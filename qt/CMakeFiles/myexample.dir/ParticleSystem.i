# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.cpp"
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.h" 1





class Particle;
class ParticleModifier;
class GravityModifier;
class WindModifier;
class ParticleEmitter;

# 1 "/usr/include/c++/4.6/vector" 1 3
# 59 "/usr/include/c++/4.6/vector" 3
       
# 60 "/usr/include/c++/4.6/vector" 3

# 1 "/usr/include/c++/4.6/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++config.h" 1 3
# 153 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;




}
# 393 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++config.h" 3
# 1 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/os_defines.h" 1 3
# 40 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 324 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/predefs.h" 1 3 4
# 325 "/usr/include/features.h" 2 3 4
# 357 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 378 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 379 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 358 "/usr/include/features.h" 2 3 4
# 389 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 390 "/usr/include/features.h" 2 3 4
# 41 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/os_defines.h" 2 3
# 394 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/cpu_defines.h" 1 3
# 397 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++config.h" 2 3
# 61 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/bits/functexcept.h" 1 3
# 41 "/usr/include/c++/4.6/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.6/bits/exception_defines.h" 1 3
# 42 "/usr/include/c++/4.6/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 62 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/bits/cpp_type_traits.h" 1 3
# 36 "/usr/include/c++/4.6/bits/cpp_type_traits.h" 3
       
# 37 "/usr/include/c++/4.6/bits/cpp_type_traits.h" 3
# 69 "/usr/include/c++/4.6/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 199 "/usr/include/c++/4.6/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 422 "/usr/include/c++/4.6/bits/cpp_type_traits.h" 3

}
# 63 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/ext/type_traits.h" 1 3
# 33 "/usr/include/c++/4.6/ext/type_traits.h" 3
       
# 34 "/usr/include/c++/4.6/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 64 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.6/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/4.6/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/4.6/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/4.6/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 65 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_pair.h" 1 3
# 60 "/usr/include/c++/4.6/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.6/bits/move.h" 1 3
# 34 "/usr/include/c++/4.6/bits/move.h" 3
# 1 "/usr/include/c++/4.6/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.6/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/4.6/bits/concept_check.h" 3
# 35 "/usr/include/c++/4.6/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
# 109 "/usr/include/c++/4.6/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 120 "/usr/include/c++/4.6/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }


}
# 61 "/usr/include/c++/4.6/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 86 "/usr/include/c++/4.6/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
# 196 "/usr/include/c++/4.6/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 270 "/usr/include/c++/4.6/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }



}
# 66 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/include/c++/4.6/bits/stl_iterator_base_types.h" 3
       
# 64 "/usr/include/c++/4.6/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "/usr/include/c++/4.6/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 117 "/usr/include/c++/4.6/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 163 "/usr/include/c++/4.6/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


}
# 67 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/include/c++/4.6/bits/stl_iterator_base_funcs.h" 3
       
# 64 "/usr/include/c++/4.6/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 111 "/usr/include/c++/4.6/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 169 "/usr/include/c++/4.6/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
# 200 "/usr/include/c++/4.6/bits/stl_iterator_base_funcs.h" 3

}
# 68 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_iterator.h" 1 3
# 68 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 96 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 283 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 395 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 422 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 445 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 471 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 486 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 512 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 535 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 561 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 580 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 623 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 649 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 675 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 699 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 797 "/usr/include/c++/4.6/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}
# 69 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.6/debug/debug.h" 1 3
# 47 "/usr/include/c++/4.6/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 71 "/usr/include/c++/4.6/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{





  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 116 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 157 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 185 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 208 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 231 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 252 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 319 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 357 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 442 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 494 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 522 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 552 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 611 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 669 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 713 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 773 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 934 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1008 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1040 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1071 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1105 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1145 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1182 "/usr/include/c++/4.6/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 62 "/usr/include/c++/4.6/vector" 2 3
# 1 "/usr/include/c++/4.6/bits/allocator.h" 1 3
# 48 "/usr/include/c++/4.6/bits/allocator.h" 3
# 1 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++allocator.h" 1 3
# 34 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.6/ext/new_allocator.h" 1 3
# 34 "/usr/include/c++/4.6/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.6/new" 1 3
# 39 "/usr/include/c++/4.6/new" 3
       
# 40 "/usr/include/c++/4.6/new" 3


# 1 "/usr/include/c++/4.6/exception" 1 3
# 35 "/usr/include/c++/4.6/exception" 3
       
# 36 "/usr/include/c++/4.6/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 61 "/usr/include/c++/4.6/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 118 "/usr/include/c++/4.6/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 143 "/usr/include/c++/4.6/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
# 43 "/usr/include/c++/4.6/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 93 "/usr/include/c++/4.6/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 35 "/usr/include/c++/4.6/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 53 "/usr/include/c++/4.6/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 117 "/usr/include/c++/4.6/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 35 "/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++allocator.h" 2 3
# 49 "/usr/include/c++/4.6/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/4.6/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 91 "/usr/include/c++/4.6/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }




  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 236 "/usr/include/c++/4.6/bits/allocator.h" 3

}
# 63 "/usr/include/c++/4.6/vector" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_construct.h" 1 3
# 64 "/usr/include/c++/4.6/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 78 "/usr/include/c++/4.6/bits/stl_construct.h" 3
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }





  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 64 "/usr/include/c++/4.6/vector" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_uninitialized.h" 1 3
# 61 "/usr/include/c++/4.6/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 107 "/usr/include/c++/4.6/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 164 "/usr/include/c++/4.6/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 218 "/usr/include/c++/4.6/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 332 "/usr/include/c++/4.6/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 652 "/usr/include/c++/4.6/bits/stl_uninitialized.h" 3

}
# 65 "/usr/include/c++/4.6/vector" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_vector.h" 1 3
# 63 "/usr/include/c++/4.6/bits/stl_vector.h" 3
# 1 "/usr/include/c++/4.6/initializer_list" 1 3
# 33 "/usr/include/c++/4.6/initializer_list" 3
       
# 34 "/usr/include/c++/4.6/initializer_list" 3
# 64 "/usr/include/c++/4.6/bits/stl_vector.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
# 141 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 179 "/usr/include/c++/4.6/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 262 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 278 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 333 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 361 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 411 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 427 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 454 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 569 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 628 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 649 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 679 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 694 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 709 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 734 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 752 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 801 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      pointer

      data()
      { return std::__addressof(front()); }




      const_pointer

      data() const
      { return std::__addressof(front()); }
# 825 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 856 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 892 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 942 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 960 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 985 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 1006 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1018 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1073 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1147 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1187 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
# 1229 "/usr/include/c++/4.6/bits/stl_vector.h" 3
      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1271 "/usr/include/c++/4.6/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1288 "/usr/include/c++/4.6/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 66 "/usr/include/c++/4.6/vector" 2 3
# 1 "/usr/include/c++/4.6/bits/stl_bvector.h" 1 3
# 62 "/usr/include/c++/4.6/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 431 "/usr/include/c++/4.6/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 478 "/usr/include/c++/4.6/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
# 547 "/usr/include/c++/4.6/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 596 "/usr/include/c++/4.6/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }







    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 664 "/usr/include/c++/4.6/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}
# 67 "/usr/include/c++/4.6/vector" 2 3
# 1 "/usr/include/c++/4.6/bits/range_access.h" 1 3
# 33 "/usr/include/c++/4.6/bits/range_access.h" 3
       
# 34 "/usr/include/c++/4.6/bits/range_access.h" 3
# 68 "/usr/include/c++/4.6/vector" 2 3


# 1 "/usr/include/c++/4.6/bits/vector.tcc" 1 3
# 60 "/usr/include/c++/4.6/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
# 106 "/usr/include/c++/4.6/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 128 "/usr/include/c++/4.6/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::copy(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 298 "/usr/include/c++/4.6/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1))
             );
   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;

   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       this->_M_impl.construct(__new_start + __elems_before,



                               __x);

       __new_finish = 0;

       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;

       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;

    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }
# 519 "/usr/include/c++/4.6/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }


}
# 71 "/usr/include/c++/4.6/vector" 2 3
# 13 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.h" 2

# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 1



# 1 "/usr/include/GL/glfw.h" 1 3 4
# 34 "/usr/include/GL/glfw.h" 3 4
extern "C" {
# 168 "/usr/include/GL/glfw.h" 3 4
# 1 "/usr/include/GL/gl.h" 1 3 4
# 135 "/usr/include/GL/gl.h" 3 4
extern "C" {
# 149 "/usr/include/GL/gl.h" 3 4
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef int GLsizei;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
# 776 "/usr/include/GL/gl.h" 3 4
__attribute__((visibility("default"))) void glClearIndex( GLfloat c );

__attribute__((visibility("default"))) void glClearColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha );

__attribute__((visibility("default"))) void glClear( GLbitfield mask );

__attribute__((visibility("default"))) void glIndexMask( GLuint mask );

__attribute__((visibility("default"))) void glColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha );

__attribute__((visibility("default"))) void glAlphaFunc( GLenum func, GLclampf ref );

__attribute__((visibility("default"))) void glBlendFunc( GLenum sfactor, GLenum dfactor );

__attribute__((visibility("default"))) void glLogicOp( GLenum opcode );

__attribute__((visibility("default"))) void glCullFace( GLenum mode );

__attribute__((visibility("default"))) void glFrontFace( GLenum mode );

__attribute__((visibility("default"))) void glPointSize( GLfloat size );

__attribute__((visibility("default"))) void glLineWidth( GLfloat width );

__attribute__((visibility("default"))) void glLineStipple( GLint factor, GLushort pattern );

__attribute__((visibility("default"))) void glPolygonMode( GLenum face, GLenum mode );

__attribute__((visibility("default"))) void glPolygonOffset( GLfloat factor, GLfloat units );

__attribute__((visibility("default"))) void glPolygonStipple( const GLubyte *mask );

__attribute__((visibility("default"))) void glGetPolygonStipple( GLubyte *mask );

__attribute__((visibility("default"))) void glEdgeFlag( GLboolean flag );

__attribute__((visibility("default"))) void glEdgeFlagv( const GLboolean *flag );

__attribute__((visibility("default"))) void glScissor( GLint x, GLint y, GLsizei width, GLsizei height);

__attribute__((visibility("default"))) void glClipPlane( GLenum plane, const GLdouble *equation );

__attribute__((visibility("default"))) void glGetClipPlane( GLenum plane, GLdouble *equation );

__attribute__((visibility("default"))) void glDrawBuffer( GLenum mode );

__attribute__((visibility("default"))) void glReadBuffer( GLenum mode );

__attribute__((visibility("default"))) void glEnable( GLenum cap );

__attribute__((visibility("default"))) void glDisable( GLenum cap );

__attribute__((visibility("default"))) GLboolean glIsEnabled( GLenum cap );


__attribute__((visibility("default"))) void glEnableClientState( GLenum cap );

__attribute__((visibility("default"))) void glDisableClientState( GLenum cap );


__attribute__((visibility("default"))) void glGetBooleanv( GLenum pname, GLboolean *params );

__attribute__((visibility("default"))) void glGetDoublev( GLenum pname, GLdouble *params );

__attribute__((visibility("default"))) void glGetFloatv( GLenum pname, GLfloat *params );

__attribute__((visibility("default"))) void glGetIntegerv( GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glPushAttrib( GLbitfield mask );

__attribute__((visibility("default"))) void glPopAttrib( void );


__attribute__((visibility("default"))) void glPushClientAttrib( GLbitfield mask );

__attribute__((visibility("default"))) void glPopClientAttrib( void );


__attribute__((visibility("default"))) GLint glRenderMode( GLenum mode );

__attribute__((visibility("default"))) GLenum glGetError( void );

__attribute__((visibility("default"))) const GLubyte * glGetString( GLenum name );

__attribute__((visibility("default"))) void glFinish( void );

__attribute__((visibility("default"))) void glFlush( void );

__attribute__((visibility("default"))) void glHint( GLenum target, GLenum mode );






__attribute__((visibility("default"))) void glClearDepth( GLclampd depth );

__attribute__((visibility("default"))) void glDepthFunc( GLenum func );

__attribute__((visibility("default"))) void glDepthMask( GLboolean flag );

__attribute__((visibility("default"))) void glDepthRange( GLclampd near_val, GLclampd far_val );






__attribute__((visibility("default"))) void glClearAccum( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );

__attribute__((visibility("default"))) void glAccum( GLenum op, GLfloat value );






__attribute__((visibility("default"))) void glMatrixMode( GLenum mode );

__attribute__((visibility("default"))) void glOrtho( GLdouble left, GLdouble right,
                                 GLdouble bottom, GLdouble top,
                                 GLdouble near_val, GLdouble far_val );

__attribute__((visibility("default"))) void glFrustum( GLdouble left, GLdouble right,
                                   GLdouble bottom, GLdouble top,
                                   GLdouble near_val, GLdouble far_val );

__attribute__((visibility("default"))) void glViewport( GLint x, GLint y,
                                    GLsizei width, GLsizei height );

__attribute__((visibility("default"))) void glPushMatrix( void );

__attribute__((visibility("default"))) void glPopMatrix( void );

__attribute__((visibility("default"))) void glLoadIdentity( void );

__attribute__((visibility("default"))) void glLoadMatrixd( const GLdouble *m );
__attribute__((visibility("default"))) void glLoadMatrixf( const GLfloat *m );

__attribute__((visibility("default"))) void glMultMatrixd( const GLdouble *m );
__attribute__((visibility("default"))) void glMultMatrixf( const GLfloat *m );

__attribute__((visibility("default"))) void glRotated( GLdouble angle,
                                   GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glRotatef( GLfloat angle,
                                   GLfloat x, GLfloat y, GLfloat z );

__attribute__((visibility("default"))) void glScaled( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glScalef( GLfloat x, GLfloat y, GLfloat z );

__attribute__((visibility("default"))) void glTranslated( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glTranslatef( GLfloat x, GLfloat y, GLfloat z );






__attribute__((visibility("default"))) GLboolean glIsList( GLuint list );

__attribute__((visibility("default"))) void glDeleteLists( GLuint list, GLsizei range );

__attribute__((visibility("default"))) GLuint glGenLists( GLsizei range );

__attribute__((visibility("default"))) void glNewList( GLuint list, GLenum mode );

__attribute__((visibility("default"))) void glEndList( void );

__attribute__((visibility("default"))) void glCallList( GLuint list );

__attribute__((visibility("default"))) void glCallLists( GLsizei n, GLenum type,
                                     const GLvoid *lists );

__attribute__((visibility("default"))) void glListBase( GLuint base );






__attribute__((visibility("default"))) void glBegin( GLenum mode );

__attribute__((visibility("default"))) void glEnd( void );


__attribute__((visibility("default"))) void glVertex2d( GLdouble x, GLdouble y );
__attribute__((visibility("default"))) void glVertex2f( GLfloat x, GLfloat y );
__attribute__((visibility("default"))) void glVertex2i( GLint x, GLint y );
__attribute__((visibility("default"))) void glVertex2s( GLshort x, GLshort y );

__attribute__((visibility("default"))) void glVertex3d( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glVertex3f( GLfloat x, GLfloat y, GLfloat z );
__attribute__((visibility("default"))) void glVertex3i( GLint x, GLint y, GLint z );
__attribute__((visibility("default"))) void glVertex3s( GLshort x, GLshort y, GLshort z );

__attribute__((visibility("default"))) void glVertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
__attribute__((visibility("default"))) void glVertex4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
__attribute__((visibility("default"))) void glVertex4i( GLint x, GLint y, GLint z, GLint w );
__attribute__((visibility("default"))) void glVertex4s( GLshort x, GLshort y, GLshort z, GLshort w );

__attribute__((visibility("default"))) void glVertex2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex2iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex2sv( const GLshort *v );

__attribute__((visibility("default"))) void glVertex3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex3iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex3sv( const GLshort *v );

__attribute__((visibility("default"))) void glVertex4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex4iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex4sv( const GLshort *v );


__attribute__((visibility("default"))) void glNormal3b( GLbyte nx, GLbyte ny, GLbyte nz );
__attribute__((visibility("default"))) void glNormal3d( GLdouble nx, GLdouble ny, GLdouble nz );
__attribute__((visibility("default"))) void glNormal3f( GLfloat nx, GLfloat ny, GLfloat nz );
__attribute__((visibility("default"))) void glNormal3i( GLint nx, GLint ny, GLint nz );
__attribute__((visibility("default"))) void glNormal3s( GLshort nx, GLshort ny, GLshort nz );

__attribute__((visibility("default"))) void glNormal3bv( const GLbyte *v );
__attribute__((visibility("default"))) void glNormal3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glNormal3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glNormal3iv( const GLint *v );
__attribute__((visibility("default"))) void glNormal3sv( const GLshort *v );


__attribute__((visibility("default"))) void glIndexd( GLdouble c );
__attribute__((visibility("default"))) void glIndexf( GLfloat c );
__attribute__((visibility("default"))) void glIndexi( GLint c );
__attribute__((visibility("default"))) void glIndexs( GLshort c );
__attribute__((visibility("default"))) void glIndexub( GLubyte c );

__attribute__((visibility("default"))) void glIndexdv( const GLdouble *c );
__attribute__((visibility("default"))) void glIndexfv( const GLfloat *c );
__attribute__((visibility("default"))) void glIndexiv( const GLint *c );
__attribute__((visibility("default"))) void glIndexsv( const GLshort *c );
__attribute__((visibility("default"))) void glIndexubv( const GLubyte *c );

__attribute__((visibility("default"))) void glColor3b( GLbyte red, GLbyte green, GLbyte blue );
__attribute__((visibility("default"))) void glColor3d( GLdouble red, GLdouble green, GLdouble blue );
__attribute__((visibility("default"))) void glColor3f( GLfloat red, GLfloat green, GLfloat blue );
__attribute__((visibility("default"))) void glColor3i( GLint red, GLint green, GLint blue );
__attribute__((visibility("default"))) void glColor3s( GLshort red, GLshort green, GLshort blue );
__attribute__((visibility("default"))) void glColor3ub( GLubyte red, GLubyte green, GLubyte blue );
__attribute__((visibility("default"))) void glColor3ui( GLuint red, GLuint green, GLuint blue );
__attribute__((visibility("default"))) void glColor3us( GLushort red, GLushort green, GLushort blue );

__attribute__((visibility("default"))) void glColor4b( GLbyte red, GLbyte green,
                                   GLbyte blue, GLbyte alpha );
__attribute__((visibility("default"))) void glColor4d( GLdouble red, GLdouble green,
                                   GLdouble blue, GLdouble alpha );
__attribute__((visibility("default"))) void glColor4f( GLfloat red, GLfloat green,
                                   GLfloat blue, GLfloat alpha );
__attribute__((visibility("default"))) void glColor4i( GLint red, GLint green,
                                   GLint blue, GLint alpha );
__attribute__((visibility("default"))) void glColor4s( GLshort red, GLshort green,
                                   GLshort blue, GLshort alpha );
__attribute__((visibility("default"))) void glColor4ub( GLubyte red, GLubyte green,
                                    GLubyte blue, GLubyte alpha );
__attribute__((visibility("default"))) void glColor4ui( GLuint red, GLuint green,
                                    GLuint blue, GLuint alpha );
__attribute__((visibility("default"))) void glColor4us( GLushort red, GLushort green,
                                    GLushort blue, GLushort alpha );


__attribute__((visibility("default"))) void glColor3bv( const GLbyte *v );
__attribute__((visibility("default"))) void glColor3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glColor3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glColor3iv( const GLint *v );
__attribute__((visibility("default"))) void glColor3sv( const GLshort *v );
__attribute__((visibility("default"))) void glColor3ubv( const GLubyte *v );
__attribute__((visibility("default"))) void glColor3uiv( const GLuint *v );
__attribute__((visibility("default"))) void glColor3usv( const GLushort *v );

__attribute__((visibility("default"))) void glColor4bv( const GLbyte *v );
__attribute__((visibility("default"))) void glColor4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glColor4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glColor4iv( const GLint *v );
__attribute__((visibility("default"))) void glColor4sv( const GLshort *v );
__attribute__((visibility("default"))) void glColor4ubv( const GLubyte *v );
__attribute__((visibility("default"))) void glColor4uiv( const GLuint *v );
__attribute__((visibility("default"))) void glColor4usv( const GLushort *v );


__attribute__((visibility("default"))) void glTexCoord1d( GLdouble s );
__attribute__((visibility("default"))) void glTexCoord1f( GLfloat s );
__attribute__((visibility("default"))) void glTexCoord1i( GLint s );
__attribute__((visibility("default"))) void glTexCoord1s( GLshort s );

__attribute__((visibility("default"))) void glTexCoord2d( GLdouble s, GLdouble t );
__attribute__((visibility("default"))) void glTexCoord2f( GLfloat s, GLfloat t );
__attribute__((visibility("default"))) void glTexCoord2i( GLint s, GLint t );
__attribute__((visibility("default"))) void glTexCoord2s( GLshort s, GLshort t );

__attribute__((visibility("default"))) void glTexCoord3d( GLdouble s, GLdouble t, GLdouble r );
__attribute__((visibility("default"))) void glTexCoord3f( GLfloat s, GLfloat t, GLfloat r );
__attribute__((visibility("default"))) void glTexCoord3i( GLint s, GLint t, GLint r );
__attribute__((visibility("default"))) void glTexCoord3s( GLshort s, GLshort t, GLshort r );

__attribute__((visibility("default"))) void glTexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
__attribute__((visibility("default"))) void glTexCoord4f( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
__attribute__((visibility("default"))) void glTexCoord4i( GLint s, GLint t, GLint r, GLint q );
__attribute__((visibility("default"))) void glTexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q );

__attribute__((visibility("default"))) void glTexCoord1dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord1fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord1iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord1sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord2iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord2sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord3iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord3sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord4iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord4sv( const GLshort *v );


__attribute__((visibility("default"))) void glRasterPos2d( GLdouble x, GLdouble y );
__attribute__((visibility("default"))) void glRasterPos2f( GLfloat x, GLfloat y );
__attribute__((visibility("default"))) void glRasterPos2i( GLint x, GLint y );
__attribute__((visibility("default"))) void glRasterPos2s( GLshort x, GLshort y );

__attribute__((visibility("default"))) void glRasterPos3d( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glRasterPos3f( GLfloat x, GLfloat y, GLfloat z );
__attribute__((visibility("default"))) void glRasterPos3i( GLint x, GLint y, GLint z );
__attribute__((visibility("default"))) void glRasterPos3s( GLshort x, GLshort y, GLshort z );

__attribute__((visibility("default"))) void glRasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
__attribute__((visibility("default"))) void glRasterPos4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
__attribute__((visibility("default"))) void glRasterPos4i( GLint x, GLint y, GLint z, GLint w );
__attribute__((visibility("default"))) void glRasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w );

__attribute__((visibility("default"))) void glRasterPos2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos2iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos2sv( const GLshort *v );

__attribute__((visibility("default"))) void glRasterPos3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos3iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos3sv( const GLshort *v );

__attribute__((visibility("default"))) void glRasterPos4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos4iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos4sv( const GLshort *v );


__attribute__((visibility("default"))) void glRectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
__attribute__((visibility("default"))) void glRectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 );
__attribute__((visibility("default"))) void glRecti( GLint x1, GLint y1, GLint x2, GLint y2 );
__attribute__((visibility("default"))) void glRects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );


__attribute__((visibility("default"))) void glRectdv( const GLdouble *v1, const GLdouble *v2 );
__attribute__((visibility("default"))) void glRectfv( const GLfloat *v1, const GLfloat *v2 );
__attribute__((visibility("default"))) void glRectiv( const GLint *v1, const GLint *v2 );
__attribute__((visibility("default"))) void glRectsv( const GLshort *v1, const GLshort *v2 );






__attribute__((visibility("default"))) void glVertexPointer( GLint size, GLenum type,
                                       GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glNormalPointer( GLenum type, GLsizei stride,
                                       const GLvoid *ptr );

__attribute__((visibility("default"))) void glColorPointer( GLint size, GLenum type,
                                      GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glIndexPointer( GLenum type, GLsizei stride,
                                      const GLvoid *ptr );

__attribute__((visibility("default"))) void glTexCoordPointer( GLint size, GLenum type,
                                         GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glEdgeFlagPointer( GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glGetPointerv( GLenum pname, GLvoid **params );

__attribute__((visibility("default"))) void glArrayElement( GLint i );

__attribute__((visibility("default"))) void glDrawArrays( GLenum mode, GLint first, GLsizei count );

__attribute__((visibility("default"))) void glDrawElements( GLenum mode, GLsizei count,
                                      GLenum type, const GLvoid *indices );

__attribute__((visibility("default"))) void glInterleavedArrays( GLenum format, GLsizei stride,
                                           const GLvoid *pointer );





__attribute__((visibility("default"))) void glShadeModel( GLenum mode );

__attribute__((visibility("default"))) void glLightf( GLenum light, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glLighti( GLenum light, GLenum pname, GLint param );
__attribute__((visibility("default"))) void glLightfv( GLenum light, GLenum pname,
                                 const GLfloat *params );
__attribute__((visibility("default"))) void glLightiv( GLenum light, GLenum pname,
                                 const GLint *params );

__attribute__((visibility("default"))) void glGetLightfv( GLenum light, GLenum pname,
                                    GLfloat *params );
__attribute__((visibility("default"))) void glGetLightiv( GLenum light, GLenum pname,
                                    GLint *params );

__attribute__((visibility("default"))) void glLightModelf( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glLightModeli( GLenum pname, GLint param );
__attribute__((visibility("default"))) void glLightModelfv( GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glLightModeliv( GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glMaterialf( GLenum face, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glMateriali( GLenum face, GLenum pname, GLint param );
__attribute__((visibility("default"))) void glMaterialfv( GLenum face, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glMaterialiv( GLenum face, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetMaterialfv( GLenum face, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetMaterialiv( GLenum face, GLenum pname, GLint *params );

__attribute__((visibility("default"))) void glColorMaterial( GLenum face, GLenum mode );






__attribute__((visibility("default"))) void glPixelZoom( GLfloat xfactor, GLfloat yfactor );

__attribute__((visibility("default"))) void glPixelStoref( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glPixelStorei( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glPixelTransferf( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glPixelTransferi( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glPixelMapfv( GLenum map, GLsizei mapsize,
                                    const GLfloat *values );
__attribute__((visibility("default"))) void glPixelMapuiv( GLenum map, GLsizei mapsize,
                                     const GLuint *values );
__attribute__((visibility("default"))) void glPixelMapusv( GLenum map, GLsizei mapsize,
                                     const GLushort *values );

__attribute__((visibility("default"))) void glGetPixelMapfv( GLenum map, GLfloat *values );
__attribute__((visibility("default"))) void glGetPixelMapuiv( GLenum map, GLuint *values );
__attribute__((visibility("default"))) void glGetPixelMapusv( GLenum map, GLushort *values );

__attribute__((visibility("default"))) void glBitmap( GLsizei width, GLsizei height,
                                GLfloat xorig, GLfloat yorig,
                                GLfloat xmove, GLfloat ymove,
                                const GLubyte *bitmap );

__attribute__((visibility("default"))) void glReadPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    GLvoid *pixels );

__attribute__((visibility("default"))) void glDrawPixels( GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glCopyPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum type );





__attribute__((visibility("default"))) void glStencilFunc( GLenum func, GLint ref, GLuint mask );

__attribute__((visibility("default"))) void glStencilMask( GLuint mask );

__attribute__((visibility("default"))) void glStencilOp( GLenum fail, GLenum zfail, GLenum zpass );

__attribute__((visibility("default"))) void glClearStencil( GLint s );







__attribute__((visibility("default"))) void glTexGend( GLenum coord, GLenum pname, GLdouble param );
__attribute__((visibility("default"))) void glTexGenf( GLenum coord, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexGeni( GLenum coord, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexGendv( GLenum coord, GLenum pname, const GLdouble *params );
__attribute__((visibility("default"))) void glTexGenfv( GLenum coord, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glTexGeniv( GLenum coord, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetTexGendv( GLenum coord, GLenum pname, GLdouble *params );
__attribute__((visibility("default"))) void glGetTexGenfv( GLenum coord, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexGeniv( GLenum coord, GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexEnvf( GLenum target, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexEnvi( GLenum target, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexEnvfv( GLenum target, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glTexEnviv( GLenum target, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetTexEnvfv( GLenum target, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexEnviv( GLenum target, GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexParameterf( GLenum target, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexParameteri( GLenum target, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexParameterfv( GLenum target, GLenum pname,
                                          const GLfloat *params );
__attribute__((visibility("default"))) void glTexParameteriv( GLenum target, GLenum pname,
                                          const GLint *params );

__attribute__((visibility("default"))) void glGetTexParameterfv( GLenum target,
                                           GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) void glGetTexParameteriv( GLenum target,
                                           GLenum pname, GLint *params );

__attribute__((visibility("default"))) void glGetTexLevelParameterfv( GLenum target, GLint level,
                                                GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexLevelParameteriv( GLenum target, GLint level,
                                                GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexImage1D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLint border,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glTexImage2D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLsizei height,
                                    GLint border, GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glGetTexImage( GLenum target, GLint level,
                                     GLenum format, GLenum type,
                                     GLvoid *pixels );




__attribute__((visibility("default"))) void glGenTextures( GLsizei n, GLuint *textures );

__attribute__((visibility("default"))) void glDeleteTextures( GLsizei n, const GLuint *textures);

__attribute__((visibility("default"))) void glBindTexture( GLenum target, GLuint texture );

__attribute__((visibility("default"))) void glPrioritizeTextures( GLsizei n,
                                            const GLuint *textures,
                                            const GLclampf *priorities );

__attribute__((visibility("default"))) GLboolean glAreTexturesResident( GLsizei n,
                                                  const GLuint *textures,
                                                  GLboolean *residences );

__attribute__((visibility("default"))) GLboolean glIsTexture( GLuint texture );


__attribute__((visibility("default"))) void glTexSubImage1D( GLenum target, GLint level,
                                       GLint xoffset,
                                       GLsizei width, GLenum format,
                                       GLenum type, const GLvoid *pixels );


__attribute__((visibility("default"))) void glTexSubImage2D( GLenum target, GLint level,
                                       GLint xoffset, GLint yoffset,
                                       GLsizei width, GLsizei height,
                                       GLenum format, GLenum type,
                                       const GLvoid *pixels );


__attribute__((visibility("default"))) void glCopyTexImage1D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLint border );


__attribute__((visibility("default"))) void glCopyTexImage2D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLsizei height,
                                        GLint border );


__attribute__((visibility("default"))) void glCopyTexSubImage1D( GLenum target, GLint level,
                                           GLint xoffset, GLint x, GLint y,
                                           GLsizei width );


__attribute__((visibility("default"))) void glCopyTexSubImage2D( GLenum target, GLint level,
                                           GLint xoffset, GLint yoffset,
                                           GLint x, GLint y,
                                           GLsizei width, GLsizei height );






__attribute__((visibility("default"))) void glMap1d( GLenum target, GLdouble u1, GLdouble u2,
                               GLint stride,
                               GLint order, const GLdouble *points );
__attribute__((visibility("default"))) void glMap1f( GLenum target, GLfloat u1, GLfloat u2,
                               GLint stride,
                               GLint order, const GLfloat *points );

__attribute__((visibility("default"))) void glMap2d( GLenum target,
       GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
       GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
       const GLdouble *points );
__attribute__((visibility("default"))) void glMap2f( GLenum target,
       GLfloat u1, GLfloat u2, GLint ustride, GLint uorder,
       GLfloat v1, GLfloat v2, GLint vstride, GLint vorder,
       const GLfloat *points );

__attribute__((visibility("default"))) void glGetMapdv( GLenum target, GLenum query, GLdouble *v );
__attribute__((visibility("default"))) void glGetMapfv( GLenum target, GLenum query, GLfloat *v );
__attribute__((visibility("default"))) void glGetMapiv( GLenum target, GLenum query, GLint *v );

__attribute__((visibility("default"))) void glEvalCoord1d( GLdouble u );
__attribute__((visibility("default"))) void glEvalCoord1f( GLfloat u );

__attribute__((visibility("default"))) void glEvalCoord1dv( const GLdouble *u );
__attribute__((visibility("default"))) void glEvalCoord1fv( const GLfloat *u );

__attribute__((visibility("default"))) void glEvalCoord2d( GLdouble u, GLdouble v );
__attribute__((visibility("default"))) void glEvalCoord2f( GLfloat u, GLfloat v );

__attribute__((visibility("default"))) void glEvalCoord2dv( const GLdouble *u );
__attribute__((visibility("default"))) void glEvalCoord2fv( const GLfloat *u );

__attribute__((visibility("default"))) void glMapGrid1d( GLint un, GLdouble u1, GLdouble u2 );
__attribute__((visibility("default"))) void glMapGrid1f( GLint un, GLfloat u1, GLfloat u2 );

__attribute__((visibility("default"))) void glMapGrid2d( GLint un, GLdouble u1, GLdouble u2,
                                   GLint vn, GLdouble v1, GLdouble v2 );
__attribute__((visibility("default"))) void glMapGrid2f( GLint un, GLfloat u1, GLfloat u2,
                                   GLint vn, GLfloat v1, GLfloat v2 );

__attribute__((visibility("default"))) void glEvalPoint1( GLint i );

__attribute__((visibility("default"))) void glEvalPoint2( GLint i, GLint j );

__attribute__((visibility("default"))) void glEvalMesh1( GLenum mode, GLint i1, GLint i2 );

__attribute__((visibility("default"))) void glEvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );






__attribute__((visibility("default"))) void glFogf( GLenum pname, GLfloat param );

__attribute__((visibility("default"))) void glFogi( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glFogfv( GLenum pname, const GLfloat *params );

__attribute__((visibility("default"))) void glFogiv( GLenum pname, const GLint *params );






__attribute__((visibility("default"))) void glFeedbackBuffer( GLsizei size, GLenum type, GLfloat *buffer );

__attribute__((visibility("default"))) void glPassThrough( GLfloat token );

__attribute__((visibility("default"))) void glSelectBuffer( GLsizei size, GLuint *buffer );

__attribute__((visibility("default"))) void glInitNames( void );

__attribute__((visibility("default"))) void glLoadName( GLuint name );

__attribute__((visibility("default"))) void glPushName( GLuint name );

__attribute__((visibility("default"))) void glPopName( void );
# 1521 "/usr/include/GL/gl.h" 3 4
__attribute__((visibility("default"))) void glDrawRangeElements( GLenum mode, GLuint start,
 GLuint end, GLsizei count, GLenum type, const GLvoid *indices );

__attribute__((visibility("default"))) void glTexImage3D( GLenum target, GLint level,
                                      GLint internalFormat,
                                      GLsizei width, GLsizei height,
                                      GLsizei depth, GLint border,
                                      GLenum format, GLenum type,
                                      const GLvoid *pixels );

__attribute__((visibility("default"))) void glTexSubImage3D( GLenum target, GLint level,
                                         GLint xoffset, GLint yoffset,
                                         GLint zoffset, GLsizei width,
                                         GLsizei height, GLsizei depth,
                                         GLenum format,
                                         GLenum type, const GLvoid *pixels);

__attribute__((visibility("default"))) void glCopyTexSubImage3D( GLenum target, GLint level,
                                             GLint xoffset, GLint yoffset,
                                             GLint zoffset, GLint x,
                                             GLint y, GLsizei width,
                                             GLsizei height );

typedef void ( * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void ( * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 1631 "/usr/include/GL/gl.h" 3 4
__attribute__((visibility("default"))) void glColorTable( GLenum target, GLenum internalformat,
                                    GLsizei width, GLenum format,
                                    GLenum type, const GLvoid *table );

__attribute__((visibility("default"))) void glColorSubTable( GLenum target,
                                       GLsizei start, GLsizei count,
                                       GLenum format, GLenum type,
                                       const GLvoid *data );

__attribute__((visibility("default"))) void glColorTableParameteriv(GLenum target, GLenum pname,
                                              const GLint *params);

__attribute__((visibility("default"))) void glColorTableParameterfv(GLenum target, GLenum pname,
                                              const GLfloat *params);

__attribute__((visibility("default"))) void glCopyColorSubTable( GLenum target, GLsizei start,
                                           GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glCopyColorTable( GLenum target, GLenum internalformat,
                                        GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glGetColorTable( GLenum target, GLenum format,
                                       GLenum type, GLvoid *table );

__attribute__((visibility("default"))) void glGetColorTableParameterfv( GLenum target, GLenum pname,
                                                  GLfloat *params );

__attribute__((visibility("default"))) void glGetColorTableParameteriv( GLenum target, GLenum pname,
                                                  GLint *params );

__attribute__((visibility("default"))) void glBlendEquation( GLenum mode );

__attribute__((visibility("default"))) void glBlendColor( GLclampf red, GLclampf green,
                                    GLclampf blue, GLclampf alpha );

__attribute__((visibility("default"))) void glHistogram( GLenum target, GLsizei width,
       GLenum internalformat, GLboolean sink );

__attribute__((visibility("default"))) void glResetHistogram( GLenum target );

__attribute__((visibility("default"))) void glGetHistogram( GLenum target, GLboolean reset,
          GLenum format, GLenum type,
          GLvoid *values );

__attribute__((visibility("default"))) void glGetHistogramParameterfv( GLenum target, GLenum pname,
       GLfloat *params );

__attribute__((visibility("default"))) void glGetHistogramParameteriv( GLenum target, GLenum pname,
       GLint *params );

__attribute__((visibility("default"))) void glMinmax( GLenum target, GLenum internalformat,
    GLboolean sink );

__attribute__((visibility("default"))) void glResetMinmax( GLenum target );

__attribute__((visibility("default"))) void glGetMinmax( GLenum target, GLboolean reset,
                                   GLenum format, GLenum types,
                                   GLvoid *values );

__attribute__((visibility("default"))) void glGetMinmaxParameterfv( GLenum target, GLenum pname,
           GLfloat *params );

__attribute__((visibility("default"))) void glGetMinmaxParameteriv( GLenum target, GLenum pname,
           GLint *params );

__attribute__((visibility("default"))) void glConvolutionFilter1D( GLenum target,
 GLenum internalformat, GLsizei width, GLenum format, GLenum type,
 const GLvoid *image );

__attribute__((visibility("default"))) void glConvolutionFilter2D( GLenum target,
 GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
 GLenum type, const GLvoid *image );

__attribute__((visibility("default"))) void glConvolutionParameterf( GLenum target, GLenum pname,
 GLfloat params );

__attribute__((visibility("default"))) void glConvolutionParameterfv( GLenum target, GLenum pname,
 const GLfloat *params );

__attribute__((visibility("default"))) void glConvolutionParameteri( GLenum target, GLenum pname,
 GLint params );

__attribute__((visibility("default"))) void glConvolutionParameteriv( GLenum target, GLenum pname,
 const GLint *params );

__attribute__((visibility("default"))) void glCopyConvolutionFilter1D( GLenum target,
 GLenum internalformat, GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glCopyConvolutionFilter2D( GLenum target,
 GLenum internalformat, GLint x, GLint y, GLsizei width,
 GLsizei height);

__attribute__((visibility("default"))) void glGetConvolutionFilter( GLenum target, GLenum format,
 GLenum type, GLvoid *image );

__attribute__((visibility("default"))) void glGetConvolutionParameterfv( GLenum target, GLenum pname,
 GLfloat *params );

__attribute__((visibility("default"))) void glGetConvolutionParameteriv( GLenum target, GLenum pname,
 GLint *params );

__attribute__((visibility("default"))) void glSeparableFilter2D( GLenum target,
 GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
 GLenum type, const GLvoid *row, const GLvoid *column );

__attribute__((visibility("default"))) void glGetSeparableFilter( GLenum target, GLenum format,
 GLenum type, GLvoid *row, GLvoid *column, GLvoid *span );

typedef void ( * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void ( * PFNGLBLENDEQUATIONPROC) (GLenum mode);
# 1853 "/usr/include/GL/gl.h" 3 4
__attribute__((visibility("default"))) void glActiveTexture( GLenum texture );

__attribute__((visibility("default"))) void glClientActiveTexture( GLenum texture );

__attribute__((visibility("default"))) void glCompressedTexImage1D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexImage2D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexImage3D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glGetCompressedTexImage( GLenum target, GLint lod, GLvoid *img );

__attribute__((visibility("default"))) void glMultiTexCoord1d( GLenum target, GLdouble s );

__attribute__((visibility("default"))) void glMultiTexCoord1dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord1f( GLenum target, GLfloat s );

__attribute__((visibility("default"))) void glMultiTexCoord1fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord1i( GLenum target, GLint s );

__attribute__((visibility("default"))) void glMultiTexCoord1iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord1s( GLenum target, GLshort s );

__attribute__((visibility("default"))) void glMultiTexCoord1sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord2d( GLenum target, GLdouble s, GLdouble t );

__attribute__((visibility("default"))) void glMultiTexCoord2dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord2f( GLenum target, GLfloat s, GLfloat t );

__attribute__((visibility("default"))) void glMultiTexCoord2fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord2i( GLenum target, GLint s, GLint t );

__attribute__((visibility("default"))) void glMultiTexCoord2iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord2s( GLenum target, GLshort s, GLshort t );

__attribute__((visibility("default"))) void glMultiTexCoord2sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord3d( GLenum target, GLdouble s, GLdouble t, GLdouble r );

__attribute__((visibility("default"))) void glMultiTexCoord3dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord3f( GLenum target, GLfloat s, GLfloat t, GLfloat r );

__attribute__((visibility("default"))) void glMultiTexCoord3fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord3i( GLenum target, GLint s, GLint t, GLint r );

__attribute__((visibility("default"))) void glMultiTexCoord3iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord3s( GLenum target, GLshort s, GLshort t, GLshort r );

__attribute__((visibility("default"))) void glMultiTexCoord3sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord4d( GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q );

__attribute__((visibility("default"))) void glMultiTexCoord4dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord4f( GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q );

__attribute__((visibility("default"))) void glMultiTexCoord4fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord4i( GLenum target, GLint s, GLint t, GLint r, GLint q );

__attribute__((visibility("default"))) void glMultiTexCoord4iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord4s( GLenum target, GLshort s, GLshort t, GLshort r, GLshort q );

__attribute__((visibility("default"))) void glMultiTexCoord4sv( GLenum target, const GLshort *v );


__attribute__((visibility("default"))) void glLoadTransposeMatrixd( const GLdouble m[16] );

__attribute__((visibility("default"))) void glLoadTransposeMatrixf( const GLfloat m[16] );

__attribute__((visibility("default"))) void glMultTransposeMatrixd( const GLdouble m[16] );

__attribute__((visibility("default"))) void glMultTransposeMatrixf( const GLfloat m[16] );

__attribute__((visibility("default"))) void glSampleCoverage( GLclampf value, GLboolean invert );


typedef void ( * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, GLvoid *img);
# 2001 "/usr/include/GL/gl.h" 3 4
__attribute__((visibility("default"))) void glActiveTextureARB(GLenum texture);
__attribute__((visibility("default"))) void glClientActiveTextureARB(GLenum texture);
__attribute__((visibility("default"))) void glMultiTexCoord1dARB(GLenum target, GLdouble s);
__attribute__((visibility("default"))) void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord1fARB(GLenum target, GLfloat s);
__attribute__((visibility("default"))) void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord1iARB(GLenum target, GLint s);
__attribute__((visibility("default"))) void glMultiTexCoord1ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord1sARB(GLenum target, GLshort s);
__attribute__((visibility("default"))) void glMultiTexCoord1svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
__attribute__((visibility("default"))) void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
__attribute__((visibility("default"))) void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
__attribute__((visibility("default"))) void glMultiTexCoord2ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
__attribute__((visibility("default"))) void glMultiTexCoord2svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
__attribute__((visibility("default"))) void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
__attribute__((visibility("default"))) void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
__attribute__((visibility("default"))) void glMultiTexCoord3ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
__attribute__((visibility("default"))) void glMultiTexCoord3svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__attribute__((visibility("default"))) void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__attribute__((visibility("default"))) void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
__attribute__((visibility("default"))) void glMultiTexCoord4ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
__attribute__((visibility("default"))) void glMultiTexCoord4svARB(GLenum target, const GLshort *v);

typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 2085 "/usr/include/GL/gl.h" 3 4
# 1 "/usr/include/GL/glext.h" 1 3 4




extern "C" {
# 5319 "/usr/include/GL/glext.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 150 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 5320 "/usr/include/GL/glext.h" 2 3 4


typedef char GLchar;




typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;




typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;




typedef char GLcharARB;
typedef unsigned int GLhandleARB;




typedef unsigned short GLhalfARB;



typedef unsigned short GLhalfNV;
# 5386 "/usr/include/GL/glext.h" 3 4
# 1 "/usr/include/inttypes.h" 1 3 4
# 28 "/usr/include/inttypes.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdint.h" 1 3 4


# 1 "/usr/include/stdint.h" 1 3 4
# 27 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 37 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;







typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 66 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 91 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 104 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 120 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 135 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 4 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdint.h" 2 3 4
# 29 "/usr/include/inttypes.h" 2 3 4
# 274 "/usr/include/inttypes.h" 3 4
extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 298 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) throw () __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      throw () __attribute__ ((__const__));


extern intmax_t strtoimax (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base) throw ();


extern uintmax_t strtoumax (__const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) throw ();


extern intmax_t wcstoimax (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();


extern uintmax_t wcstoumax (__const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     throw ();
# 442 "/usr/include/inttypes.h" 3 4
}
# 5387 "/usr/include/GL/glext.h" 2 3 4




typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;



typedef int64_t GLint64;
typedef uint64_t GLuint64;
typedef struct __GLsync *GLsync;




struct _cl_context;
struct _cl_event;



typedef void ( *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);



typedef void ( *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,GLvoid *userParam);



typedef GLintptr GLvdpauSurfaceNV;
# 5473 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
# 5572 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat *m);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble *m);
# 5622 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void ( * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
typedef void ( * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
# 5673 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void ( * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVPROC) (const GLshort *v);
# 5736 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISQUERYPROC) (GLuint id);
typedef void ( * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLENDQUERYPROC) (GLenum target);
typedef void ( * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
typedef void ( * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
typedef void ( * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean ( * PFNGLISBUFFERPROC) (GLuint buffer);
typedef void ( * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef void ( * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef GLvoid* ( * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERPROC) (GLenum target);
typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid* *params);
# 5854 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum *bufs);
typedef void ( * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void ( * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar *name);
typedef void ( * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint ( * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint ( * PFNGLCREATESHADERPROC) (GLenum type);
typedef void ( * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void ( * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj);
typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void ( * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void ( * PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat *params);
typedef void ( * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean ( * PFNGLISSHADERPROC) (GLuint shader);
typedef void ( * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar* *string, const GLint *length);
typedef void ( * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
# 5959 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 6033 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLORMASKIPROC) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLGETBOOLEANI_VPROC) (GLenum target, GLuint index, GLboolean *data);
typedef void ( * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint *data);
typedef void ( * PFNGLENABLEIPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLDISABLEIPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDIPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar* *varyings, GLenum bufferMode);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void ( * PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint *params);
typedef void ( * PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawbuffer, const GLint *value);
typedef void ( * PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawbuffer, const GLuint *value);
typedef void ( * PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawbuffer, const GLfloat *value);
typedef void ( * PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef const GLubyte * ( * PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
# 6104 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
typedef void ( * PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint index);
# 6122 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETINTEGER64I_VPROC) (GLenum target, GLuint index, GLint64 *data);
typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum pname, GLint64 *params);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
# 6142 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
# 6166 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);
typedef void ( * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
# 6282 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);







typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 6315 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint level, GLvoid *img);
# 6334 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat *params);
# 6352 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, const GLbyte *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, const GLshort *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, const GLint *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, const GLfloat *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, const GLdouble *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, const GLubyte *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, const GLushort *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, const GLuint *weights);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
# 6373 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, const GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, const GLushort *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, const GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 6428 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort *v);
# 6512 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint *programs);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
# 6596 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
typedef GLvoid* ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid* *params);
# 6621 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint *params);
# 6674 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB* *string, const GLint *length);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint *params);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat *params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint *params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
# 6722 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
# 6752 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum *bufs);
# 6764 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 6789 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
# 6817 "/usr/include/GL/glext.h" 3 4
typedef GLboolean ( * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void ( * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint *renderbuffers);
typedef void ( * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint *renderbuffers);
typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef void ( * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint *framebuffers);
typedef void ( * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint *framebuffers);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void ( * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void ( * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 6851 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
# 6866 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
# 6875 "/usr/include/GL/glext.h" 3 4
typedef GLvoid* ( * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);







typedef void ( * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 6903 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint *arrays);
typedef void ( * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint *arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYPROC) (GLuint array);
# 6920 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* *uniformNames, GLuint *uniformIndices);
typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar *uniformBlockName);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
# 6938 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
# 6957 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount, const GLint *basevertex);
# 6972 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
# 6990 "/usr/include/GL/glext.h" 3 4
typedef GLsync ( * PFNGLFENCESYNCPROC) (GLenum condition, GLbitfield flags);
typedef GLboolean ( * PFNGLISSYNCPROC) (GLsync sync);
typedef void ( * PFNGLDELETESYNCPROC) (GLsync sync);
typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void ( * PFNGLWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void ( * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64 *params);
typedef void ( * PFNGLGETSYNCIVPROC) (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
# 7007 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat *val);
typedef void ( * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
# 7025 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);







typedef void ( * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);
# 7061 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
typedef void ( * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name);
typedef void ( * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* *path, const GLint *length);
typedef GLboolean ( * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name);
typedef void ( * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void ( * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar *name, GLenum pname, GLint *params);
# 7079 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar *name);
# 7109 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint *samplers);
typedef void ( * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint *samplers);
typedef GLboolean ( * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void ( * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void ( * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void ( * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
typedef void ( * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void ( * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat *param);
typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint *param);
typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint *params);
# 7144 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
typedef void ( * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64 *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64 *params);
# 7191 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint *value);
typedef void ( * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint *value);
typedef void ( * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint *value);
typedef void ( * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint *coords);
typedef void ( * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint *coords);
typedef void ( * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint *coords);
typedef void ( * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint *coords);
typedef void ( * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint *coords);
typedef void ( * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint *coords);
typedef void ( * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint *color);
typedef void ( * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint *color);
typedef void ( * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint *color);
typedef void ( * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
# 7237 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect);
typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect);
# 7267 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void ( * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble *params);
# 7299 "/usr/include/GL/glext.h" 3 4
typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar *name);
typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint *indices);
typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint *params);
typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint *values);
# 7315 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
typedef void ( * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat *values);
# 7334 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint *ids);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint *ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
# 7351 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void ( * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void ( * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
# 7366 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void ( * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
typedef void ( * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLCLEARDEPTHFPROC) (GLclampf d);
# 7380 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
typedef void ( * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
typedef void ( * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
# 7449 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void ( * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar* *strings);
typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint *pipelines);
typedef void ( * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint *pipelines);
typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint *params);
typedef void ( * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat v0);
typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble v0);
typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1);
typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
# 7525 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble *params);
# 7551 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint *v);
typedef void ( * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd *v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void ( * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat *data);
typedef void ( * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble *data);







typedef GLsync ( * PFNGLCREATESYNCFROMCLEVENTARBPROC) (struct _cl_context * context, struct _cl_event * event, GLbitfield flags);
# 7579 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
typedef void ( * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const GLvoid *userParam);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
# 7609 "/usr/include/GL/glext.h" 3 4
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void ( * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
typedef void ( * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
typedef void ( * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint *v);
typedef void ( * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat *values);
typedef void ( * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint *values);
typedef void ( * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort *values);
typedef void ( * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte *pattern);
typedef void ( * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table);
typedef void ( * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image);
typedef void ( * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
typedef void ( * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
typedef void ( * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img);
typedef void ( * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *img);
typedef void ( * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
typedef void ( * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint *params);
typedef void ( * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint *params);
typedef void ( * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
# 7642 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
# 7657 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
# 7674 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
# 7686 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
# 7695 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void ( * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
# 7713 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 7730 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);







typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 7751 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
# 7761 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat *weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
# 7771 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
# 7784 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 7805 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 7834 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
# 7864 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint *params);







typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 7891 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPIXELTEXGENPARAMETERISGISPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLPIXELTEXGENPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, GLint *params);
typedef void ( * PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, GLfloat *params);
# 7905 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
# 7927 "/usr/include/GL/glext.h" 3 4
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint *textures, GLboolean *residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint *textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint *textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint *textures, const GLclampf *priorities);
# 7941 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
# 7951 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
# 7969 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 7990 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void ( * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
# 8030 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 8061 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, const GLint *params);
# 8077 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat *params);
# 8087 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
# 8101 "/usr/include/GL/glext.h" 3 4
typedef GLint ( * PFNGLGETINSTRUMENTSSGIXPROC) (void);
typedef void ( * PFNGLINSTRUMENTSBUFFERSGIXPROC) (GLsizei size, GLint *buffer);
typedef GLint ( * PFNGLPOLLINSTRUMENTSSGIXPROC) (GLint *marker_p);
typedef void ( * PFNGLREADINSTRUMENTSSGIXPROC) (GLint marker);
typedef void ( * PFNGLSTARTINSTRUMENTSSGIXPROC) (void);
typedef void ( * PFNGLSTOPINSTRUMENTSSGIXPROC) (GLint marker);
# 8118 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);







typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 8137 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDEFORMATIONMAP3DSGIXPROC) (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
typedef void ( * PFNGLDEFORMATIONMAP3FSGIXPROC) (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
typedef void ( * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void ( * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);







typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble *equation);







typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 8169 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat *points);
# 8187 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, GLfloat *params);
# 8209 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 8222 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLHINTPGIPROC) (GLenum target, GLint mode);
# 8233 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
# 8253 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, GLint *params);
typedef void ( * PFNGLLISTPARAMETERFSGIXPROC) (GLuint list, GLenum pname, GLfloat param);
typedef void ( * PFNGLLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLLISTPARAMETERISGIXPROC) (GLuint list, GLenum pname, GLint param);
typedef void ( * PFNGLLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, const GLint *params);
# 8286 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);







typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLclampf ref);
# 8307 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 8317 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble *params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat *params);
# 8347 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, const GLint *params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint *params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint *params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, GLint *params);
typedef void ( * PFNGLLIGHTENVISGIXPROC) (GLenum pname, GLint param);
# 8380 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 8398 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 8421 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint *markerp);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint *markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
# 8445 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
# 8463 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
# 8502 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);







typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 8535 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
# 8548 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
# 8585 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTANGENT3BEXTPROC) (GLbyte tx, GLbyte ty, GLbyte tz);
typedef void ( * PFNGLTANGENT3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLTANGENT3DEXTPROC) (GLdouble tx, GLdouble ty, GLdouble tz);
typedef void ( * PFNGLTANGENT3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLTANGENT3FEXTPROC) (GLfloat tx, GLfloat ty, GLfloat tz);
typedef void ( * PFNGLTANGENT3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLTANGENT3IEXTPROC) (GLint tx, GLint ty, GLint tz);
typedef void ( * PFNGLTANGENT3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLTANGENT3SEXTPROC) (GLshort tx, GLshort ty, GLshort tz);
typedef void ( * PFNGLTANGENT3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLBINORMAL3BEXTPROC) (GLbyte bx, GLbyte by, GLbyte bz);
typedef void ( * PFNGLBINORMAL3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLBINORMAL3DEXTPROC) (GLdouble bx, GLdouble by, GLdouble bz);
typedef void ( * PFNGLBINORMAL3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLBINORMAL3FEXTPROC) (GLfloat bx, GLfloat by, GLfloat bz);
typedef void ( * PFNGLBINORMAL3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLBINORMAL3IEXTPROC) (GLint bx, GLint by, GLint bz);
typedef void ( * PFNGLBINORMAL3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLBINORMAL3SEXTPROC) (GLshort bx, GLshort by, GLshort bz);
typedef void ( * PFNGLBINORMAL3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
# 8630 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 8645 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
# 8666 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint *code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort *code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte *code);
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid* *pointer);
# 8719 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat *tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint *rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);







typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);







typedef void ( * PFNGLBLENDFUNCSEPARATEINGRPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 8820 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (const GLfloat *weight);
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 8835 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, const GLvoid *pointer);
# 8856 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint *params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint *params);
# 8892 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 8923 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort *v);
# 8959 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, GLint modestride);
# 8975 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean* *pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
# 9014 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 9023 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 9048 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXTURECOLORMASKSGISPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);







typedef void ( * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, const GLvoid *params);
# 9078 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint *fences);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint *fences);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint *params);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
# 9100 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
# 9121 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat *params);
# 9213 "/usr/include/GL/glext.h" 3 4
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint *programs, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat *params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint *programs);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte *program);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble *v);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat *v);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei count, const GLubyte *v);
# 9311 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, const GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, const GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
# 9335 "/usr/include/GL/glext.h" 3 4
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat *value);
# 9357 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
# 9377 "/usr/include/GL/glext.h" 3 4
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const GLvoid *pointer, GLenum usage);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint *params);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint *params);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint *params);
# 9437 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, const GLbyte *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, const GLshort *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, const GLint *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, const GLfloat *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, const GLdouble *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, const GLubyte *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, const GLushort *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, const GLuint *addr);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid* *data);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
# 9530 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort nx, GLshort ny, GLshort nz);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint nx, GLint ny, GLint nz);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
# 9584 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const GLvoid *pointer);
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);







typedef void ( * PFNGLDRAWMESHARRAYSSUNPROC) (GLenum mode, GLint first, GLsizei count, GLsizei width);
# 9620 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint *params);
# 9635 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
# 9656 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 9676 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const GLvoid *pointer);
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
# 9695 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint *fences);
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint *fences);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
# 9713 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint *arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, GLuint *arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 9726 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
# 9744 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum *bufs);
# 9777 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
# 9835 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalfNV x, GLhalfNV y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalfNV s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalfNV s, GLhalfNV t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalfNV s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalfNV fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalfNV *fog);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalfNV weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalfNV *weight);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalfNV x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
# 9889 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
# 9899 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
# 9917 "/usr/include/GL/glext.h" 3 4
typedef GLvoid* ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 9927 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
# 9938 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint *params);
# 9952 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 9964 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 10016 "/usr/include/GL/glext.h" 3 4
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint *renderbuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint *renderbuffers);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint *framebuffers);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint *framebuffers);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);







typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const GLvoid *string);
# 10052 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSTENCILCLEARTAGEXTPROC) (GLsizei stencilTagBits, GLuint stencilClearTag);
# 10064 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);







typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 10085 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 10095 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
# 10105 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 10129 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC) (GLenum target, GLuint index, GLint *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC) (GLenum target, GLuint index, GLuint *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERIIVNVPROC) (GLenum target, GLuint index, GLint *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC) (GLenum target, GLuint index, GLuint *params);
# 10155 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);







typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 10196 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
# 10236 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
# 10255 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
# 10272 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 10294 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
# 10308 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 10326 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
# 10341 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum target, GLuint index, GLboolean *data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLint *data);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 10365 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef void ( * PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC) (GLsizei count, const GLint *attribs, GLsizei nbuffers, const GLint *bufstreams, GLenum bufferMode);
# 10386 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
# 10401 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);







typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);
# 10423 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLENDCONDITIONALRENDERNVPROC) (void);
# 10437 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
typedef void ( * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void ( * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint *params);
typedef void ( * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT *params);
# 10456 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void ( * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar* *varyings, GLenum bufferMode);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
# 10675 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLMATRIXLOADFEXTPROC) (GLenum mode, const GLfloat *m);
typedef void ( * PFNGLMATRIXLOADDEXTPROC) (GLenum mode, const GLdouble *m);
typedef void ( * PFNGLMATRIXMULTFEXTPROC) (GLenum mode, const GLfloat *m);
typedef void ( * PFNGLMATRIXMULTDEXTPROC) (GLenum mode, const GLdouble *m);
typedef void ( * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum mode);
typedef void ( * PFNGLMATRIXROTATEFEXTPROC) (GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXROTATEDEXTPROC) (GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXSCALEFEXTPROC) (GLenum mode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXSCALEDEXTPROC) (GLenum mode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum mode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum mode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef void ( * PFNGLMATRIXORTHOEXTPROC) (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef void ( * PFNGLMATRIXPOPEXTPROC) (GLenum mode);
typedef void ( * PFNGLMATRIXPUSHEXTPROC) (GLenum mode);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum mode, const GLfloat *m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum mode, const GLdouble *m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum mode, const GLfloat *m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum mode, const GLdouble *m);
typedef void ( * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params);
typedef void ( * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void ( * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params);
typedef void ( * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef void ( * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void ( * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params);
typedef void ( * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint *params);
typedef void ( * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint *params);
typedef void ( * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat *data);
typedef void ( * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble *data);
typedef void ( * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLvoid* *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint lod, GLvoid *img);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
typedef void ( * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint lod, GLvoid *img);
typedef void ( * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble *params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat *params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble *params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat *params);
typedef void ( * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, GLvoid *string);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint *params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint *params);
typedef void ( * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint *params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint *params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void ( * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void ( * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void ( * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef GLvoid* ( * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef GLvoid* ( * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint *params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, GLvoid* *params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef void ( * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint *params);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void ( * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum *bufs);
typedef void ( * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint *params);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLPROGRAMUNIFORM1DEXTPROC) (GLuint program, GLint location, GLdouble x);
typedef void ( * PFNGLPROGRAMUNIFORM2DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLPROGRAMUNIFORM3DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLPROGRAMUNIFORM4DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMUNIFORM1DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM2DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM3DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM4DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
# 10898 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat *val);
typedef void ( * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);
# 10914 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint *ids);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint *ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
# 10942 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint *numGroups, GLsizei groupsSize, GLuint *groups);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters);
typedef void ( * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
typedef void ( * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, GLvoid *data);
typedef void ( * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint *monitors);
typedef void ( * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint *monitors);
typedef void ( * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList);
typedef void ( * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten);
# 10965 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void ( * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);







typedef void ( * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);
# 10989 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
# 11001 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, const GLvoid *pointer);
typedef void ( * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, GLvoid* *params);
# 11020 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean ( * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
typedef void ( * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
typedef void ( * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
typedef void ( * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
# 11040 "/usr/include/GL/glext.h" 3 4
typedef GLenum ( * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum ( * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef void ( * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint *params);
# 11069 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void ( * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params);
typedef GLenum ( * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params);







typedef void ( * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
# 11098 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
typedef void ( * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar *string);
# 11125 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void ( * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef GLboolean ( * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef void ( * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void ( * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef GLboolean ( * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT *params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT *params);
typedef void ( * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT *result);
typedef void ( * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void ( * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT *params);
typedef void ( * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void ( * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
# 11157 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void ( * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void ( * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT *result);







typedef void ( * PFNGLTEXTUREBARRIERNVPROC) (void);
# 11197 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void ( * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);
# 11216 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
# 11235 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC) (GLenum target, GLsizei count, const GLuint *params);
typedef void ( * PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC) (GLenum target, GLuint index, GLuint *param);
# 11276 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void ( * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void ( * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT *params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT *value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
# 11342 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT *v);
typedef void ( * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT *v);
typedef void ( * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT *v);
typedef void ( * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT *v);
typedef void ( * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT *v);
typedef void ( * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT *v);
typedef void ( * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT *v);
typedef void ( * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT *v);
typedef void ( * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT *params);
typedef void ( * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
# 11374 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint *names);
typedef void ( * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint *names);
typedef GLboolean ( * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);
# 11387 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf);
typedef void ( * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, GLvoid *userParam);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message);
# 11407 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLVDPAUINITNVPROC) (const GLvoid *vdpDevice, const GLvoid *getProcAddress);
typedef void ( * PFNGLVDPAUFININVPROC) (void);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void ( * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void ( * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void ( * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
typedef void ( * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void ( * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces);
typedef void ( * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV *surfaces);
# 11441 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
# 11458 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat *val);







typedef GLsync ( * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
# 11475 "/usr/include/GL/glext.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
# 11485 "/usr/include/GL/glext.h" 3 4
}
# 2086 "/usr/include/GL/gl.h" 2 3 4
# 2100 "/usr/include/GL/gl.h" 3 4
__attribute__((visibility("default"))) GLhandleARB glCreateDebugObjectMESA (void);
__attribute__((visibility("default"))) void glClearDebugLogMESA (GLhandleARB obj, GLenum logType, GLenum shaderType);
__attribute__((visibility("default"))) void glGetDebugLogMESA (GLhandleARB obj, GLenum logType, GLenum shaderType, GLsizei maxLength,
                                         GLsizei *length, GLcharARB *debugLog);
__attribute__((visibility("default"))) GLsizei glGetDebugLogLengthMESA (GLhandleARB obj, GLenum logType, GLenum shaderType);
# 2139 "/usr/include/GL/gl.h" 3 4
typedef void (*GLprogramcallbackMESA)(GLenum target, GLvoid *data);

__attribute__((visibility("default"))) void glProgramCallbackMESA(GLenum target, GLprogramcallbackMESA callback, GLvoid *data);

__attribute__((visibility("default"))) void glGetProgramRegisterfvMESA(GLenum target, GLsizei len, const GLubyte *name, GLfloat *v);
# 2186 "/usr/include/GL/gl.h" 3 4
__attribute__((visibility("default"))) void glBlendEquationSeparateATI( GLenum modeRGB, GLenum modeA );
typedef void ( * PFNGLBLENDEQUATIONSEPARATEATIPROC) (GLenum modeRGB, GLenum modeA);






typedef void* GLeglImageOES;
# 2203 "/usr/include/GL/gl.h" 3 4
typedef void ( * PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) (GLenum target, GLeglImageOES image);
typedef void ( * PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLeglImageOES image);
# 2232 "/usr/include/GL/gl.h" 3 4
}
# 169 "/usr/include/GL/glfw.h" 2 3 4

# 1 "/usr/include/GL/glu.h" 1 3 4
# 65 "/usr/include/GL/glu.h" 3 4
extern "C" {
# 270 "/usr/include/GL/glu.h" 3 4
class GLUnurbs;
class GLUquadric;
class GLUtesselator;






typedef GLUnurbs GLUnurbsObj;
typedef GLUquadric GLUquadricObj;
typedef GLUtesselator GLUtesselatorObj;
typedef GLUtesselator GLUtriangulatorObj;




typedef void ( * _GLUfuncptr)(void);

__attribute__((visibility("default"))) void gluBeginCurve (GLUnurbs* nurb);
__attribute__((visibility("default"))) void gluBeginPolygon (GLUtesselator* tess);
__attribute__((visibility("default"))) void gluBeginSurface (GLUnurbs* nurb);
__attribute__((visibility("default"))) void gluBeginTrim (GLUnurbs* nurb);
__attribute__((visibility("default"))) GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
__attribute__((visibility("default"))) GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
__attribute__((visibility("default"))) GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
__attribute__((visibility("default"))) GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
__attribute__((visibility("default"))) GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
__attribute__((visibility("default"))) GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
__attribute__((visibility("default"))) GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString);
__attribute__((visibility("default"))) void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks);
__attribute__((visibility("default"))) void gluDeleteNurbsRenderer (GLUnurbs* nurb);
__attribute__((visibility("default"))) void gluDeleteQuadric (GLUquadric* quad);
__attribute__((visibility("default"))) void gluDeleteTess (GLUtesselator* tess);
__attribute__((visibility("default"))) void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops);
__attribute__((visibility("default"))) void gluEndCurve (GLUnurbs* nurb);
__attribute__((visibility("default"))) void gluEndPolygon (GLUtesselator* tess);
__attribute__((visibility("default"))) void gluEndSurface (GLUnurbs* nurb);
__attribute__((visibility("default"))) void gluEndTrim (GLUnurbs* nurb);
__attribute__((visibility("default"))) const GLubyte * gluErrorString (GLenum error);
__attribute__((visibility("default"))) void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data);
__attribute__((visibility("default"))) const GLubyte * gluGetString (GLenum name);
__attribute__((visibility("default"))) void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data);
__attribute__((visibility("default"))) void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view);
__attribute__((visibility("default"))) void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ);
__attribute__((visibility("default"))) GLUnurbs* gluNewNurbsRenderer (void);
__attribute__((visibility("default"))) GLUquadric* gluNewQuadric (void);
__attribute__((visibility("default"))) GLUtesselator* gluNewTess (void);
__attribute__((visibility("default"))) void gluNextContour (GLUtesselator* tess, GLenum type);
__attribute__((visibility("default"))) void gluNurbsCallback (GLUnurbs* nurb, GLenum which, _GLUfuncptr CallBackFunc);
__attribute__((visibility("default"))) void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData);
__attribute__((visibility("default"))) void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
__attribute__((visibility("default"))) void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type);
__attribute__((visibility("default"))) void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value);
__attribute__((visibility("default"))) void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type);
__attribute__((visibility("default"))) void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top);
__attribute__((visibility("default"))) void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep);
__attribute__((visibility("default"))) void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
__attribute__((visibility("default"))) void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport);
__attribute__((visibility("default"))) GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ);
__attribute__((visibility("default"))) void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type);
__attribute__((visibility("default"))) void gluQuadricCallback (GLUquadric* quad, GLenum which, _GLUfuncptr CallBackFunc);
__attribute__((visibility("default"))) void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw);
__attribute__((visibility("default"))) void gluQuadricNormals (GLUquadric* quad, GLenum normal);
__attribute__((visibility("default"))) void gluQuadricOrientation (GLUquadric* quad, GLenum orientation);
__attribute__((visibility("default"))) void gluQuadricTexture (GLUquadric* quad, GLboolean texture);
__attribute__((visibility("default"))) GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut);
__attribute__((visibility("default"))) void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks);
__attribute__((visibility("default"))) void gluTessBeginContour (GLUtesselator* tess);
__attribute__((visibility("default"))) void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data);
__attribute__((visibility("default"))) void gluTessCallback (GLUtesselator* tess, GLenum which, _GLUfuncptr CallBackFunc);
__attribute__((visibility("default"))) void gluTessEndContour (GLUtesselator* tess);
__attribute__((visibility("default"))) void gluTessEndPolygon (GLUtesselator* tess);
__attribute__((visibility("default"))) void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ);
__attribute__((visibility("default"))) void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data);
__attribute__((visibility("default"))) void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data);
__attribute__((visibility("default"))) GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ);
__attribute__((visibility("default"))) GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW);


}
# 171 "/usr/include/GL/glfw.h" 2 3 4
# 381 "/usr/include/GL/glfw.h" 3 4
typedef struct {
    int Width, Height;
    int RedBits, BlueBits, GreenBits;
} GLFWvidmode;


typedef struct {
    int Width, Height;
    int Format;
    int BytesPerPixel;
    unsigned char *Data;
} GLFWimage;


typedef int GLFWthread;


typedef void * GLFWmutex;


typedef void * GLFWcond;


typedef void ( * GLFWwindowsizefun)(int,int);
typedef int ( * GLFWwindowclosefun)(void);
typedef void ( * GLFWwindowrefreshfun)(void);
typedef void ( * GLFWmousebuttonfun)(int,int);
typedef void ( * GLFWmouseposfun)(int,int);
typedef void ( * GLFWmousewheelfun)(int);
typedef void ( * GLFWkeyfun)(int,int);
typedef void ( * GLFWcharfun)(int,int);
typedef void ( * GLFWthreadfun)(void *);







 int glfwInit( void );
 void glfwTerminate( void );
 void glfwGetVersion( int *major, int *minor, int *rev );


 int glfwOpenWindow( int width, int height, int redbits, int greenbits, int bluebits, int alphabits, int depthbits, int stencilbits, int mode );
 void glfwOpenWindowHint( int target, int hint );
 void glfwCloseWindow( void );
 void glfwSetWindowTitle( const char *title );
 void glfwGetWindowSize( int *width, int *height );
 void glfwSetWindowSize( int width, int height );
 void glfwSetWindowPos( int x, int y );
 void glfwIconifyWindow( void );
 void glfwRestoreWindow( void );
 void glfwSwapBuffers( void );
 void glfwSwapInterval( int interval );
 int glfwGetWindowParam( int param );
 void glfwSetWindowSizeCallback( GLFWwindowsizefun cbfun );
 void glfwSetWindowCloseCallback( GLFWwindowclosefun cbfun );
 void glfwSetWindowRefreshCallback( GLFWwindowrefreshfun cbfun );


 int glfwGetVideoModes( GLFWvidmode *list, int maxcount );
 void glfwGetDesktopMode( GLFWvidmode *mode );


 void glfwPollEvents( void );
 void glfwWaitEvents( void );
 int glfwGetKey( int key );
 int glfwGetMouseButton( int button );
 void glfwGetMousePos( int *xpos, int *ypos );
 void glfwSetMousePos( int xpos, int ypos );
 int glfwGetMouseWheel( void );
 void glfwSetMouseWheel( int pos );
 void glfwSetKeyCallback( GLFWkeyfun cbfun );
 void glfwSetCharCallback( GLFWcharfun cbfun );
 void glfwSetMouseButtonCallback( GLFWmousebuttonfun cbfun );
 void glfwSetMousePosCallback( GLFWmouseposfun cbfun );
 void glfwSetMouseWheelCallback( GLFWmousewheelfun cbfun );


 int glfwGetJoystickParam( int joy, int param );
 int glfwGetJoystickPos( int joy, float *pos, int numaxes );
 int glfwGetJoystickButtons( int joy, unsigned char *buttons, int numbuttons );


 double glfwGetTime( void );
 void glfwSetTime( double time );
 void glfwSleep( double time );


 int glfwExtensionSupported( const char *extension );
 void* glfwGetProcAddress( const char *procname );
 void glfwGetGLVersion( int *major, int *minor, int *rev );


 GLFWthread glfwCreateThread( GLFWthreadfun fun, void *arg );
 void glfwDestroyThread( GLFWthread ID );
 int glfwWaitThread( GLFWthread ID, int waitmode );
 GLFWthread glfwGetThreadID( void );
 GLFWmutex glfwCreateMutex( void );
 void glfwDestroyMutex( GLFWmutex mutex );
 void glfwLockMutex( GLFWmutex mutex );
 void glfwUnlockMutex( GLFWmutex mutex );
 GLFWcond glfwCreateCond( void );
 void glfwDestroyCond( GLFWcond cond );
 void glfwWaitCond( GLFWcond cond, GLFWmutex mutex, double timeout );
 void glfwSignalCond( GLFWcond cond );
 void glfwBroadcastCond( GLFWcond cond );
 int glfwGetNumberOfProcessors( void );


 void glfwEnable( int token );
 void glfwDisable( int token );


 int glfwReadImage( const char *name, GLFWimage *img, int flags );
 int glfwReadMemoryImage( const void *data, long size, GLFWimage *img, int flags );
 void glfwFreeImage( GLFWimage *img );
 int glfwLoadTexture2D( const char *name, int flags );
 int glfwLoadMemoryTexture2D( const void *data, long size, int flags );
 int glfwLoadTextureImage2D( GLFWimage *img, int flags );



}
# 5 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 2
# 1 "/usr/include/sgct/glm/glm.hpp" 1 3 4
# 78 "/usr/include/sgct/glm/glm.hpp" 3 4
# 1 "/usr/include/sgct/glm/core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 2 3 4




typedef float float_t;
typedef double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void
 sincosf
# 82 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 (float __x, float *__sinx, float *__cosx) throw (); extern void
 __sincosf
# 82 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 146 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void
 sincosl
# 82 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 (long double __x, long double *__sinx, long double *__cosx) throw (); extern void
 __sincosl
# 82 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 147 "/usr/include/math.h" 2 3 4
# 162 "/usr/include/math.h" 3 4
extern int signgam;
# 203 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 296 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 319 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 483 "/usr/include/math.h" 3 4
}
# 47 "/usr/include/c++/4.6/cmath" 2 3
# 77 "/usr/include/c++/4.6/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 481 "/usr/include/c++/4.6/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 731 "/usr/include/c++/4.6/cmath" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
      FP_SUBNORMAL, FP_ZERO, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }




}
# 30 "/usr/include/sgct/glm/core/_fixes.hpp" 2 3 4
# 79 "/usr/include/sgct/glm/glm.hpp" 2 3 4




# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 84 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.6/climits" 1 3 4
# 41 "/usr/include/c++/4.6/climits" 3 4
       
# 42 "/usr/include/c++/4.6/climits" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 1 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 158 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 170 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 2 3 4
# 44 "/usr/include/c++/4.6/climits" 2 3
# 85 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.6/cfloat" 1 3 4
# 41 "/usr/include/c++/4.6/cfloat" 3 4
       
# 42 "/usr/include/c++/4.6/cfloat" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/float.h" 1 3 4
# 44 "/usr/include/c++/4.6/cfloat" 2 3
# 86 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.6/limits" 1 3 4
# 41 "/usr/include/c++/4.6/limits" 3 4
       
# 42 "/usr/include/c++/4.6/limits" 3
# 148 "/usr/include/c++/4.6/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 192 "/usr/include/c++/4.6/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;


    static const int digits10 = 0;
# 213 "/usr/include/c++/4.6/limits" 3
    static const bool is_signed = false;



    static const bool is_integer = false;





    static const bool is_exact = false;



    static const int radix = 0;



    static const int min_exponent = 0;



    static const int min_exponent10 = 0;




    static const int max_exponent = 0;



    static const int max_exponent10 = 0;


    static const bool has_infinity = false;



    static const bool has_quiet_NaN = false;



    static const bool has_signaling_NaN = false;


    static const float_denorm_style has_denorm = denorm_absent;



    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;




    static const bool is_bounded = false;





    static const bool is_modulo = false;


    static const bool traps = false;


    static const bool tinyness_before = false;




    static const float_round_style round_style =
          round_toward_zero;
  };
# 303 "/usr/include/c++/4.6/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp
      min() throw() { return static_cast<_Tp>(0); }


      static _Tp
      max() throw() { return static_cast<_Tp>(0); }
# 324 "/usr/include/c++/4.6/limits" 3
      static _Tp
      epsilon() throw() { return static_cast<_Tp>(0); }


      static _Tp
      round_error() throw() { return static_cast<_Tp>(0); }


      static _Tp
      infinity() throw() { return static_cast<_Tp>(0); }



      static _Tp
      quiet_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp
      signaling_NaN() throw() { return static_cast<_Tp>(0); }




      static _Tp
      denorm_min() throw() { return static_cast<_Tp>(0); }
    };
# 370 "/usr/include/c++/4.6/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool
      min() throw() { return false; }

      static bool
      max() throw() { return true; }





      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static bool
      epsilon() throw() { return false; }

      static bool
      round_error() throw() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool
      infinity() throw() { return false; }

      static bool
      quiet_NaN() throw() { return false; }

      static bool
      signaling_NaN() throw() { return false; }

      static bool
      denorm_min() throw() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char
      min() throw() { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }

      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }






      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static char
      epsilon() throw() { return 0; }

      static char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
      char infinity() throw() { return char(); }

      static char
      quiet_NaN() throw() { return char(); }

      static char
      signaling_NaN() throw() { return char(); }

      static char
      denorm_min() throw() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char
      min() throw() { return -127 - 1; }

      static signed char
      max() throw() { return 127; }






      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static signed char
      epsilon() throw() { return 0; }

      static signed char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      signaling_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      denorm_min() throw() { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char
      min() throw() { return 0; }

      static unsigned char
      max() throw() { return 127 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned char
      epsilon() throw() { return 0; }

      static unsigned char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char
      infinity() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      quiet_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      signaling_NaN() throw() { return static_cast<unsigned char>(0); }

      static unsigned char
      denorm_min() throw() { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }

      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }






      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static wchar_t
      epsilon() throw() { return 0; }

      static wchar_t
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t
      infinity() throw() { return wchar_t(); }

      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static wchar_t
      denorm_min() throw() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
# 852 "/usr/include/c++/4.6/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short
      min() throw() { return -32767 - 1; }

      static short
      max() throw() { return 32767; }






      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static short
      epsilon() throw() { return 0; }

      static short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static short
      infinity() throw() { return short(); }

      static short
      quiet_NaN() throw() { return short(); }

      static short
      signaling_NaN() throw() { return short(); }

      static short
      denorm_min() throw() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short
      min() throw() { return 0; }

      static unsigned short
      max() throw() { return 32767 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned short
      epsilon() throw() { return 0; }

      static unsigned short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short
      infinity() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      quiet_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      signaling_NaN() throw() { return static_cast<unsigned short>(0); }

      static unsigned short
      denorm_min() throw() { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int
      min() throw() { return -2147483647 - 1; }

      static int
      max() throw() { return 2147483647; }






      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static int
      epsilon() throw() { return 0; }

      static int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static int
      infinity() throw() { return static_cast<int>(0); }

      static int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static int
      denorm_min() throw() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int
      min() throw() { return 0; }

      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned int
      epsilon() throw() { return 0; }

      static unsigned int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      quiet_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      signaling_NaN() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      denorm_min() throw() { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long
      min() throw() { return -9223372036854775807L - 1; }

      static long
      max() throw() { return 9223372036854775807L; }






      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long
      epsilon() throw() { return 0; }

      static long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long
      infinity() throw() { return static_cast<long>(0); }

      static long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static long
      denorm_min() throw() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long
      min() throw() { return 0; }

      static unsigned long
      max() throw() { return 9223372036854775807L * 2UL + 1; }






      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long
      epsilon() throw() { return 0; }

      static unsigned long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long
      infinity() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      quiet_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      signaling_NaN() throw() { return static_cast<unsigned long>(0); }

      static unsigned long
      denorm_min() throw() { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long
      min() throw() { return -9223372036854775807LL - 1; }

      static long long
      max() throw() { return 9223372036854775807LL; }






      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long long
      epsilon() throw() { return 0; }

      static long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long
      infinity() throw() { return static_cast<long long>(0); }

      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static long long
      signaling_NaN() throw() { return static_cast<long long>(0); }

      static long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long
      min() throw() { return 0; }

      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }






      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long long
      epsilon() throw() { return 0; }

      static unsigned long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long
      infinity() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      quiet_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      signaling_NaN() throw() { return static_cast<unsigned long long>(0); }

      static unsigned long long
      denorm_min() throw() { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float
      min() throw() { return 1.17549435082228750797e-38F; }

      static float
      max() throw() { return 3.40282346638528859812e+38F; }






      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static float
      epsilon() throw() { return 1.19209289550781250000e-7F; }

      static float
      round_error() throw() { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;

      static float
      infinity() throw() { return __builtin_huge_valf (); }

      static float
      quiet_NaN() throw() { return __builtin_nanf (""); }

      static float
      signaling_NaN() throw() { return __builtin_nansf (""); }

      static float
      denorm_min() throw() { return 1.40129846432481707092e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double
      min() throw() { return double(2.22507385850720138309e-308L); }

      static double
      max() throw() { return double(1.79769313486231570815e+308L); }






      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static double
      epsilon() throw() { return double(2.22044604925031308085e-16L); }

      static double
      round_error() throw() { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static double
      infinity() throw() { return __builtin_huge_val(); }

      static double
      quiet_NaN() throw() { return __builtin_nan (""); }

      static double
      signaling_NaN() throw() { return __builtin_nans (""); }

      static double
      denorm_min() throw() { return double(4.94065645841246544177e-324L); }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double
      min() throw() { return 3.36210314311209350626e-4932L; }

      static long double
      max() throw() { return 1.18973149535723176502e+4932L; }






      static const int digits = 64;
      static const int digits10 = 18;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }

      static long double
      round_error() throw() { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double
      infinity() throw() { return __builtin_huge_vall (); }

      static long double
      quiet_NaN() throw() { return __builtin_nanl (""); }

      static long double
      signaling_NaN() throw() { return __builtin_nansl (""); }

      static long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };






}
# 87 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.6/cstdio" 1 3 4
# 41 "/usr/include/c++/4.6/cstdio" 3 4
       
# 42 "/usr/include/c++/4.6/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 132 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 172 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 182 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 205 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 273 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 321 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 330 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 366 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 462 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 492 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 554 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 91 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 165 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 166 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 206 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 253 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 263 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 296 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
# 418 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 469 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 528 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 556 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 567 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 600 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 646 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 662 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 723 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 734 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 770 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 789 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 812 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 851 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 870 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 940 "/usr/include/stdio.h" 3 4
}
# 45 "/usr/include/c++/4.6/cstdio" 2 3
# 92 "/usr/include/c++/4.6/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 148 "/usr/include/c++/4.6/cstdio" 3
namespace __gnu_cxx
{
# 166 "/usr/include/c++/4.6/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 88 "/usr/include/sgct/glm/glm.hpp" 2 3 4

# 1 "/usr/include/sgct/glm/core/setup.hpp" 1 3 4
# 533 "/usr/include/sgct/glm/core/setup.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 1 3 4
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 1 3 4
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/mmintrin.h" 1 3 4
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/mmintrin.h" 3 4
typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));


typedef int __v2si __attribute__ ((__vector_size__ (8)));
typedef short __v4hi __attribute__ ((__vector_size__ (8)));
typedef char __v8qi __attribute__ ((__vector_size__ (8)));
typedef long long __v1di __attribute__ ((__vector_size__ (8)));
typedef float __v2sf __attribute__ ((__vector_size__ (8)));


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_empty (void)
{
  __builtin_ia32_emms ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_empty (void)
{
  _mm_empty ();
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si64 (int __i)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int (int __i)
{
  return _mm_cvtsi32_si64 (__i);
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_m64 (long long __i)
{
  return (__m64) __i;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi64x (long long __i)
{
  return (__m64) __i;
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si32 (__m64 __i)
{
  return __builtin_ia32_vec_ext_v2si ((__v2si)__i, 0);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int (__m64 __i)
{
  return _mm_cvtsi64_si32 (__i);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int64 (__m64 __i)
{
  return (long long)__i;
}

extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtm64_si64 (__m64 __i)
{
  return (long long)__i;
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si64x (__m64 __i)
{
  return (long long)__i;
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packsswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packsswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packssdw ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packssdw (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi32 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packuswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packuswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pu16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhdq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhdq (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckldq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckldq (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddb (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddw (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddd (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddq ((__v1di)__m1, (__v1di)__m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubb (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubw (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubd (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubq ((__v1di)__m1, (__v1di)__m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmaddwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaddwd (__m64 __m1, __m64 __m2)
{
  return _mm_madd_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmulhw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhw (__m64 __m1, __m64 __m2)
{
  return _mm_mulhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmullw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmullw (__m64 __m1, __m64 __m2)
{
  return _mm_mullo_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllw (__m64 __m, __m64 __count)
{
  return _mm_sll_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllwi (__m64 __m, int __count)
{
  return _mm_slli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_pslld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslld (__m64 __m, __m64 __count)
{
  return _mm_sll_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_pslldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslldi (__m64 __m, int __count)
{
  return _mm_slli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllq (__m64 __m, __m64 __count)
{
  return _mm_sll_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllqi (__m64 __m, int __count)
{
  return _mm_slli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psraw (__m64 __m, __m64 __count)
{
  return _mm_sra_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrawi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrawi (__m64 __m, int __count)
{
  return _mm_srai_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrad ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrad (__m64 __m, __m64 __count)
{
  return _mm_sra_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psradi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psradi (__m64 __m, int __count)
{
  return _mm_srai_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlw (__m64 __m, __m64 __count)
{
  return _mm_srl_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlwi (__m64 __m, int __count)
{
  return _mm_srli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrld (__m64 __m, __m64 __count)
{
  return _mm_srl_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrldi (__m64 __m, int __count)
{
  return _mm_srli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlq (__m64 __m, __m64 __count)
{
  return _mm_srl_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlqi (__m64 __m, int __count)
{
  return _mm_srli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pand (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pand (__m64 __m1, __m64 __m2)
{
  return _mm_and_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pandn (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pandn (__m64 __m1, __m64 __m2)
{
  return _mm_andnot_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_por (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_por (__m64 __m1, __m64 __m2)
{
  return _mm_or_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pxor (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pxor (__m64 __m1, __m64 __m2)
{
  return _mm_xor_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi8 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi16 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi32 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si64 (void)
{
  return (__m64)0LL;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi32 (int __i1, int __i0)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i0, __i1);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
{
  return (__m64) __builtin_ia32_vec_init_v4hi (__w0, __w1, __w2, __w3);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
      char __b3, char __b2, char __b1, char __b0)
{
  return (__m64) __builtin_ia32_vec_init_v8qi (__b0, __b1, __b2, __b3,
            __b4, __b5, __b6, __b7);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi32 (int __i0, int __i1)
{
  return _mm_set_pi32 (__i1, __i0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)
{
  return _mm_set_pi16 (__w3, __w2, __w1, __w0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
       char __b4, char __b5, char __b6, char __b7)
{
  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi32 (int __i)
{
  return _mm_set_pi32 (__i, __i);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi16 (short __w)
{
  return _mm_set_pi16 (__w, __w, __w, __w);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi8 (char __b)
{
  return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);
}
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/mm_malloc.h" 1 3 4
# 27 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/mm_malloc.h" 3 4
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

# 236 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 237 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 99 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 116 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 148 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 201 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 55 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 65 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 97 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 107 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 119 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 132 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 221 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 64 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 224 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 263 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
# 187 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 272 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 498 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 808 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 896 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 964 "/usr/include/stdlib.h" 3 4
}
# 28 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/mm_malloc.h" 2 3 4






extern "C" int posix_memalign (void **, size_t, size_t) throw ();


static __inline void *
_mm_malloc (size_t size, size_t alignment)
{
  void *ptr;
  if (alignment == 1)
    return malloc (size);
  if (alignment == 2 || (sizeof (void *) == 8 && alignment == 4))
    alignment = sizeof (void *);
  if (posix_memalign (&ptr, alignment, size) == 0)
    return ptr;
  else
    return __null;
}

static __inline void
_mm_free (void * ptr)
{
  free (ptr);
}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 2 3 4



typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));


typedef float __v4sf __attribute__ ((__vector_size__ (16)));






enum _mm_hint
{
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};
# 89 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_ps (void)
{
  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andnps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_orps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_xorps (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpltss ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpless ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnltss ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnless ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);
}




extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si32 (__m128 __A)
{
  return __builtin_ia32_cvtss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ss2si (__m128 __A)
{
  return _mm_cvtss_si32 (__A);
}






extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64 (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64x (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ps2pi (__m128 __A)
{
  return _mm_cvtps_pi32 (__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si32 (__m128 __A)
{
  return __builtin_ia32_cvttss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ss2si (__m128 __A)
{
  return _mm_cvttss_si32 (__A);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64 (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64x (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ps2pi (__m128 __A)
{
  return _mm_cvttps_pi32 (__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_ss (__m128 __A, int __B)
{
  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_si2ss (__m128 __A, int __B)
{
  return _mm_cvtsi32_ss (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_ps (__m128 __A, __m64 __B)
{
  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_pi2ps (__m128 __A, __m64 __B)
{
  return _mm_cvtpi32_ps (__A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi16_ps (__m64 __A)
{
  __v4hi __sign;
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;




  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu16_ps (__m64 __A)
{
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi8_ps (__m64 __A)
{
  __v8qi __sign;




  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);


  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);

  return _mm_cvtpi16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu8_ps(__m64 __A)
{
  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);
  return _mm_cvtpu16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)
{
  __v4sf __zero = (__v4sf) _mm_setzero_ps ();
  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);
  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__sfa, (__v2si)__B);
  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi16(__m128 __A)
{
  __v4sf __hisf = (__v4sf)__A;
  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);
  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);
  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);
  return (__m64) __builtin_ia32_packssdw (__hisi, __losi);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi8(__m128 __A)
{
  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);
  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);
}
# 727 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storehps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movehl_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movelh_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storelps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_ps (__m128 __A)
{
  return __builtin_ia32_movmskps ((__v4sf)__A);
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_getcsr (void)
{
  return __builtin_ia32_stmxcsr ();
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_STATE (void)
{
  return _mm_getcsr() & 0x003f;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_MASK (void)
{
  return _mm_getcsr() & 0x1f80;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_ROUNDING_MODE (void)
{
  return _mm_getcsr() & 0x6000;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_FLUSH_ZERO_MODE (void)
{
  return _mm_getcsr() & 0x8000;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setcsr (unsigned int __I)
{
  __builtin_ia32_ldmxcsr (__I);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_STATE(unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x003f) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_MASK (unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x1f80) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_ROUNDING_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x6000) | __mode);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x8000) | __mode);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ss (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_ps (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps1 (float __F)
{
  return _mm_set1_ps (__F);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ss (float const *__P)
{
  return _mm_set_ss (*__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_ps (float const *__P)
{
  return _mm_set1_ps (*__P);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps1 (float const *__P)
{
  return _mm_load1_ps (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps (float const *__P)
{
  return (__m128) *(__v4sf *)__P;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_ps (float const *__P)
{
  return (__m128) __builtin_ia32_loadups (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_ps (float const *__P)
{
  __v4sf __tmp = *(__v4sf *)__P;
  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)
{
  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_ps (float __Z, float __Y, float __X, float __W)
{
  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ss (float *__P, __m128 __A)
{
  *__P = __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);
}

extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_f32 (__m128 __A)
{
  return __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps (float *__P, __m128 __A)
{
  *(__v4sf *)__P = (__v4sf)__A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_ps (float *__P, __m128 __A)
{
  __builtin_ia32_storeups (__P, (__v4sf)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((0) << 4) | ((0) << 2) | (0)));
  _mm_storeu_ps (__P, __tmp);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps1 (float *__P, __m128 __A)
{
  _mm_store1_ps (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
  _mm_store_ps (__P, __tmp);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf)__A, (__v4sf)__B);
}
# 1032 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 3 4
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxsw (__m64 __A, __m64 __B)
{
  return _mm_max_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxub (__m64 __A, __m64 __B)
{
  return _mm_max_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminsw (__m64 __A, __m64 __B)
{
  return _mm_min_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminub (__m64 __A, __m64 __B)
{
  return _mm_min_pu8 (__A, __B);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pi8 (__m64 __A)
{
  return __builtin_ia32_pmovmskb ((__v8qi)__A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmovmskb (__m64 __A)
{
  return _mm_movemask_pi8 (__A);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhuw (__m64 __A, __m64 __B)
{
  return _mm_mulhi_pu16 (__A, __B);
}
# 1134 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
{
  __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_maskmovq (__m64 __A, __m64 __N, char *__P)
{
  _mm_maskmove_si64 (__A, __N, __P);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgb (__m64 __A, __m64 __B)
{
  return _mm_avg_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgw (__m64 __A, __m64 __B)
{
  return _mm_avg_pu16 (__A, __B);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psadbw (__m64 __A, __m64 __B)
{
  return _mm_sad_pu8 (__A, __B);
}
# 1201 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pi (__m64 *__P, __m64 __A)
{
  __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_ps (float *__P, __m128 __A)
{
  __builtin_ia32_movntps (__P, (__v4sf)__A);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sfence (void)
{
  __builtin_ia32_sfence ();
}




extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_pause (void)
{
  __asm__ __volatile__ ("rep; nop" : : );
}
# 1247 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 1 3 4
# 1248 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/xmmintrin.h" 2 3 4
# 37 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 2 3 4


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef int __v4si __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__ ((__vector_size__ (16)));
typedef char __v16qi __attribute__ ((__vector_size__ (16)));



typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));






extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_sd (double __F)
{
  return __extension__ (__m128d){ __F, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pd (double __F)
{
  return __extension__ (__m128d){ __F, __F };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd1 (double __F)
{
  return _mm_set1_pd (__F);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __X, __W };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __W, __X };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_pd (void)
{
  return __extension__ (__m128d){ 0.0, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd (double const *__P)
{
  return *(__m128d *)__P;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_pd (double const *__P)
{
  return __builtin_ia32_loadupd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_pd (double const *__P)
{
  return _mm_set1_pd (*__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_sd (double const *__P)
{
  return _mm_set_sd (*__P);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd1 (double const *__P)
{
  return _mm_load1_pd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_pd (double const *__P)
{
  __m128d __tmp = _mm_load_pd (__P);
  return __builtin_ia32_shufpd (__tmp, __tmp, (((0) << 1) | (1)));
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd (double *__P, __m128d __A)
{
  *(__m128d *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_pd (double *__P, __m128d __A)
{
  __builtin_ia32_storeupd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_sd (double *__P, __m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df (__A, 0);
}

extern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_f64 (__m128d __A)
{
  return __builtin_ia32_vec_ext_v2df (__A, 0);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pd (double *__P, __m128d __A)
{
  _mm_store_sd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pd (double *__P, __m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df (__A, 1);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (0))));
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd1 (double *__P, __m128d __A)
{
  _mm_store1_pd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (1))));
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si32 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di ((__v2di)__A, 0);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64x (__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di ((__v2di)__A, 0);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_pd (__m128d __A)
{
  return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_sd (__m128d __A, __m128d __B)
{
  __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
  return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpltsd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmplesd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnltsd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnlesd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64x (long long __q1, long long __q0)
{
  return __extension__ (__m128i)(__v2di){ __q0, __q1 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64 (__m64 __q1, __m64 __q0)
{
  return _mm_set_epi64x ((long long)__q1, (long long)__q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)
{
  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,
        short __q3, short __q2, short __q1, short __q0)
{
  return __extension__ (__m128i)(__v8hi){
    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,
       char __q11, char __q10, char __q09, char __q08,
       char __q07, char __q06, char __q05, char __q04,
       char __q03, char __q02, char __q01, char __q00)
{
  return __extension__ (__m128i)(__v16qi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15
  };
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64x (long long __A)
{
  return _mm_set_epi64x (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64 (__m64 __A)
{
  return _mm_set_epi64 (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi32 (int __A)
{
  return _mm_set_epi32 (__A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi16 (short __A)
{
  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi8 (char __A)
{
  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,
         __A, __A, __A, __A, __A, __A, __A, __A);
}




extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi64 (__m64 __q0, __m64 __q1)
{
  return _mm_set_epi64 (__q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)
{
  return _mm_set_epi32 (__q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,
         short __q4, short __q5, short __q6, short __q7)
{
  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,
        char __q04, char __q05, char __q06, char __q07,
        char __q08, char __q09, char __q10, char __q11,
        char __q12, char __q13, char __q14, char __q15)
{
  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
         __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_si128 (__m128i const *__P)
{
  return *__P;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si128 (__m128i const *__P)
{
  return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_epi64 (__m128i const *__P)
{
  return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_si128 (__m128i *__P, __m128i __B)
{
  *__P = __B;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si128 (__m128i *__P, __m128i __B)
{
  __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_epi64 (__m128i *__P, __m128i __B)
{
  *(long long *)__P = __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi64_pi64 (__m128i __B)
{
  return (__m64) __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movpi64_epi64 (__m64 __A)
{
  return _mm_set_epi64 ((__m64)0LL, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_epi64 (__m128i __A)
{
  return (__m128i)__builtin_ia32_movq128 ((__v2di) __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si128 (void)
{
  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_pd (__m128i __A)
{
  return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_ps (__m128i __A)
{
  return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_ps (__m128d __A)
{
  return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_pd (__m64 __A)
{
  return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pd (__m128 __A)
{
  return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_ss (__m128 __A, __m128d __B)
{
  return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_sd (__m128d __A, int __B)
{
  return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);
}



extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_sd (__m128d __A, __m128 __B)
{
  return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);
}
# 893 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 3 4
extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pd (__m128d __A)
{
  return __builtin_ia32_movmskpd ((__v2df)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packus_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmullw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_su32 (__m64 __A, __m64 __B)
{
  return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);
}
# 1164 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pand128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_por128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pxor128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__B, (__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__B, (__v8hi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__B, (__v4si)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__A, (__v4si)__B);
}
# 1328 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_epi8 (__m128i __A)
{
  return __builtin_ia32_pmovmskb128 ((__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);
}
# 1391 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/emmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
{
  __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si32 (int *__A, int __B)
{
  __builtin_ia32_movnti (__A, __B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si128 (__m128i *__A, __m128i __B)
{
  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pd (double *__A, __m128d __B)
{
  __builtin_ia32_movntpd (__A, (__v2df)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clflush (void const *__A)
{
  __builtin_ia32_clflush (__A);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_lfence (void)
{
  __builtin_ia32_lfence ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mfence (void)
{
  __builtin_ia32_mfence ();
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si128 (int __A)
{
  return _mm_set_epi32 (0, 0, 0, __A);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_ps(__m128d __A)
{
  return (__m128) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_si128(__m128d __A)
{
  return (__m128i) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_pd(__m128 __A)
{
  return (__m128d) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_si128(__m128 __A)
{
  return (__m128i) __A;
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_ps(__m128i __A)
{
  return (__m128) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_pd(__m128i __A)
{
  return (__m128d) __A;
}
# 534 "/usr/include/sgct/glm/core/setup.hpp" 2 3 4
# 90 "/usr/include/sgct/glm/glm.hpp" 2 3 4






# 1 "/usr/include/sgct/glm/./core/_detail.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
# 1 "/usr/include/sgct/glm/./core/setup.hpp" 1 3 4
# 33 "/usr/include/sgct/glm/./core/_detail.hpp" 2 3 4
# 1 "/usr/include/c++/4.6/cassert" 1 3 4
# 43 "/usr/include/c++/4.6/cassert" 3 4
       
# 44 "/usr/include/c++/4.6/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 68 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/4.6/cassert" 2 3
# 34 "/usr/include/sgct/glm/./core/_detail.hpp" 2 3 4




namespace glm{
namespace detail
{
 class half;
# 50 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 __extension__ typedef signed long long sint64;
 __extension__ typedef unsigned long long uint64;
# 60 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 template<bool C>
 struct If
 {
  template<typename F, typename T>
  static inline T apply(F functor, const T& val)
  {
   return functor(val);
  }
 };

 template<>
 struct If<false>
 {
  template<typename F, typename T>
  static inline T apply(F, const T& val)
  {
   return val;
  }
 };
# 133 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 union uif32
 {
  inline uif32() :
   i(0)
  {}

  inline uif32(float f) :
   f(f)
  {}

  inline uif32(unsigned int i) :
   i(i)
  {}

  float f;
  unsigned int i;
 };

 union uif64
 {
  inline uif64() :
   i(0)
  {}

  inline uif64(double f) :
   f(f)
  {}

  inline uif64(uint64 i) :
   i(i)
  {}

  double f;
  uint64 i;
 };

 typedef uif32 uif;




 template <typename T>
 struct is_int
 {
  enum is_int_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 198 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 template <typename T>
 struct is_uint
 {
  enum is_uint_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 224 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 template <typename T>
 struct is_float
 {
  enum is_float_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 245 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 template <> struct is_float<detail::half> { enum is_float_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_float<float> { enum is_float_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_float<double> { enum is_float_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_float<long double> { enum is_float_enum { _YES = 1, _NO = 0 }; };




 template <typename T>
 struct is_bool
 {
  enum is_bool_enum
  {
   _YES = 0,
   _NO = 1
  };
 };

 template <>
 struct is_bool<bool>
 {
  enum is_bool_enum
  {
   _YES = 1,
   _NO = 0
  };
 };




 template <typename T>
 struct is_vector
 {
  enum is_vector_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 300 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 template <typename T>
 struct is_matrix
 {
  enum is_matrix_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 324 "/usr/include/sgct/glm/./core/_detail.hpp" 3 4
 template <typename T>
 struct type
 {
  enum type_enum
  {
   is_float = is_float<T>::_YES,
   is_int = is_int<T>::_YES,
   is_uint = is_uint<T>::_YES,
   is_bool = is_bool<T>::_YES
  };
 };




 typedef signed char int8;
 typedef signed short int16;
 typedef signed int int32;
 typedef detail::sint64 int64;

 typedef unsigned char uint8;
 typedef unsigned short uint16;
 typedef unsigned int uint32;
 typedef detail::uint64 uint64;

 typedef detail::half float16;
 typedef float float32;
 typedef double float64;




 struct float_or_int_value
 {
  enum
  {
   GLM_ERROR,
   GLM_FLOAT,
   GLM_INT
  };
 };

 template <typename T>
 struct float_or_int_trait
 {
  enum{ID = float_or_int_value::GLM_ERROR};
 };

 template <>
 struct float_or_int_trait<int8>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<int16>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<int32>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<int64>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint8>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint16>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint32>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint64>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<float16>
 {
  enum{ID = float_or_int_value::GLM_FLOAT};
 };

 template <>
 struct float_or_int_trait<float32>
 {
  enum{ID = float_or_int_value::GLM_FLOAT};
 };

 template <>
 struct float_or_int_trait<float64>
 {
  enum{ID = float_or_int_value::GLM_FLOAT};
 };

}
}
# 97 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/type.hpp" 3 4
# 1 "/usr/include/sgct/glm/./core/type_half.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/type_half.hpp" 3 4
# 1 "/usr/include/c++/4.6/cstdlib" 1 3 4
# 41 "/usr/include/c++/4.6/cstdlib" 3 4
       
# 42 "/usr/include/c++/4.6/cstdlib" 3
# 98 "/usr/include/c++/4.6/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }


}
# 158 "/usr/include/c++/4.6/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 193 "/usr/include/c++/4.6/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 33 "/usr/include/sgct/glm/./core/type_half.hpp" 2 3 4

namespace glm{
namespace detail
{
 typedef short hdata;

 float toFloat32(hdata value);
 hdata toFloat16(float const & value);



 class half
 {
 public:

  half();
  half(half const & s);

  template <typename U>
  explicit half(U const & s);


  template <typename U>
  operator U() const;


  half& operator= (half const & s);
  half& operator+=(half const & s);
  half& operator-=(half const & s);
  half& operator*=(half const & s);
  half& operator/=(half const & s);
  half& operator++();
  half& operator--();

  float toFloat() const{return toFloat32(data);}

  hdata _data() const{return data;}

 private:
  hdata data;
 };

 half operator+ (half const & s1, half const & s2);

 half operator- (half const & s1, half const & s2);

 half operator* (half const & s1, half const & s2);

 half operator/ (half const & s1, half const & s2);


 half operator- (half const & s);

 half operator-- (half const & s, int);

 half operator++ (half const & s, int);

 bool operator==(
  detail::half const & x,
  detail::half const & y);

 bool operator!=(
  detail::half const & x,
  detail::half const & y);

 bool operator<(
  detail::half const & x,
  detail::half const & y);

 bool operator<=(
  detail::half const & x,
  detail::half const & y);

 bool operator>(
  detail::half const & x,
  detail::half const & y);

 bool operator>=(
  detail::half const & x,
  detail::half const & y);

}
}

# 1 "/usr/include/sgct/glm/./core/type_half.inl" 1 3 4
# 33 "/usr/include/sgct/glm/./core/type_half.inl" 3 4
# 1 "/usr/include/sgct/glm/./core/_detail.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_half.inl" 2 3 4

namespace glm{
namespace detail
{
 inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f *= f;

  return f;
 }

 inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif result;
    result.i = (unsigned int)(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif result;
    result.i = (unsigned int)((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif result;
    result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif Result;
  Result.i = (unsigned int)((s << 31) | (e << 23) | m);
  return Result.f;
 }

 inline hdata toFloat16(float const & f)
 {
  uif Entry;
  Entry.f = f;
  int i = (int)Entry.i;
# 138 "/usr/include/sgct/glm/./core/type_half.inl" 3 4
  register int s = (i >> 16) & 0x00008000;
  register int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  register int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 158 "/usr/include/sgct/glm/./core/type_half.inl" 3 4
    return 0;
   }
# 168 "/usr/include/sgct/glm/./core/type_half.inl" 3 4
   m = (m | 0x00800000) >> (1 - e);
# 179 "/usr/include/sgct/glm/./core/type_half.inl" 3 4
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 210 "/usr/include/sgct/glm/./core/type_half.inl" 3 4
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 226 "/usr/include/sgct/glm/./core/type_half.inl" 3 4
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

 inline half::half() :
  data(0)
 {}

 inline half::half(half const & s) :
  data(s.data)
 {}

 template <typename U>
 inline half::half(U const & s) :
  data(toFloat16(float(s)))
 {}

 template <typename U>
 inline half::operator U() const
 {
  return static_cast<U>(toFloat32(this->data));
 }


 inline half& half::operator= (half const & s)
 {
  data = s.data;
  return *this;
 }

 inline half& half::operator+=(half const & s)
 {
  data = toFloat16(toFloat32(data) + toFloat32(s.data));
  return *this;
 }

 inline half& half::operator-=(half const & s)
 {
  data = toFloat16(toFloat32(data) - toFloat32(s.data));
  return *this;
 }

 inline half& half::operator*=(half const & s)
 {
  data = toFloat16(toFloat32(data) * toFloat32(s.data));
  return *this;
 }

 inline half& half::operator/=(half const & s)
 {
  data = toFloat16(toFloat32(data) / toFloat32(s.data));
  return *this;
 }

 inline half& half::operator++()
 {
  float Casted = toFloat32(data);
  this->data = toFloat16(++Casted);
  return *this;
 }

 inline half& half::operator--()
 {
  float Casted = toFloat32(data);
  this->data = toFloat16(--Casted);
  return *this;
 }




 inline detail::half operator+ (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) + float(s2));
 }

 inline detail::half operator- (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) - float(s2));
 }

 inline detail::half operator* (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) * float(s2));
 }

 inline detail::half operator/ (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) / float(s2));
 }


 inline detail::half operator- (detail::half const & s)
 {
  return detail::half(-float(s));
 }

 inline detail::half operator-- (detail::half const & s, int)
 {
  return detail::half(float(s) - 1.0f);
 }

 inline detail::half operator++ (detail::half const & s, int)
 {
  return detail::half(float(s) + 1.0f);
 }

 inline bool operator==
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return x._data() == y._data();
 }

 inline bool operator!=
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return x._data() != y._data();
 }

 inline bool operator<
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) < float(y);
 }

 inline bool operator<=
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) <= float(y);
 }

 inline bool operator>
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) > float(y);
 }

 inline bool operator>=
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) >= float(y);
 }

}
}
# 118 "/usr/include/sgct/glm/./core/type_half.hpp" 2 3 4
# 33 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_float.hpp" 1 3 4
# 35 "/usr/include/sgct/glm/./core/type_float.hpp" 3 4
namespace glm
{



    typedef float lowp_float_t;

    typedef float mediump_float_t;
    typedef double highp_float_t;
# 53 "/usr/include/sgct/glm/./core/type_float.hpp" 3 4
    typedef lowp_float_t lowp_float;






    typedef mediump_float_t mediump_float;






    typedef highp_float_t highp_float;


 typedef mediump_float float_t;
# 82 "/usr/include/sgct/glm/./core/type_float.hpp" 3 4
}
# 34 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_int.hpp" 1 3 4
# 35 "/usr/include/sgct/glm/./core/type_int.hpp" 3 4
namespace glm{
namespace detail
{
 typedef signed short lowp_int_t;
 typedef signed int mediump_int_t;
 typedef sint64 highp_int_t;

 typedef unsigned short lowp_uint_t;
 typedef unsigned int mediump_uint_t;
 typedef uint64 highp_uint_t;

 template <> struct is_int<signed char> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<signed short> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<signed int> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<signed long> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<highp_int_t> { enum is_int_enum { _YES = 1, _NO = 0 }; };

 template <> struct is_uint<unsigned char> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<unsigned short> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<unsigned int> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<unsigned long> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<highp_uint_t> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
}
# 67 "/usr/include/sgct/glm/./core/type_int.hpp" 3 4
 typedef detail::lowp_int_t lowp_int;






 typedef detail::mediump_int_t mediump_int;






 typedef detail::highp_int_t highp_int;






 typedef detail::lowp_uint_t lowp_uint;






 typedef detail::mediump_uint_t mediump_uint;






 typedef detail::highp_uint_t highp_uint;


 typedef mediump_int int_t;
# 117 "/usr/include/sgct/glm/./core/type_int.hpp" 3 4
 typedef mediump_uint uint_t;
# 131 "/usr/include/sgct/glm/./core/type_int.hpp" 3 4
 typedef uint_t uint;



}
# 35 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4

# 1 "/usr/include/sgct/glm/./core/type_gentype.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/type_gentype.hpp" 3 4
# 1 "/usr/include/sgct/glm/./core/type_size.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/type_size.hpp" 3 4
# 1 "/usr/include/c++/4.6/cstdlib" 1 3 4
# 41 "/usr/include/c++/4.6/cstdlib" 3 4
       
# 42 "/usr/include/c++/4.6/cstdlib" 3
# 33 "/usr/include/sgct/glm/./core/type_size.hpp" 2 3 4

namespace glm{
namespace detail
{

 typedef int sizeType;

}
}
# 33 "/usr/include/sgct/glm/./core/type_gentype.hpp" 2 3 4

namespace glm
{
 enum profile
 {
  nice,
  fast,
  simd
 };

namespace detail
{
 template
 <
  typename VALTYPE,
  template <typename> class TYPE
 >
 struct genType
 {
 public:
  enum ctor{null};

  typedef VALTYPE value_type;
  typedef VALTYPE & value_reference;
  typedef VALTYPE * value_pointer;
  typedef VALTYPE const * value_const_pointer;
  typedef TYPE<bool> bool_type;

  typedef sizeType size_type;
  static bool is_vector();
  static bool is_matrix();

  typedef TYPE<VALTYPE> type;
  typedef TYPE<VALTYPE> * pointer;
  typedef TYPE<VALTYPE> const * const_pointer;
  typedef TYPE<VALTYPE> const * const const_pointer_const;
  typedef TYPE<VALTYPE> * const pointer_const;
  typedef TYPE<VALTYPE> & reference;
  typedef TYPE<VALTYPE> const & const_reference;
  typedef TYPE<VALTYPE> const & param_type;




  value_const_pointer value_address() const{return value_pointer(this);}
  value_pointer value_address(){return value_pointer(this);}
# 89 "/usr/include/sgct/glm/./core/type_gentype.hpp" 3 4
 };

 template
 <
  typename VALTYPE,
  template <typename> class TYPE
 >
 bool genType<VALTYPE, TYPE>::is_vector()
 {
  return true;
 }
# 164 "/usr/include/sgct/glm/./core/type_gentype.hpp" 3 4
 }
}
# 37 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4

# 1 "/usr/include/sgct/glm/./core/type_vec1.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/type_vec1.hpp" 3 4
# 1 "/usr/include/sgct/glm/./core/type_vec.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_vec.hpp" 3 4
namespace glm{
namespace detail
{

}
}
# 33 "/usr/include/sgct/glm/./core/type_vec1.hpp" 2 3 4



# 1 "/usr/include/sgct/glm/./core/_swizzle.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/_swizzle.hpp" 3 4
# 1 "/usr/include/sgct/glm/./core/_swizzle_func.hpp" 1 3 4
# 33 "/usr/include/sgct/glm/./core/_swizzle.hpp" 2 3 4

namespace glm
{
 enum comp
 {
  X = 0,
  R = 0,
  S = 0,
  Y = 1,
  G = 1,
  T = 1,
  Z = 2,
  B = 2,
  P = 2,
  W = 3,
  A = 3,
  Q = 3
 };
}

namespace glm{
namespace detail
{

    template <typename T, int N>
    struct _swizzle_base0
    {
        typedef T value_type;

    protected:
        value_type& elem (size_t i) { return (reinterpret_cast<value_type*>(_buffer))[i]; }
        const value_type& elem (size_t i) const { return (reinterpret_cast<const value_type*>(_buffer))[i]; }




        char _buffer[1];
    };

    template <typename T, typename V, int E0, int E1, int E2, int E3, int N>
    struct _swizzle_base1 : public _swizzle_base0<T,N>
    {
    };

    template <typename T, typename V, int E0, int E1>
    struct _swizzle_base1<T,V,E0,E1,-1,-2,2> : public _swizzle_base0<T,2>
    {
        V operator ()() const { return V(this->elem(E0), this->elem(E1)); }
    };

    template <typename T, typename V, int E0, int E1, int E2>
    struct _swizzle_base1<T,V,E0,E1,E2,-1,3> : public _swizzle_base0<T,3>
    {
        V operator ()() const { return V(this->elem(E0), this->elem(E1), this->elem(E2)); }
    };

    template <typename T, typename V, int E0, int E1, int E2, int E3>
    struct _swizzle_base1<T,V,E0,E1,E2,E3,4> : public _swizzle_base0<T,4>
    {
        V operator ()() const { return V(this->elem(E0), this->elem(E1), this->elem(E2), this->elem(E3)); }
    };
# 107 "/usr/include/sgct/glm/./core/_swizzle.hpp" 3 4
    template <typename ValueType, typename VecType, int N, int E0, int E1, int E2, int E3, int DUPLICATE_ELEMENTS>
    struct _swizzle_base2 : public _swizzle_base1<ValueType,VecType,E0,E1,E2,E3,N>
    {
  typedef VecType vec_type;
  typedef ValueType value_type;

  _swizzle_base2& operator= (const ValueType& t)
  {
   for (int i = 0; i < N; ++i)
    (*this)[i] = t;
   return *this;
  }

  _swizzle_base2& operator= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e = t; }
   };
   _apply_op(that, op());
   return *this;
  }

  void operator -= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e -= t; }
   };
   _apply_op(that, op());
  }

  void operator += (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e += t; }
   };
   _apply_op(that, op());
  }

  void operator *= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e *= t; }
   };
   _apply_op(that, op());
  }

  void operator /= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e /= t; }
   };
   _apply_op(that, op());
  }

  value_type& operator[] (size_t i)
  {
   static const int offset_dst[4] = { E0, E1, E2, E3 };
   return this->elem(offset_dst[i]);
  }
  value_type operator[] (size_t i) const
  {
   static const int offset_dst[4] = { E0, E1, E2, E3 };
   return this->elem(offset_dst[i]);
  }
 protected:
  template <typename T>
  void _apply_op(const VecType& that, T op)
  {



   ValueType t[N];
   for (int i = 0; i < N; ++i)
    t[i] = that[i];
   for (int i = 0; i < N; ++i)
    op( (*this)[i], t[i] );
  }
    };


 template <typename ValueType, typename VecType, int N, int E0, int E1, int E2, int E3>
 struct _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,1> : public _swizzle_base1<ValueType,VecType,E0,E1,E2,E3,N>
 {
  typedef VecType vec_type;
  typedef ValueType value_type;

  struct Stub {};
  _swizzle_base2& operator= (const Stub& that) {}

  value_type operator[] (size_t i) const
  {
   static const int offset_dst[4] = { E0, E1, E2, E3 };
   return this->elem(offset_dst[i]);
  }
 };

 template <int N,typename ValueType, typename VecType, int E0,int E1,int E2,int E3>
 struct swizzle : public _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,(E0==E1||E0==E2||E0==E3||E1==E2||E1==E3||E2==E3)>
 {
  typedef _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,(E0==E1||E0==E2||E0==E3||E1==E2||E1==E3||E2==E3)> base_type;

  using base_type::operator=;

  operator VecType () const { return (*this)(); }
 };
# 316 "/usr/include/sgct/glm/./core/_swizzle.hpp" 3 4
}
}

namespace glm
{
 namespace detail
 {
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const T& b) { return a() - b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const T& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a - b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const T& b) { return a() * b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const T& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a * b(); }

  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator + ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() + b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator + ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() + b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator + ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a + b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() - b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() - b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a - b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() * b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() * b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a * b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator / ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() / b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator / ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() / b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator / ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a / b(); }
 }
# 352 "/usr/include/sgct/glm/./core/_swizzle.hpp" 3 4
}
# 37 "/usr/include/sgct/glm/./core/type_vec1.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T> struct tref1;
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;

 template <typename T>
 struct tvec1
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  size_type length() const;

  typedef tvec1<T> type;
  typedef tvec1<bool> bool_type;







   union {value_type x, r, s;};





  value_type & operator[](size_type i);
  value_type const & operator[](size_type i) const;




  tvec1();
  tvec1(tvec1<T> const & v);




  explicit tvec1(
   ctor);
  explicit tvec1(
   value_type const & s);




  tvec1(tref1<T> const & r);





  template <typename U>
  explicit tvec1(U const & s);





  template <typename U>
  explicit tvec1(tvec2<U> const & v);

  template <typename U>
  explicit tvec1(tvec3<U> const & v);

  template <typename U>
  explicit tvec1(tvec4<U> const & v);




  tvec1<T> & operator= (tvec1<T> const & v);
  template <typename U>
  tvec1<T> & operator= (tvec1<U> const & v);

  template <typename U>
  tvec1<T> & operator+=(U const & s);
  template <typename U>
  tvec1<T> & operator+=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator-=(U const & s);
  template <typename U>
  tvec1<T> & operator-=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator*=(U const & s);
  template <typename U>
  tvec1<T> & operator*=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator/=(U const & s);
  template <typename U>
  tvec1<T> & operator/=(tvec1<U> const & v);
  tvec1<T> & operator++();
  tvec1<T> & operator--();




  template <typename U>
  tvec1<T> & operator%=(U const & s);
  template <typename U>
  tvec1<T> & operator%=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator&=(U const & s);
  template <typename U>
  tvec1<T> & operator&=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator|=(U const & s);
  template <typename U>
  tvec1<T> & operator|=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator^=(U const & s);
  template <typename U>
  tvec1<T> & operator^=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator<<=(U const & s);
  template <typename U>
  tvec1<T> & operator<<=(tvec1<U> const & v);
  template <typename U>
  tvec1<T> & operator>>=(U const & s);
  template <typename U>
  tvec1<T> & operator>>=(tvec1<U> const & v);




  value_type swizzle(comp X) const;
  tvec2<T> swizzle(comp X, comp Y) const;
  tvec3<T> swizzle(comp X, comp Y, comp Z) const;
  tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
  tref1<T> swizzle(comp X);
 };

 template <typename T>
 struct tref1
 {
  tref1(T & x);
  tref1(tref1<T> const & r);
  tref1(tvec1<T> const & v);

  tref1<T> & operator= (tref1<T> const & r);
  tref1<T> & operator= (tvec1<T> const & v);

  T& x;
 };

 template <typename T> struct is_vector<tvec1<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };

 typedef detail::tvec1<highp_float> highp_vec1_t;
 typedef detail::tvec1<mediump_float> mediump_vec1_t;
 typedef detail::tvec1<lowp_float> lowp_vec1_t;
 typedef detail::tvec1<highp_int> highp_ivec1_t;
 typedef detail::tvec1<mediump_int> mediump_ivec1_t;
 typedef detail::tvec1<lowp_int> lowp_ivec1_t;
 typedef detail::tvec1<highp_uint> highp_uvec1_t;
 typedef detail::tvec1<mediump_uint> mediump_uvec1_t;
 typedef detail::tvec1<lowp_uint> lowp_uvec1_t;

}
}


# 1 "/usr/include/sgct/glm/./core/type_vec1.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_vec1.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T>
 inline typename tvec1<T>::size_type tvec1<T>::length() const
 {
  return 1;
 }




 template <typename T>
 inline typename tvec1<T>::value_type & tvec1<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec1.inl", 47, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T>
 inline typename tvec1<T>::value_type const & tvec1<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec1.inl", 57, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T>
 inline tvec1<T>::tvec1() :
  x(value_type(0))
 {}

 template <typename T>
 inline tvec1<T>::tvec1
 (
  ctor
 )
 {}

 template <typename T>
 inline tvec1<T>::tvec1
 (
  tvec1<T> const & v
 ) :
  x(v.x)
 {}




 template <typename T>
 inline tvec1<T>::tvec1
 (
  value_type const & s
 ) :
  x(s)
 {}




 template <typename T>
 inline tvec1<T>::tvec1
 (
  tref1<T> const & r
 ) :
  x(r.x)
 {}




 template <typename T>
 template <typename U>
 inline tvec1<T>::tvec1
 (
  U const & s
 ) :
  x(value_type(s))
 {}




 template <typename T>
 template <typename U>
 inline tvec1<T>::tvec1
 (
  tvec2<U> const & v
 ) :
  x(value_type(v.x))
 {}

 template <typename T>
 template <typename U>
 inline tvec1<T>::tvec1
 (
  tvec3<U> const & v
 ) :
  x(value_type(v.x))
 {}

 template <typename T>
 template <typename U>
 inline tvec1<T>::tvec1
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x))
 {}




 template <typename T>
 inline tvec1<T> & tvec1<T>::operator=
 (
  tvec1<T> const & v
 )
 {
  this->x = v.x;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator=
 (
  tvec1<U> const & v
 )
 {
  this->x = T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator+=
 (
  tvec1<U> const & v
 )
 {
  this->x += T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator-=
 (
  tvec1<U> const & v
 )
 {
  this->x -= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator*=
 (
  tvec1<U> const & v
 )
 {
  this->x *= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator/=
 (
  tvec1<U> const & v
 )
 {
  this->x /= T(v.x);
  return *this;
 }

 template <typename T>
 inline tvec1<T> & tvec1<T>::operator++()
 {
  ++this->x;
  return *this;
 }

 template <typename T>
 inline tvec1<T> & tvec1<T>::operator--()
 {
  --this->x;
  return *this;
 }




 template <typename T>
 inline bool operator==
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return (v1.x == v2.x);
 }

 template <typename T>
 inline bool operator!=
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return (v1.x != v2.x);
 }




 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator%=
 (
  tvec1<U> const & v
 )
 {
  this->x %= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator&=
 (
  tvec1<U> const & v
 )
 {
  this->x &= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator|=
 (
  tvec1<U> const & v
 )
 {
  this->x |= U(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator^=
 (
  tvec1<U> const & v
 )
 {
  this->x ^= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator<<=
 (
  tvec1<U> const & v
 )
 {
  this->x <<= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec1<T> & tvec1<T>::operator>>=
 (
  tvec1<U> const & v
 )
 {
  this->x >>= T(v.x);
  return *this;
 }




 template <typename T>
 inline T
 tvec1<T>::swizzle(comp x) const
 {
  return (*this)[x];
 }

 template <typename T>
 inline tvec2<T>
 tvec1<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T>
 inline tvec3<T>
 tvec1<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T>
 inline tvec4<T>
 tvec1<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T>
 inline tref1<T>
 tvec1<T>::swizzle
 (
  comp x
 )
 {
  return tref1<T>(
   (*this)[x]);
 }




 template <typename T>
 inline tvec1<T> operator+
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x + s);
 }

 template <typename T>
 inline tvec1<T> operator+
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s + v.x);
 }

 template <typename T>
 inline tvec1<T> operator+
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x + v2.x);
 }


 template <typename T>
 inline tvec1<T> operator-
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x - s);
 }

 template <typename T>
 inline tvec1<T> operator-
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s - v.x);
 }

 template <typename T>
 inline tvec1<T> operator-
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x - v2.x);
 }


 template <typename T>
 inline tvec1<T> operator*
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x * s);
 }

 template <typename T>
 inline tvec1<T> operator*
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s * v.x);
 }

 template <typename T>
 inline tvec1<T> operator*
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x * v2.x);
 }


 template <typename T>
 inline tvec1<T> operator/
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x / s);
 }

 template <typename T>
 inline tvec1<T> operator/
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s / v.x);
 }

 template <typename T>
 inline tvec1<T> operator/
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x / v2.x);
 }


 template <typename T>
 inline tvec1<T> operator-
 (
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   -v.x);
 }

 template <typename T>
 inline tvec1<T> operator++
 (
  tvec1<T> const & v,
  int
 )
 {
  return tvec1<T>(
   v.x + T(1));
 }

 template <typename T>
 inline tvec1<T> operator--
 (
  tvec1<T> const & v,
  int
 )
 {
  return tvec1<T>(
   v.x - T(1));
 }




 template <typename T>
 inline tvec1<T> operator%
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x % s);
 }

 template <typename T>
 inline tvec1<T> operator%
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s % v.x);
 }

 template <typename T>
 inline tvec1<T> operator%
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x % v2.x);
 }

 template <typename T>
 inline tvec1<T> operator&
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x & s);
 }

 template <typename T>
 inline tvec1<T> operator&
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s & v.x);
 }

 template <typename T>
 inline tvec1<T> operator&
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x & v2.x);
 }

 template <typename T>
 inline tvec1<T> operator|
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x | s);
 }

 template <typename T>
 inline tvec1<T> operator|
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s | v.x);
 }

 template <typename T>
 inline tvec1<T> operator|
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x | v2.x);
 }

 template <typename T>
 inline tvec1<T> operator^
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x ^ s);
 }

 template <typename T>
 inline tvec1<T> operator^
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s ^ v.x);
 }

 template <typename T>
 inline tvec1<T> operator^
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x ^ v2.x);
 }

 template <typename T>
 inline tvec1<T> operator<<
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x << s);
 }

 template <typename T>
 inline tvec1<T> operator<<
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s << v.x);
 }

 template <typename T>
 inline tvec1<T> operator<<
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x << v2.x);
 }

 template <typename T>
 inline tvec1<T> operator>>
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x >> s);
 }

 template <typename T>
 inline tvec1<T> operator>>
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s >> v.x);
 }

 template <typename T>
 inline tvec1<T> operator>>
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x >> v2.x);
 }

 template <typename T>
 inline tvec1<T> operator~
 (
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   ~v.x);
 }




 template <typename T>
 inline tref1<T>::tref1
 (
  T & x
 ) :
  x(x)
 {}

 template <typename T>
 inline tref1<T>::tref1
 (
  tref1<T> const & r
 ) :
  x(r.x)
 {}

 template <typename T>
 inline tref1<T>::tref1
 (
  tvec1<T> const & v
 ) :
  x(v.x)
 {}

 template <typename T>
 inline tref1<T> & tref1<T>::operator=
 (
  tref1<T> const & r
 )
 {
  x = r.x;
  return *this;
 }

 template <typename T>
 inline tref1<T> & tref1<T>::operator=
 (
  tvec1<T> const & v
 )
 {
  x = v.x;
  return *this;
 }

}
}
# 210 "/usr/include/sgct/glm/./core/type_vec1.hpp" 2 3 4
# 39 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_vec2.hpp" 1 3 4
# 38 "/usr/include/sgct/glm/./core/type_vec2.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;



 template <typename T>
 struct tvec2
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  size_type length() const;

  typedef tvec2<T> type;
  typedef tvec2<bool> bool_type;
# 84 "/usr/include/sgct/glm/./core/type_vec2.hpp" 3 4
  union {value_type x, r, s;};
  union {value_type y, g, t;};
# 105 "/usr/include/sgct/glm/./core/type_vec2.hpp" 3 4
  value_type & operator[](size_type i);
  value_type const & operator[](size_type i) const;




  tvec2();
  tvec2(tvec2<T> const & v);




  explicit tvec2(
   ctor);
  explicit tvec2(
   value_type const & s);
  explicit tvec2(
   value_type const & s1,
   value_type const & s2);




  tvec2(tref2<T> const & r);

        template <int E0, int E1>
        tvec2(const glm::detail::swizzle<2,T,tvec2<T>,E0,E1,-1,-2>& that)
        {
            *this = that();
        }





  template <typename U>
  explicit tvec2(
   U const & x);

  template <typename U, typename V>
  explicit tvec2(
   U const & x,
   V const & y);





  template <typename U>
  explicit tvec2(tvec2<U> const & v);

  template <typename U>
  explicit tvec2(tvec3<U> const & v);

  template <typename U>
  explicit tvec2(tvec4<U> const & v);




  tvec2<T> & operator= (tvec2<T> const & v);
  template <typename U>
  tvec2<T> & operator= (tvec2<U> const & v);

  template <typename U>
  tvec2<T> & operator+=(U const & s);
  template <typename U>
  tvec2<T> & operator+=(tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator-=(U const & s);
  template <typename U>
  tvec2<T> & operator-=(tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator*=(U const & s);
  template <typename U>
  tvec2<T> & operator*=(tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator/=(U const & s);
  template <typename U>
  tvec2<T> & operator/=(tvec2<U> const & v);
  tvec2<T> & operator++();
  tvec2<T> & operator--();




  template <typename U>
  tvec2<T> & operator%= (U const & s);
  template <typename U>
  tvec2<T> & operator%= (tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator&= (U const & s);
  template <typename U>
  tvec2<T> & operator&= (tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator|= (U const & s);
  template <typename U>
  tvec2<T> & operator|= (tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator^= (U const & s);
  template <typename U>
  tvec2<T> & operator^= (tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator<<=(U const & s);
  template <typename U>
  tvec2<T> & operator<<=(tvec2<U> const & v);
  template <typename U>
  tvec2<T> & operator>>=(U const & s);
  template <typename U>
  tvec2<T> & operator>>=(tvec2<U> const & v);




  value_type swizzle(comp X) const;
  tvec2<T> swizzle(comp X, comp Y) const;
  tvec3<T> swizzle(comp X, comp Y, comp Z) const;
  tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
  tref2<T> swizzle(comp X, comp Y);
 };

 template <typename T>
 struct tref2
 {
  tref2(T & x, T & y);
  tref2(tref2<T> const & r);
  explicit tref2(tvec2<T> const & v);

  tref2<T> & operator= (tref2<T> const & r);
  tref2<T> & operator= (tvec2<T> const & v);

  tvec2<T> operator() ();

  T & x;
  T & y;
 };

 template <typename T> struct is_vector<tvec2<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };

}
# 254 "/usr/include/sgct/glm/./core/type_vec2.hpp" 3 4
 typedef detail::tvec2<highp_float> highp_vec2;






 typedef detail::tvec2<mediump_float> mediump_vec2;






 typedef detail::tvec2<lowp_float> lowp_vec2;






 typedef detail::tvec2<highp_int> highp_ivec2;






 typedef detail::tvec2<mediump_int> mediump_ivec2;






 typedef detail::tvec2<lowp_int> lowp_ivec2;






 typedef detail::tvec2<highp_uint> highp_uvec2;






 typedef detail::tvec2<mediump_uint> mediump_uvec2;






 typedef detail::tvec2<lowp_uint> lowp_uvec2;


}


# 1 "/usr/include/sgct/glm/./core/type_vec2.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_vec2.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T>
 inline typename tvec2<T>::size_type tvec2<T>::length() const
 {
  return 2;
 }




 template <typename T>
 inline typename tvec2<T>::value_type &
 tvec2<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec2.inl", 48, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T>
 inline typename tvec2<T>::value_type const &
 tvec2<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec2.inl", 59, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T>
 inline tvec2<T>::tvec2() :
  x(value_type(0)),
  y(value_type(0))
 {}

 template <typename T>
 inline tvec2<T>::tvec2
 (
  ctor
 )
 {}

 template <typename T>
 inline tvec2<T>::tvec2
 (
  tvec2<T> const & v
 ) :
  x(v.x),
  y(v.y)
 {}




 template <typename T>
 inline tvec2<T>::tvec2
 (
  value_type const & s
 ) :
  x(s),
  y(s)
 {}

 template <typename T>
 inline tvec2<T>::tvec2
 (
  value_type const & s1,
  value_type const & s2
 ) :
  x(s1),
  y(s2)
 {}




 template <typename T>
 inline tvec2<T>::tvec2
 (
  tref2<T> const & r
 ) :
  x(r.x),
  y(r.y)
 {}




 template <typename T>
 template <typename U>
 inline tvec2<T>::tvec2
 (
  U const & x
 ) :
  x(value_type(x)),
  y(value_type(x))
 {}

 template <typename T>
 template <typename U, typename V>
 inline tvec2<T>::tvec2
 (
  U const & a,
  V const & b
 ) :
  x(value_type(a)),
  y(value_type(b))
 {}




 template <typename T>
 template <typename U>
 inline tvec2<T>::tvec2
 (
  tvec2<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y))
 {}

 template <typename T>
 template <typename U>
 inline tvec2<T>::tvec2
 (
  tvec3<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y))
 {}

 template <typename T>
 template <typename U>
 inline tvec2<T>::tvec2
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y))
 {}




 template <typename T>
 inline tvec2<T> & tvec2<T>::operator=
 (
  tvec2<T> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator=
 (
  tvec2<U> const & v
 )
 {
  this->x = T(v.x);
  this->y = T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  this->y += T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator+=
 (
  tvec2<U> const & v
 )
 {
  this->x += T(v.x);
  this->y += T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  this->y -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator-=
 (
  tvec2<U> const & v
 )
 {
  this->x -= T(v.x);
  this->y -= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  this->y *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator*=
 (
  tvec2<U> const & v
 )
 {
  this->x *= T(v.x);
  this->y *= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  this->y /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator/=
 (
  tvec2<U> const & v
 )
 {
  this->x /= T(v.x);
  this->y /= T(v.y);
  return *this;
 }

 template <typename T>
 inline tvec2<T> & tvec2<T>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template <typename T>
 inline tvec2<T> & tvec2<T>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }




 template <typename T>
 inline bool operator==
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y);
 }

 template <typename T>
 inline bool operator!=
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y);
 }




 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= T(s);
  this->y %= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator%=
 (
  tvec2<U> const & v
 )
 {
  this->x %= T(v.x);
  this->y %= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= T(s);
  this->y &= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator&=
 (
  tvec2<U> const & v
 )
 {
  this->x &= T(v.x);
  this->y &= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= T(s);
  this->y |= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator|=
 (
  tvec2<U> const & v
 )
 {
  this->x |= T(v.x);
  this->y |= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= T(s);
  this->y ^= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator^=
 (
  tvec2<U> const & v
 )
 {
  this->x ^= T(v.x);
  this->y ^= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= T(s);
  this->y <<= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator<<=
 (
  tvec2<U> const & v
 )
 {
  this->x <<= T(v.x);
  this->y <<= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  this->y >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec2<T> & tvec2<T>::operator>>=
 (
  tvec2<U> const & v
 )
 {
  this->x >>= T(v.x);
  this->y >>= T(v.y);
  return *this;
 }




 template <typename T>
 inline typename tvec2<T>::value_type tvec2<T>::swizzle
 (
  comp x
 ) const
 {
  return (*this)[x];
 }

 template <typename T>
 inline tvec2<T> tvec2<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T>
 inline tvec3<T> tvec2<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T>
 inline tvec4<T> tvec2<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T>
 inline tref2<T> tvec2<T>::swizzle
 (
  comp x,
  comp y
 )
 {
  return tref2<T>(
   (*this)[x],
   (*this)[y]);
 }




 template <typename T>
 inline tvec2<T> operator+
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x + T(s),
   v.y + T(s));
 }

 template <typename T>
 inline tvec2<T> operator+
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) + v.x,
   T(s) + v.y);
 }

 template <typename T>
 inline tvec2<T> operator+
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x + T(v2.x),
   v1.y + T(v2.y));
 }


 template <typename T>
 inline tvec2<T> operator-
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x - T(s),
   v.y - T(s));
 }

 template <typename T>
 inline tvec2<T> operator-
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) - v.x,
   T(s) - v.y);
 }

 template <typename T>
 inline tvec2<T> operator-
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x - T(v2.x),
   v1.y - T(v2.y));
 }


 template <typename T>
 inline tvec2<T> operator*
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x * T(s),
   v.y * T(s));
 }

 template <typename T>
 inline tvec2<T> operator*
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) * v.x,
   T(s) * v.y);
 }

 template <typename T>
 inline tvec2<T> operator*
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x * T(v2.x),
   v1.y * T(v2.y));
 }


 template <typename T>
 inline tvec2<T> operator/
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x / T(s),
   v.y / T(s));
 }

 template <typename T>
 inline tvec2<T> operator/
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) / v.x,
   T(s) / v.y);
 }

 template <typename T>
 inline tvec2<T> operator/
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x / T(v2.x),
   v1.y / T(v2.y));
 }


 template <typename T>
 inline tvec2<T> operator-
 (
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   -v.x,
   -v.y);
 }

 template <typename T>
 inline tvec2<T> operator++
 (
  tvec2<T> const & v,
  int
 )
 {
  return tvec2<T>(
   v.x + T(1),
   v.y + T(1));
 }

 template <typename T>
 inline tvec2<T> operator--
 (
  tvec2<T> const & v,
  int
 )
 {
  return tvec2<T>(
   v.x - T(1),
   v.y - T(1));
 }




 template <typename T>
 inline tvec2<T> operator%
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x % T(s),
   v.y % T(s));
 }

 template <typename T>
 inline tvec2<T> operator%
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) % v.x,
   T(s) % v.y);
 }

 template <typename T>
 inline tvec2<T> operator%
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x % T(v2.x),
   v1.y % T(v2.y));
 }

 template <typename T>
 inline tvec2<T> operator&
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x & T(s),
   v.y & T(s));
 }

 template <typename T>
 inline tvec2<T> operator&
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) & v.x,
   T(s) & v.y);
 }

 template <typename T>
 inline tvec2<T> operator&
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x & T(v2.x),
   v1.y & T(v2.y));
 }

 template <typename T>
 inline tvec2<T> operator|
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x | T(s),
   v.y | T(s));
 }

 template <typename T>
 inline tvec2<T> operator|
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) | v.x,
   T(s) | v.y);
 }

 template <typename T>
 inline tvec2<T> operator|
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x | T(v2.x),
   v1.y | T(v2.y));
 }

 template <typename T>
 inline tvec2<T> operator^
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x ^ T(s),
   v.y ^ T(s));
 }

 template <typename T>
 inline tvec2<T> operator^
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) ^ v.x,
   T(s) ^ v.y);
 }

 template <typename T>
 inline tvec2<T> operator^
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x ^ T(v2.x),
   v1.y ^ T(v2.y));
 }

 template <typename T>
 inline tvec2<T> operator<<
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x << T(s),
   v.y << T(s));
 }

 template <typename T>
 inline tvec2<T> operator<<
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   s << T(v.x),
   s << T(v.y));
 }

 template <typename T>
 inline tvec2<T> operator<<
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x << T(v2.x),
   v1.y << T(v2.y));
 }

 template <typename T>
 inline tvec2<T> operator>>
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x >> T(s),
   v.y >> T(s));
 }

 template <typename T>
 inline tvec2<T> operator>>
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) >> v.x,
   T(s) >> v.y);
 }

 template <typename T>
 inline tvec2<T> operator>>
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x >> T(v2.x),
   v1.y >> T(v2.y));
 }

 template <typename T>
 inline tvec2<T> operator~
 (
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   ~v.x,
   ~v.y);
 }




 template <typename T>
 tref2<T>::tref2
 (
  T & x,
  T & y
 ) :
  x(x),
  y(y)
 {}

 template <typename T>
 tref2<T>::tref2
 (
  tref2<T> const & r
 ) :
  x(r.x),
  y(r.y)
 {}

 template <typename T>
 tref2<T>::tref2
 (
  tvec2<T> const & v
 ) :
  x(v.x),
  y(v.y)
 {}

 template <typename T>
 tref2<T>& tref2<T>::operator=
 (
  tref2<T> const & r
 )
 {
  x = r.x;
  y = r.y;
  return *this;
 }

 template <typename T>
 tref2<T>& tref2<T>::operator=
 (
  tvec2<T> const & v
 )
 {
  x = v.x;
  y = v.y;
  return *this;
 }

 template <typename T>
 inline tvec2<T> tref2<T>::operator() ()
 {
  return tvec2<T>(this->x, this->y);
 }

}
}
# 317 "/usr/include/sgct/glm/./core/type_vec2.hpp" 2 3 4
# 40 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_vec3.hpp" 1 3 4
# 38 "/usr/include/sgct/glm/./core/type_vec3.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec2;
 template <typename T> struct tvec4;



 template <typename T>
 struct tvec3
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  size_type length() const;

  typedef tvec3<T> type;
  typedef tvec3<bool> bool_type;
# 84 "/usr/include/sgct/glm/./core/type_vec3.hpp" 3 4
  union {value_type x, r, s;};
  union {value_type y, g, t;};
  union {value_type z, b, p;};
# 106 "/usr/include/sgct/glm/./core/type_vec3.hpp" 3 4
  value_type & operator[](size_type i);
  value_type const & operator[](size_type i) const;




  tvec3();
  tvec3(tvec3<T> const & v);




  explicit tvec3(
   ctor);
  explicit tvec3(
   value_type const & s);
  explicit tvec3(
   value_type const & s1,
   value_type const & s2,
   value_type const & s3);





  template <typename U>
  explicit tvec3(
   U const & x);

  template <typename U, typename V, typename W>
  explicit tvec3(
   U const & x,
   V const & y,
   W const & z);





  template <typename A, typename B>
  explicit tvec3(tvec2<A> const & v, B const & s);

  template <typename A, typename B>
  explicit tvec3(A const & s, tvec2<B> const & v);

  template <typename U>
  explicit tvec3(tvec3<U> const & v);

  template <typename U>
  explicit tvec3(tvec4<U> const & v);




  tvec3(tref3<T> const & r);

  template <typename A, typename B>
  explicit tvec3(tref2<A> const & v, B const & s);

  template <typename A, typename B>
  explicit tvec3(A const & s, tref2<B> const & v);

        template <int E0, int E1, int E2>
        tvec3(glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & that)
        {
            *this = that();
        }

        template <int E0, int E1>
        tvec3(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & s)
        {
            *this = tvec3<T>(v(), s);
        }

        template <int E0, int E1>
        tvec3(T const & s, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v)
        {
            *this = tvec3<T>(s, v());
        }




  tvec3<T> & operator= (tvec3<T> const & v);
  template <typename U>
  tvec3<T> & operator= (tvec3<U> const & v);

  template <typename U>
  tvec3<T> & operator+=(U const & s);
  template <typename U>
  tvec3<T> & operator+=(tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator-=(U const & s);
  template <typename U>
  tvec3<T> & operator-=(tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator*=(U const & s);
  template <typename U>
  tvec3<T> & operator*=(tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator/=(U const & s);
  template <typename U>
  tvec3<T> & operator/=(tvec3<U> const & v);
  tvec3<T> & operator++();
  tvec3<T> & operator--();




  template <typename U>
  tvec3<T> & operator%= (U const & s);
  template <typename U>
  tvec3<T> & operator%= (tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator&= (U const & s);
  template <typename U>
  tvec3<T> & operator&= (tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator|= (U const & s);
  template <typename U>
  tvec3<T> & operator|= (tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator^= (U const & s);
  template <typename U>
  tvec3<T> & operator^= (tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator<<=(U const & s);
  template <typename U>
  tvec3<T> & operator<<=(tvec3<U> const & v);
  template <typename U>
  tvec3<T> & operator>>=(U const & s);
  template <typename U>
  tvec3<T> & operator>>=(tvec3<U> const & v);




  value_type swizzle(comp X) const;
  tvec2<T> swizzle(comp X, comp Y) const;
  tvec3<T> swizzle(comp X, comp Y, comp Z) const;
  tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
  tref2<T> swizzle(comp X, comp Y);
  tref3<T> swizzle(comp X, comp Y, comp Z);
 };

 template <typename T>
 struct tref3
 {
  tref3(T & x, T & y, T & z);
  tref3(tref3<T> const & r);
  explicit tref3(tvec3<T> const & v);

  tref3<T> & operator= (tref3<T> const & r);
  tref3<T> & operator= (tvec3<T> const & v);

  tvec3<T> operator() ();

  T & x;
  T & y;
  T & z;
 };

 template <typename T> struct is_vector<tvec3<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };
}
# 279 "/usr/include/sgct/glm/./core/type_vec3.hpp" 3 4
 typedef detail::tvec3<highp_float> highp_vec3;






 typedef detail::tvec3<mediump_float> mediump_vec3;






 typedef detail::tvec3<lowp_float> lowp_vec3;






 typedef detail::tvec3<highp_int> highp_ivec3;






 typedef detail::tvec3<mediump_int> mediump_ivec3;






 typedef detail::tvec3<lowp_int> lowp_ivec3;






 typedef detail::tvec3<highp_uint> highp_uvec3;






 typedef detail::tvec3<mediump_uint> mediump_uvec3;






 typedef detail::tvec3<lowp_uint> lowp_uvec3;


}


# 1 "/usr/include/sgct/glm/./core/type_vec3.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_vec3.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T>
 inline typename tvec3<T>::size_type tvec3<T>::length() const
 {
  return 3;
 }




 template <typename T>
 inline typename tvec3<T>::value_type &
 tvec3<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec3.inl", 48, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T>
 inline typename tvec3<T>::value_type const &
 tvec3<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec3.inl", 59, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T>
 inline tvec3<T>::tvec3() :
  x(value_type(0)),
  y(value_type(0)),
  z(value_type(0))
 {}

 template <typename T>
 inline tvec3<T>::tvec3
 (
  ctor
 )
 {}

 template <typename T>
 inline tvec3<T>::tvec3
 (
  tvec3<T> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z)
 {}




 template <typename T>
 inline tvec3<T>::tvec3
 (
  value_type const & s
 ) :
  x(s),
  y(s),
  z(s)
 {}

 template <typename T>
 inline tvec3<T>::tvec3
 (
  value_type const & s0,
  value_type const & s1,
  value_type const & s2
 ) :
  x(s0),
  y(s1),
  z(s2)
 {}




 template <typename T>
 inline tvec3<T>::tvec3
 (
  tref3<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z)
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec3<T>::tvec3
 (
  tref2<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec3<T>::tvec3
 (
  A const & s,
  tref2<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y))
 {}




 template <typename T>
 template <typename U>
 inline tvec3<T>::tvec3
 (
  U const & s
 ) :
  x(value_type(s)),
  y(value_type(s)),
  z(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B, typename C>
 inline tvec3<T>::tvec3
 (
  A const & x,
  B const & y,
  C const & z
 ) :
  x(value_type(x)),
  y(value_type(y)),
  z(value_type(z))
 {}




 template <typename T>
 template <typename A, typename B>
 inline tvec3<T>::tvec3
 (
  tvec2<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec3<T>::tvec3
 (
  A const & s,
  tvec2<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y))
 {}

 template <typename T>
 template <typename U>
 inline tvec3<T>::tvec3
 (
  tvec3<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z))
 {}

 template <typename T>
 template <typename U>
 inline tvec3<T>::tvec3
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z))
 {}




 template <typename T>
 inline tvec3<T>& tvec3<T>::operator=
 (
  tvec3<T> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T>& tvec3<T>::operator=
 (
  tvec3<U> const & v
 )
 {
  this->x = T(v.x);
  this->y = T(v.y);
  this->z = T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  this->y += T(s);
  this->z += T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator+=
 (
  tvec3<U> const & v
 )
 {
  this->x += T(v.x);
  this->y += T(v.y);
  this->z += T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  this->y -= T(s);
  this->z -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator-=
 (
  tvec3<U> const & v
 )
 {
  this->x -= T(v.x);
  this->y -= T(v.y);
  this->z -= T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  this->y *= T(s);
  this->z *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator*=
 (
  tvec3<U> const & v
 )
 {
  this->x *= T(v.x);
  this->y *= T(v.y);
  this->z *= T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  this->y /= T(s);
  this->z /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator/=
 (
  tvec3<U> const & v
 )
 {
  this->x /= T(v.x);
  this->y /= T(v.y);
  this->z /= T(v.z);
  return *this;
 }

 template <typename T>
 inline tvec3<T> & tvec3<T>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template <typename T>
 inline tvec3<T> & tvec3<T>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }




 template <typename T>
 inline bool operator==
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
 }

 template <typename T>
 inline bool operator!=
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
 }




 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= s;
  this->y %= s;
  this->z %= s;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator%=
 (
  tvec3<U> const & v
 )
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= s;
  this->y &= s;
  this->z &= s;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator&=
 (
  tvec3<U> const & v
 )
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= s;
  this->y |= s;
  this->z |= s;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator|=
 (
  tvec3<U> const & v
 )
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= s;
  this->y ^= s;
  this->z ^= s;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator^=
 (
  tvec3<U> const & v
 )
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= s;
  this->y <<= s;
  this->z <<= s;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator<<=
 (
  tvec3<U> const & v
 )
 {
  this->x <<= T(v.x);
  this->y <<= T(v.y);
  this->z <<= T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  this->y >>= T(s);
  this->z >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec3<T> & tvec3<T>::operator>>=
 (
  tvec3<U> const & v
 )
 {
  this->x >>= T(v.x);
  this->y >>= T(v.y);
  this->z >>= T(v.z);
  return *this;
 }




 template <typename T>
 inline typename tvec3<T>::value_type
 tvec3<T>::swizzle
 (
  comp x
 ) const
 {
  return (*this)[x];
 }

 template <typename T>
 inline tvec2<T> tvec3<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T>
 inline tvec3<T> tvec3<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T>
 inline tvec4<T> tvec3<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T>
 inline tref2<T> tvec3<T>::swizzle
 (
  comp x,
  comp y
 )
 {
  return tref2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T>
 inline tref3<T> tvec3<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 )
 {
  return tref3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }




 template <typename T>
 inline tvec3<T> operator+
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x + T(s),
   v.y + T(s),
   v.z + T(s));
 }

 template <typename T>
 inline tvec3<T> operator+
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) + v.x,
   T(s) + v.y,
   T(s) + v.z);
 }

 template <typename T>
 inline tvec3<T> operator+
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x + T(v2.x),
   v1.y + T(v2.y),
   v1.z + T(v2.z));
 }


 template <typename T>
 inline tvec3<T> operator-
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x - T(s),
   v.y - T(s),
   v.z - T(s));
 }

 template <typename T>
 inline tvec3<T> operator-
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) - v.x,
   T(s) - v.y,
   T(s) - v.z);
 }

 template <typename T>
 inline tvec3<T> operator-
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x - T(v2.x),
   v1.y - T(v2.y),
   v1.z - T(v2.z));
 }


 template <typename T>
 inline tvec3<T> operator*
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x * T(s),
   v.y * T(s),
   v.z * T(s));
 }

 template <typename T>
 inline tvec3<T> operator*
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) * v.x,
   T(s) * v.y,
   T(s) * v.z);
 }

 template <typename T>
 inline tvec3<T> operator*
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x * T(v2.x),
   v1.y * T(v2.y),
   v1.z * T(v2.z));
 }


 template <typename T>
 inline tvec3<T> operator/
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x / T(s),
   v.y / T(s),
   v.z / T(s));
 }

 template <typename T>
 inline tvec3<T> operator/
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) / v.x,
   T(s) / v.y,
   T(s) / v.z);
 }

 template <typename T>
 inline tvec3<T> operator/
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x / T(v2.x),
   v1.y / T(v2.y),
   v1.z / T(v2.z));
 }


 template <typename T>
 inline tvec3<T> operator-
 (
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   -v.x,
   -v.y,
   -v.z);
 }

 template <typename T>
 inline tvec3<T> operator++
 (
  tvec3<T> const & v,
  int
 )
 {
  return tvec3<T>(
   v.x + T(1),
   v.y + T(1),
   v.z + T(1));
 }

 template <typename T>
 inline tvec3<T> operator--
 (
  tvec3<T> const & v,
  int
 )
 {
  return tvec3<T>(
   v.x - T(1),
   v.y - T(1),
   v.z - T(1));
 }




 template <typename T>
 inline tvec3<T> operator%
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x % T(s),
   v.y % T(s),
   v.z % T(s));
 }

 template <typename T>
 inline tvec3<T> operator%
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) % v.x,
   T(s) % v.y,
   T(s) % v.z);
 }

 template <typename T>
 inline tvec3<T> operator%
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x % T(v2.x),
   v1.y % T(v2.y),
   v1.z % T(v2.z));
 }

 template <typename T>
 inline tvec3<T> operator&
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x & T(s),
   v.y & T(s),
   v.z & T(s));
 }

 template <typename T>
 inline tvec3<T> operator&
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) & v.x,
   T(s) & v.y,
   T(s) & v.z);
 }

 template <typename T>
 inline tvec3<T> operator&
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x & T(v2.x),
   v1.y & T(v2.y),
   v1.z & T(v2.z));
 }

 template <typename T>
 inline tvec3<T> operator|
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x | T(s),
   v.y | T(s),
   v.z | T(s));
 }

 template <typename T>
 inline tvec3<T> operator|
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) | v.x,
   T(s) | v.y,
   T(s) | v.z);
 }

 template <typename T>
 inline tvec3<T> operator|
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x | T(v2.x),
   v1.y | T(v2.y),
   v1.z | T(v2.z));
 }

 template <typename T>
 inline tvec3<T> operator^
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x ^ T(s),
   v.y ^ T(s),
   v.z ^ T(s));
 }

 template <typename T>
 inline tvec3<T> operator^
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) ^ v.x,
   T(s) ^ v.y,
   T(s) ^ v.z);
 }

 template <typename T>
 inline tvec3<T> operator^
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x ^ T(v2.x),
   v1.y ^ T(v2.y),
   v1.z ^ T(v2.z));
 }

 template <typename T>
 inline tvec3<T> operator<<
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x << T(s),
   v.y << T(s),
   v.z << T(s));
 }

 template <typename T>
 inline tvec3<T> operator<<
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) << v.x,
   T(s) << v.y,
   T(s) << v.z);
 }

 template <typename T>
 inline tvec3<T> operator<<
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x << T(v2.x),
   v1.y << T(v2.y),
   v1.z << T(v2.z));
 }

 template <typename T>
 inline tvec3<T> operator>>
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x >> T(s),
   v.y >> T(s),
   v.z >> T(s));
 }

 template <typename T>
 inline tvec3<T> operator>>
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   s >> T(v.x),
   s >> T(v.y),
   s >> T(v.z));
 }

 template <typename T>
 inline tvec3<T> operator>>
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x >> T(v2.x),
   v1.y >> T(v2.y),
   v1.z >> T(v2.z));
 }

 template <typename T>
 inline tvec3<T> operator~
 (
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   ~v.x,
   ~v.y,
   ~v.z);
 }




 template <typename T>
 inline tref3<T>::tref3(T & x, T & y, T & z) :
  x(x),
  y(y),
  z(z)
 {}

 template <typename T>
 inline tref3<T>::tref3
 (
  tref3<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z)
 {}

 template <typename T>
 inline tref3<T>::tref3
 (
  tvec3<T> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z)
 {}

 template <typename T>
 inline tref3<T> & tref3<T>::operator=
 (
  tref3<T> const & r
 )
 {
  x = r.x;
  y = r.y;
  z = r.z;
  return *this;
 }

 template <typename T>
 inline tref3<T> & tref3<T>::operator=
 (
  tvec3<T> const & v
 )
 {
  x = v.x;
  y = v.y;
  z = v.z;
  return *this;
 }

 template <typename T>
 inline tvec3<T> tref3<T>::operator() ()
 {
  return tvec3<T>(this->x, this->y, this->z);
 }

}
}
# 342 "/usr/include/sgct/glm/./core/type_vec3.hpp" 2 3 4
# 41 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_vec4.hpp" 1 3 4
# 38 "/usr/include/sgct/glm/./core/type_vec4.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;



 template <typename T>
 struct tvec4
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  size_type length() const;

  typedef tvec4<T> type;
  typedef tvec4<bool> bool_type;
# 84 "/usr/include/sgct/glm/./core/type_vec4.hpp" 3 4
  union {value_type x, r, s;};
  union {value_type y, g, t;};
  union {value_type z, b, p;};
  union {value_type w, a, q;};
# 107 "/usr/include/sgct/glm/./core/type_vec4.hpp" 3 4
  value_type & operator[](size_type i);
  value_type const & operator[](size_type i) const;




  tvec4();
  tvec4(type const & v);




  explicit tvec4(
   ctor);
  explicit tvec4(
   value_type const & s);
  explicit tvec4(
   value_type const & s0,
   value_type const & s1,
   value_type const & s2,
   value_type const & s3);





  template <typename U>
  explicit tvec4(
   U const & x);

  template <typename A, typename B, typename C, typename D>
  explicit tvec4(
   A const & x,
   B const & y,
   C const & z,
   D const & w);





  template <typename A, typename B, typename C>
  explicit tvec4(tvec2<A> const & v, B const & s1, C const & s2);

  template <typename A, typename B, typename C>
  explicit tvec4(A const & s1, tvec2<B> const & v, C const & s2);

  template <typename A, typename B, typename C>
  explicit tvec4(A const & s1, B const & s2, tvec2<C> const & v);

  template <typename A, typename B>
  explicit tvec4(tvec3<A> const & v, B const & s);

  template <typename A, typename B>
  explicit tvec4(A const & s, tvec3<B> const & v);

  template <typename A, typename B>
  explicit tvec4(tvec2<A> const & v1, tvec2<B> const & v2);

  template <typename U>
  explicit tvec4(tvec4<U> const & v);

        template <int E0, int E1, int E2, int E3>
        tvec4(glm::detail::swizzle<4, T, tvec4<T>, E0, E1, E2, E3> const & that)
        {
            *this = that();
        }

        template <int E0, int E1, int F0, int F1>
        tvec4(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, glm::detail::swizzle<2, T, tvec2<T>, F0, F1, -1, -2> const & u)
        {
            *this = tvec4<T>(v(), u());
        }

        template <int E0, int E1>
        tvec4(T const & x, T const & y, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v)
        {
            *this = tvec4<T>(x, y, v());
        }

        template <int E0, int E1>
        tvec4(T const & x, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & w)
        {
            *this = tvec4<T>(x, v(), w);
        }

        template <int E0, int E1>
        tvec4(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & z, T const & w)
        {
            *this = tvec4<T>(v(), z, w);
        }

        template <int E0, int E1, int E2>
        tvec4(glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & v, T const & w)
        {
            *this = tvec4<T>(v(), w);
        }

        template <int E0, int E1, int E2>
        tvec4(T const & x, glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & v)
        {
            *this = tvec4<T>(x, v());
        }




  tvec4(tref4<T> const & r);


  template <typename A, typename B, typename C>
  explicit tvec4(tref2<A> const & v, B const & s1, C const & s2);

  template <typename A, typename B, typename C>
  explicit tvec4(A const & s1, tref2<B> const & v, C const & s2);

  template <typename A, typename B, typename C>
  explicit tvec4(A const & s1, B const & s2, tref2<C> const & v);

  template <typename A, typename B>
  explicit tvec4(tref3<A> const & v, B const & s);

  template <typename A, typename B>
  explicit tvec4(A const & s, tref3<B> const & v);

  template <typename A, typename B>
  explicit tvec4(tref2<A> const & v1, tref2<B> const & v2);

  template <typename A, typename B>
  explicit tvec4(tvec2<A> const & v1, tref2<B> const & v2);

  template <typename A, typename B>
  explicit tvec4(tref2<A> const & v1, tvec2<B> const & v2);




  tvec4<T> & operator= (tvec4<T> const & v);
  template <typename U>
  tvec4<T> & operator= (tvec4<U> const & v);

  template <typename U>
  tvec4<T> & operator+=(U const & s);
  template <typename U>
  tvec4<T> & operator+=(tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator-=(U const & s);
  template <typename U>
  tvec4<T> & operator-=(tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator*=(U const & s);
  template <typename U>
  tvec4<T> & operator*=(tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator/=(U const & s);
  template <typename U>
  tvec4<T> & operator/=(tvec4<U> const & v);
  tvec4<T> & operator++();
  tvec4<T> & operator--();




  template <typename U>
  tvec4<T> & operator%= (U const & s);
  template <typename U>
  tvec4<T> & operator%= (tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator&= (U const & s);
  template <typename U>
  tvec4<T> & operator&= (tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator|= (U const & s);
  template <typename U>
  tvec4<T> & operator|= (tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator^= (U const & s);
  template <typename U>
  tvec4<T> & operator^= (tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator<<=(U const & s);
  template <typename U>
  tvec4<T> & operator<<=(tvec4<U> const & v);
  template <typename U>
  tvec4<T> & operator>>=(U const & s);
  template <typename U>
  tvec4<T> & operator>>=(tvec4<U> const & v);




  value_type swizzle(comp X) const;
  tvec2<T> swizzle(comp X, comp Y) const;
  tvec3<T> swizzle(comp X, comp Y, comp Z) const;
  tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
  tref2<T> swizzle(comp X, comp Y);
  tref3<T> swizzle(comp X, comp Y, comp Z);
  tref4<T> swizzle(comp X, comp Y, comp Z, comp W);
 };

 template <typename T>
 struct tref4
 {
  tref4(T & x, T & y, T & z, T & w);
  tref4(tref4<T> const & r);
  explicit tref4(tvec4<T> const & v);

  tref4<T> & operator= (tref4<T> const & r);
  tref4<T> & operator= (tvec4<T> const & v);

  tvec4<T> operator() ();

  T & x;
  T & y;
  T & z;
  T & w;
 };

 template <typename T> struct is_vector<tvec4<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };
}
# 336 "/usr/include/sgct/glm/./core/type_vec4.hpp" 3 4
 typedef detail::tvec4<highp_float> highp_vec4;






 typedef detail::tvec4<mediump_float> mediump_vec4;






 typedef detail::tvec4<lowp_float> lowp_vec4;






 typedef detail::tvec4<highp_int> highp_ivec4;






 typedef detail::tvec4<mediump_int> mediump_ivec4;






 typedef detail::tvec4<lowp_int> lowp_ivec4;






 typedef detail::tvec4<highp_uint> highp_uvec4;






 typedef detail::tvec4<mediump_uint> mediump_uvec4;






 typedef detail::tvec4<lowp_uint> lowp_uvec4;


}


# 1 "/usr/include/sgct/glm/./core/type_vec4.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_vec4.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T>
 inline typename tvec4<T>::size_type tvec4<T>::length() const
 {
  return 4;
 }




 template <typename T>
 inline typename tvec4<T>::value_type &
 tvec4<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec4.inl", 48, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T>
 inline typename tvec4<T>::value_type const &
 tvec4<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_vec4.inl", 59, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T>
 inline tvec4<T>::tvec4() :
  x(value_type(0)),
  y(value_type(0)),
  z(value_type(0)),
  w(value_type(0))
 {}

 template <typename T>
 inline tvec4<T>::tvec4
 (
  ctor
 )
 {}

 template <typename T>
 inline tvec4<T>::tvec4
 (
  type const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z),
  w(v.w)
 {}




 template <typename T>
 inline tvec4<T>::tvec4
 (
  value_type const & s
 ) :
  x(s),
  y(s),
  z(s),
  w(s)
 {}

 template <typename T>
 inline tvec4<T>::tvec4
 (
  value_type const & s1,
  value_type const & s2,
  value_type const & s3,
  value_type const & s4
 ) :
  x(s1),
  y(s2),
  z(s3),
  w(s4)
 {}




 template <typename T>
 inline tvec4<T>::tvec4
 (
  tref4<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z),
  w(r.w)
 {}

 template <typename T>
 template <typename A, typename B, typename C>
 inline tvec4<T>::tvec4
 (
  tref2<A> const & v,
  B const & s1,
  C const & s2
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s1)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C>
 inline tvec4<T>::tvec4
 (
  A const & s1,
  tref2<B> const & v,
  C const & s2
 ) :
  x(value_type(s1)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C>
 inline tvec4<T>::tvec4
 (
  A const & s1,
  B const & s2,
  tref2<C> const & v
 ) :
  x(value_type(s1)),
  y(value_type(s2)),
  z(value_type(v.x)),
  w(value_type(v.y))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  tref3<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z)),
  w(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  A const & s,
  tref3<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(v.z))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  tref2<A> const & v1,
  tref2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  tvec2<A> const & v1,
  tref2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  tref2<A> const & v1,
  tvec2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}




 template <typename T>
 template <typename U>
 inline tvec4<T>::tvec4
 (
  U const & x
 ) :
  x(value_type(x)),
  y(value_type(x)),
  z(value_type(x)),
  w(value_type(x))
 {}

 template <typename T>
 template <typename A, typename B, typename C, typename D>
 inline tvec4<T>::tvec4
 (
  A const & x,
  B const & y,
  C const & z,
  D const & w
 ) :
  x(value_type(x)),
  y(value_type(y)),
  z(value_type(z)),
  w(value_type(w))
 {}




 template <typename T>
 template <typename A, typename B, typename C>
 inline tvec4<T>::tvec4
 (
  tvec2<A> const & v,
  B const & s1,
  C const & s2
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s1)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C>
 inline tvec4<T>::tvec4
 (
  A const & s1,
  tvec2<B> const & v,
  C const & s2
 ) :
  x(value_type(s1)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C>
 inline tvec4<T>::tvec4
 (
  A const & s1,
  B const & s2,
  tvec2<C> const & v
 ) :
  x(value_type(s1)),
  y(value_type(s2)),
  z(value_type(v.x)),
  w(value_type(v.y))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  tvec3<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z)),
  w(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  A const & s,
  tvec3<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(v.z))
 {}

 template <typename T>
 template <typename A, typename B>
 inline tvec4<T>::tvec4
 (
  tvec2<A> const & v1,
  tvec2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}

 template <typename T>
 template <typename U>
 inline tvec4<T>::tvec4
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z)),
  w(value_type(v.w))
 {}




 template <typename T>
 inline tvec4<T> & tvec4<T>::operator=
 (
  tvec4<T> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  this->w = v.w;
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator=
 (
  tvec4<U> const & v
 )
 {
  this->x = T(v.x);
  this->y = T(v.y);
  this->z = T(v.z);
  this->w = T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  this->y += T(s);
  this->z += T(s);
  this->w += T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator+=
 (
  tvec4<U> const & v
 )
 {
  this->x += T(v.x);
  this->y += T(v.y);
  this->z += T(v.z);
  this->w += T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  this->y -= T(s);
  this->z -= T(s);
  this->w -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator-=
 (
  tvec4<U> const & v
 )
 {
  this->x -= T(v.x);
  this->y -= T(v.y);
  this->z -= T(v.z);
  this->w -= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  this->y *= T(s);
  this->z *= T(s);
  this->w *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator*=
 (
  tvec4<U> const & v
 )
 {
  this->x *= T(v.x);
  this->y *= T(v.y);
  this->z *= T(v.z);
  this->w *= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  this->y /= T(s);
  this->z /= T(s);
  this->w /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator/=
 (
  tvec4<U> const & v
 )
 {
  this->x /= T(v.x);
  this->y /= T(v.y);
  this->z /= T(v.z);
  this->w /= T(v.w);
  return *this;
 }

 template <typename T>
 inline tvec4<T> & tvec4<T>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template <typename T>
 inline tvec4<T> & tvec4<T>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }




 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= T(s);
  this->y %= T(s);
  this->z %= T(s);
  this->w %= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator%=
 (
  tvec4<U> const & v
 )
 {
  this->x %= T(v.x);
  this->y %= T(v.y);
  this->z %= T(v.z);
  this->w %= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= T(s);
  this->y &= T(s);
  this->z &= T(s);
  this->w &= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator&=
 (
  tvec4<U> const & v
 )
 {
  this->x &= T(v.x);
  this->y &= T(v.y);
  this->z &= T(v.z);
  this->w &= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= T(s);
  this->y |= T(s);
  this->z |= T(s);
  this->w |= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator|=
 (
  tvec4<U> const & v
 )
 {
  this->x |= T(v.x);
  this->y |= T(v.y);
  this->z |= T(v.z);
  this->w |= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= T(s);
  this->y ^= T(s);
  this->z ^= T(s);
  this->w ^= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator^=
 (
  tvec4<U> const & v
 )
 {
  this->x ^= T(v.x);
  this->y ^= T(v.y);
  this->z ^= T(v.z);
  this->w ^= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= T(s);
  this->y <<= T(s);
  this->z <<= T(s);
  this->w <<= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator<<=
 (
  tvec4<U> const & v
 )
 {
  this->x <<= T(v.x);
  this->y <<= T(v.y);
  this->z <<= T(v.z);
  this->w <<= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  this->y >>= T(s);
  this->z >>= T(s);
  this->w >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U>
 inline tvec4<T> & tvec4<T>::operator>>=
 (
  tvec4<U> const & v
 )
 {
  this->x >>= T(v.x);
  this->y >>= T(v.y);
  this->z >>= T(v.z);
  this->w >>= T(v.w);
  return *this;
 }




 template <typename T>
 inline typename tvec4<T>::value_type
 tvec4<T>::swizzle
 (
  comp x
 ) const
 {
  return (*this)[x];
 }

 template <typename T>
 inline tvec2<T> tvec4<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T>
 inline tvec3<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T>
 inline tvec4<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T>
 inline tref2<T> tvec4<T>::swizzle
 (
  comp x,
  comp y
 )
 {
  return tref2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T>
 inline tref3<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 )
 {
  return tref3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T>
 inline tref4<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 )
 {
  return tref4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }




 template <typename T>
 inline tvec4<T> operator+
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x + s,
   v.y + s,
   v.z + s,
   v.w + s);
 }

 template <typename T>
 inline tvec4<T> operator+
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s + v.x,
   s + v.y,
   s + v.z,
   s + v.w);
 }

 template <typename T>
 inline tvec4<T> operator+
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z,
   v1.w + v2.w);
 }


 template <typename T>
 inline tvec4<T> operator-
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x - s,
   v.y - s,
   v.z - s,
   v.w - s);
 }

 template <typename T>
 inline tvec4<T> operator-
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s - v.x,
   s - v.y,
   s - v.z,
   s - v.w);
 }

 template <typename T>
 inline tvec4<T> operator-
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z,
   v1.w - v2.w);
 }


 template <typename T>
 inline tvec4<T> operator*
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x * s,
   v.y * s,
   v.z * s,
   v.w * s);
 }

 template <typename T>
 inline tvec4<T> operator*
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s * v.x,
   s * v.y,
   s * v.z,
   s * v.w);
 }

 template <typename T>
 inline tvec4<T> operator*
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z,
   v1.w * v2.w);
 }


 template <typename T>
 inline tvec4<T> operator/
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x / s,
   v.y / s,
   v.z / s,
   v.w / s);
 }

 template <typename T>
 inline tvec4<T> operator/
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s / v.x,
   s / v.y,
   s / v.z,
   s / v.w);
 }

 template <typename T>
 inline tvec4<T> operator/
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z,
   v1.w / v2.w);
 }


 template <typename T>
 inline tvec4<T> operator-
 (
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   -v.x,
   -v.y,
   -v.z,
   -v.w);
 }

 template <typename T>
 inline tvec4<T> operator++
 (
  tvec4<T> const & v,
  int
 )
 {
  typename tvec4<T>::value_type One(1);
  return tvec4<T>(
   v.x + One,
   v.y + One,
   v.z + One,
   v.w + One);
 }

 template <typename T>
 inline tvec4<T> operator--
 (
  tvec4<T> const & v,
  int
 )
 {
  typename tvec4<T>::value_type One(1);
  return tvec4<T>(
   v.x - One,
   v.y - One,
   v.z - One,
   v.w - One);
 }




 template <typename T>
 inline bool operator==
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
 }

 template <typename T>
 inline bool operator!=
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
 }




 template <typename T>
 inline tvec4<T> operator%
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x % s,
   v.y % s,
   v.z % s,
   v.w % s);
 }

 template <typename T>
 inline tvec4<T> operator%
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s % v.x,
   s % v.y,
   s % v.z,
   s % v.w);
 }

 template <typename T>
 inline tvec4<T> operator%
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z,
   v1.w % v2.w);
 }

 template <typename T>
 inline tvec4<T> operator&
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x & s,
   v.y & s,
   v.z & s,
   v.w & s);
 }

 template <typename T>
 inline tvec4<T> operator&
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s & v.x,
   s & v.y,
   s & v.z,
   s & v.w);
 }

 template <typename T>
 inline tvec4<T> operator&
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z,
   v1.w & v2.w);
 }

 template <typename T>
 inline tvec4<T> operator|
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x | s,
   v.y | s,
   v.z | s,
   v.w | s);
 }

 template <typename T>
 inline tvec4<T> operator|
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s | v.x,
   s | v.y,
   s | v.z,
   s | v.w);
 }

 template <typename T>
 inline tvec4<T> operator|
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z,
   v1.w | v2.w);
 }

 template <typename T>
 inline tvec4<T> operator^
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x ^ s,
   v.y ^ s,
   v.z ^ s,
   v.w ^ s);
 }

 template <typename T>
 inline tvec4<T> operator^
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s ^ v.x,
   s ^ v.y,
   s ^ v.z,
   s ^ v.w);
 }

 template <typename T>
 inline tvec4<T> operator^
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z,
   v1.w ^ v2.w);
 }

 template <typename T>
 inline tvec4<T> operator<<
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x << s,
   v.y << s,
   v.z << s,
   v.w << s);
 }

 template <typename T>
 inline tvec4<T> operator<<
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s << v.x,
   s << v.y,
   s << v.z,
   s << v.w);
 }

 template <typename T>
 inline tvec4<T> operator<<
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z,
   v1.w << v2.w);
 }

 template <typename T>
 inline tvec4<T> operator>>
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x >> s,
   v.y >> s,
   v.z >> s,
   v.w >> s);
 }

 template <typename T>
 inline tvec4<T> operator>>
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s >> v.x,
   s >> v.y,
   s >> v.z,
   s >> v.w);
 }

 template <typename T>
 inline tvec4<T> operator>>
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z,
   v1.w >> v2.w);
 }

 template <typename T>
 inline tvec4<T> operator~
 (
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   ~v.x,
   ~v.y,
   ~v.z,
   ~v.w);
 }




 template <typename T>
 tref4<T>::tref4
 (
  T & x,
  T & y,
  T & z,
  T & w
 ) :
  x(x),
  y(y),
  z(z),
  w(w)
 {}

 template <typename T>
 tref4<T>::tref4
 (
  tref4<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z),
  w(r.w)
 {}

 template <typename T>
 tref4<T>::tref4
 (
  tvec4<T> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z),
  w(v.w)
 {}

 template <typename T>
 tref4<T>& tref4<T>::operator=
 (
  tref4<T> const & r
 )
 {
  x = r.x;
  y = r.y;
  z = r.z;
  w = r.w;
  return *this;
 }

 template <typename T>
 tref4<T>& tref4<T>::operator=
 (
  tvec4<T> const & v
 )
 {
  x = v.x;
  y = v.y;
  z = v.z;
  w = v.w;
  return *this;
 }

 template <typename T>
 inline tvec4<T> tref4<T>::operator() ()
 {
  return tvec4<T>(this->x, this->y, this->z, this->w);
 }

}
}
# 399 "/usr/include/sgct/glm/./core/type_vec4.hpp" 2 3 4
# 42 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4

# 1 "/usr/include/sgct/glm/./core/type_mat2x2.hpp" 1 3 4
# 32 "/usr/include/sgct/glm/./core/type_mat2x2.hpp" 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat.hpp" 3 4
namespace glm{
namespace detail
{
# 72 "/usr/include/sgct/glm/./core/type_mat.hpp" 3 4
}
}
# 33 "/usr/include/sgct/glm/./core/type_mat2x2.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat2x2
 {

  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T> col_type;
  typedef tvec2<T> row_type;
  static size_type col_size();
  static size_type row_size();

  typedef tmat2x2<T> type;
  typedef tmat2x2<T> transpose_type;

  size_type length() const;

 public:

  tmat2x2<T> _inverse() const;

 private:


  col_type value[2];

 public:


  tmat2x2();
  tmat2x2(
   tmat2x2 const & m);

  explicit tmat2x2(
   ctor Null);
  explicit tmat2x2(
   value_type const & x);
  explicit tmat2x2(
   value_type const & x1, value_type const & y1,
   value_type const & x2, value_type const & y2);
  explicit tmat2x2(
   col_type const & v1,
   col_type const & v2);



  template <typename U>
  explicit tmat2x2(
   U const & x);

  template <typename U, typename V, typename M, typename N>
  explicit tmat2x2(
   U const & x1, V const & y1,
   M const & x2, N const & y2);

  template <typename U, typename V>
  explicit tmat2x2(
   tvec2<U> const & v1,
   tvec2<V> const & v2);



  template <typename U>
  explicit tmat2x2(tmat2x2<U> const & m);

  explicit tmat2x2(tmat3x3<T> const & x);
  explicit tmat2x2(tmat4x4<T> const & x);
  explicit tmat2x2(tmat2x3<T> const & x);
  explicit tmat2x2(tmat3x2<T> const & x);
  explicit tmat2x2(tmat2x4<T> const & x);
  explicit tmat2x2(tmat4x2<T> const & x);
  explicit tmat2x2(tmat3x4<T> const & x);
  explicit tmat2x2(tmat4x3<T> const & x);




  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat2x2<T> & operator=(tmat2x2<T> const & m);
  template <typename U>
  tmat2x2<T> & operator=(tmat2x2<U> const & m);
  template <typename U>
  tmat2x2<T> & operator+=(U const & s);
  template <typename U>
  tmat2x2<T> & operator+=(tmat2x2<U> const & m);
  template <typename U>
  tmat2x2<T> & operator-=(U const & s);
  template <typename U>
  tmat2x2<T> & operator-=(tmat2x2<U> const & m);
  template <typename U>
  tmat2x2<T> & operator*=(U const & s);
  template <typename U>
  tmat2x2<T> & operator*=(tmat2x2<U> const & m);
  template <typename U>
  tmat2x2<T> & operator/=(U const & s);
  template <typename U>
  tmat2x2<T> & operator/=(tmat2x2<U> const & m);
  tmat2x2<T> & operator++();
  tmat2x2<T> & operator--();
 };


 template <typename T>
 tmat2x2<T> operator+ (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator+ (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator+ (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat2x2<T> operator- (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator- (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator- (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat2x2<T> operator* (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator* (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 typename tmat2x2<T>::col_type operator* (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type const & v);

 template <typename T>
 typename tmat2x2<T>::row_type operator* (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator* (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat3x2<T> operator* (
  tmat2x2<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat2x2<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat2x2<T> operator/ (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator/ (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 typename tmat2x2<T>::col_type operator/ (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type const & v);

 template <typename T>
 typename tmat2x2<T>::row_type operator/ (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator/ (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);


 template <typename T>
 tmat2x2<T> const operator- (
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> const operator-- (
  tmat2x2<T> const & m,
  int);

 template <typename T>
 tmat2x2<T> const operator++ (
  tmat2x2<T> const & m,
  int);
}
# 272 "/usr/include/sgct/glm/./core/type_mat2x2.hpp" 3 4
 typedef detail::tmat2x2<lowp_float> lowp_mat2;






 typedef detail::tmat2x2<mediump_float> mediump_mat2;






 typedef detail::tmat2x2<highp_float> highp_mat2;






 typedef detail::tmat2x2<lowp_float> lowp_mat2x2;






 typedef detail::tmat2x2<mediump_float> mediump_mat2x2;






 typedef detail::tmat2x2<highp_float> highp_mat2x2;


}


# 1 "/usr/include/sgct/glm/./core/type_mat2x2.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat2x2.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat2x2<T>::size_type tmat2x2<T>::length() const
    {
        return 2;
    }

 template <typename T>
 inline typename tmat2x2<T>::size_type tmat2x2<T>::col_size()
 {
  return 2;
 }

 template <typename T>
 inline typename tmat2x2<T>::size_type tmat2x2<T>::row_size()
 {
  return 2;
 }




 template <typename T>
 inline typename tmat2x2<T>::col_type &
 tmat2x2<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat2x2.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat2x2<T>::col_type const &
 tmat2x2<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat2x2.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat2x2<T>::tmat2x2()
    {
  this->value[0] = col_type(1, 0);
        this->value[1] = col_type(0, 1);
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  ctor
 )
    {}

    template <typename T>
 inline tmat2x2<T>::tmat2x2
 (
  value_type const & s
 )
    {
  value_type const Zero(0);
        this->value[0] = col_type(s, Zero);
        this->value[1] = col_type(Zero, s);
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  value_type const & x0, value_type const & y0,
  value_type const & x1, value_type const & y1
 )
    {
        this->value[0] = col_type(x0, y0);
        this->value[1] = col_type(x1, y1);
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  col_type const & v0,
  col_type const & v1
 )
    {
        this->value[0] = v0;
        this->value[1] = v1;
    }



 template <typename T>
 template <typename U>
 tmat2x2<T>::tmat2x2
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec2<T>(value_type(s), Zero);
        this->value[1] = tvec2<T>(Zero, value_type(s));
 }

 template <typename T>
 template <typename X1, typename Y1, typename X2, typename Y2>
 tmat2x2<T>::tmat2x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1));
        this->value[1] = col_type(value_type(x2), value_type(y2));
 }

 template <typename T>
 template <typename V1, typename V2>
 tmat2x2<T>::tmat2x2
 (
  tvec2<V1> const & v1,
  tvec2<V2> const & v2
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
 }




    template <typename T>
    template <typename U>
    inline tmat2x2<T>::tmat2x2
 (
  tmat2x2<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
 }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

 template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x2<T>::tmat2x2
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x2<T> tmat2x2<T>::_inverse() const
    {
        typename tmat2x2<T>::value_type Determinant = this->value[0][0] * this->value[1][1] - this->value[1][0] * this->value[0][1];

        tmat2x2<T> Inverse(
            + this->value[1][1] / Determinant,
            - this->value[1][0] / Determinant,
            - this->value[0][1] / Determinant,
            + this->value[0][0] / Determinant);
        return Inverse;
    }





    template <typename T>
    inline tmat2x2<T>& tmat2x2<T>::operator=
 (
  tmat2x2<T> const & m
 )
    {
     this->value[0] = m[0];
     this->value[1] = m[1];
     return *this;
    }

 template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator=
 (
  tmat2x2<U> const & m
 )
    {
     this->value[0] = m[0];
     this->value[1] = m[1];
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator+=
 (
  U const & s
 )
    {
     this->value[0] += s;
     this->value[1] += s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator+=
 (
  tmat2x2<U> const & m
 )
    {
     this->value[0] += m[0];
     this->value[1] += m[1];
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator-=
 (
  U const & s
 )
    {
     this->value[0] -= s;
     this->value[1] -= s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator-=
 (
  tmat2x2<U> const & m
 )
    {
     this->value[0] -= m[0];
     this->value[1] -= m[1];
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator*=
 (
  U const & s
 )
    {
     this->value[0] *= s;
     this->value[1] *= s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator*=
 (
  tmat2x2<U> const & m
 )
    {
        return (*this = *this * m);
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator/=
 (
  U const & s
 )
    {
     this->value[0] /= s;
     this->value[1] /= s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x2<T>& tmat2x2<T>::operator/=
 (
  tmat2x2<U> const & m
 )
    {
        return (*this = *this / m);
    }

    template <typename T>
    inline tmat2x2<T>& tmat2x2<T>::operator++ ()
    {
     ++this->value[0];
     ++this->value[1];
     return *this;
    }

    template <typename T>
    inline tmat2x2<T>& tmat2x2<T>::operator-- ()
    {
     --this->value[0];
     --this->value[1];
     return *this;
    }




    template <typename T>
    inline tmat2x2<T> operator+
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
    {
        return tmat2x2<T>(
            m[0] + s,
            m[1] + s);
    }

    template <typename T>
    inline tmat2x2<T> operator+
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
    {
        return tmat2x2<T>(
            m[0] + s,
            m[1] + s);
    }

    template <typename T>
    inline tmat2x2<T> operator+
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
    {
        return tmat2x2<T>(
            m1[0] + m2[0],
            m1[1] + m2[1]);
    }

    template <typename T>
    inline tmat2x2<T> operator-
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
    {
        return tmat2x2<T>(
            m[0] - s,
            m[1] - s);
    }

    template <typename T>
    inline tmat2x2<T> operator-
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
    {
        return tmat2x2<T>(
            s - m[0],
            s - m[1]);
    }

    template <typename T>
    inline tmat2x2<T> operator-
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
    {
        return tmat2x2<T>(
            m1[0] - m2[0],
            m1[1] - m2[1]);
    }

    template <typename T>
    inline tmat2x2<T> operator*
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
    {
        return tmat2x2<T>(
            m[0] * s,
            m[1] * s);
    }





    template <typename T>
    inline tmat2x2<T> operator*
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
    {
        return tmat2x2<T>(
            m[0] * s,
            m[1] * s);
    }

    template <typename T>
    inline typename tmat2x2<T>::col_type operator*
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type const & v
 )
    {
        return detail::tvec2<T>(
            m[0][0] * v.x + m[1][0] * v.y,
            m[0][1] * v.x + m[1][1] * v.y);
    }




    template <typename T>
    inline typename tmat2x2<T>::row_type operator*
 (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m
 )
    {
        return detail::tvec2<T>(
            v.x * m[0][0] + v.y * m[0][1],
            v.x * m[1][0] + v.y * m[1][1]);
    }

 template <typename T>
 inline tmat2x2<T> operator*
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template <typename T>
 inline tmat3x2<T> operator*
 (
  tmat2x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template <typename T>
 inline tmat4x2<T> operator*
 (
  tmat2x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

    template <typename T>
    inline tmat2x2<T> operator/
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
    {
        return tmat2x2<T>(
            m[0] / s,
            m[1] / s);
    }

    template <typename T>
    inline tmat2x2<T> operator/
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
    {
        return tmat2x2<T>(
            s / m[0],
            s / m[1]);
    }

    template <typename T>
    inline typename tmat2x2<T>::col_type operator/
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type & v
 )
    {
        return m._inverse() * v;
    }

    template <typename T>
    inline typename tmat2x2<T>::row_type operator/
 (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m
 )
    {
        return v * m._inverse();
    }

    template <typename T>
    inline tmat2x2<T> operator/
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
    {
        return m1 * m2._inverse();
    }


    template <typename T>
    inline tmat2x2<T> const operator-
 (
  tmat2x2<T> const & m
 )
    {
        return tmat2x2<T>(
            -m[0],
            -m[1]);
    }

    template <typename T>
    inline tmat2x2<T> const operator++
 (
  tmat2x2<T> const & m,
  int
 )
    {
        return tmat2x2<T>(
            m[0] + T(1),
            m[1] + T(1));
    }

    template <typename T>
    inline tmat2x2<T> const operator--
 (
  tmat2x2<T> const & m,
  int
 )
    {
        return tmat2x2<T>(
            m[0] - T(1),
            m[1] - T(1));
    }




 template <typename T>
 inline bool operator==
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }

}
}
# 314 "/usr/include/sgct/glm/./core/type_mat2x2.hpp" 2 3 4
# 44 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat2x3.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat2x3.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat2x3
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T> col_type;
  typedef tvec2<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat2x3<T> type;
  typedef tmat3x2<T> transpose_type;

 private:

  col_type value[2];

 public:

  tmat2x3();
  tmat2x3(tmat2x3 const & m);

  explicit tmat2x3(
   ctor);
  explicit tmat2x3(
   value_type const & s);
  explicit tmat2x3(
   value_type const & x0, value_type const & y0, value_type const & z0,
   value_type const & x1, value_type const & y1, value_type const & z1);
  explicit tmat2x3(
   col_type const & v0,
   col_type const & v1);



  template <typename U>
  explicit tmat2x3(
            U const & x);

  template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
  explicit tmat2x3(
            X1 const & x1, Y1 const & y1, Z1 const & z1,
            X2 const & x2, Y2 const & y2, Z2 const & z2);

  template <typename U, typename V>
  explicit tmat2x3(
            tvec3<U> const & v1,
            tvec3<V> const & v2);



  template <typename U>
  explicit tmat2x3(tmat2x3<U> const & m);

  explicit tmat2x3(tmat2x2<T> const & x);
  explicit tmat2x3(tmat3x3<T> const & x);
  explicit tmat2x3(tmat4x4<T> const & x);
  explicit tmat2x3(tmat2x4<T> const & x);
  explicit tmat2x3(tmat3x2<T> const & x);
  explicit tmat2x3(tmat3x4<T> const & x);
  explicit tmat2x3(tmat4x2<T> const & x);
  explicit tmat2x3(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat2x3<T> & operator= (tmat2x3<T> const & m);
  template <typename U>
  tmat2x3<T> & operator= (tmat2x3<U> const & m);
  template <typename U>
  tmat2x3<T> & operator+= (U const & s);
  template <typename U>
  tmat2x3<T> & operator+= (tmat2x3<U> const & m);
  template <typename U>
  tmat2x3<T> & operator-= (U const & s);
  template <typename U>
  tmat2x3<T> & operator-= (tmat2x3<U> const & m);
  template <typename U>
  tmat2x3<T> & operator*= (U const & s);
  template <typename U>
  tmat2x3<T> & operator*= (tmat2x3<U> const & m);
  template <typename U>
  tmat2x3<T> & operator/= (U const & s);

  tmat2x3<T> & operator++ ();
  tmat2x3<T> & operator-- ();
 };


 template <typename T>
 tmat2x3<T> operator+ (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator+ (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat2x3<T> operator- (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator- (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat2x3<T> operator* (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator* (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m);

 template <typename T>
 typename tmat2x3<T>::col_type operator* (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::row_type const & v);

 template <typename T>
 typename tmat2x3<T>::row_type operator* (
  typename tmat2x3<T>::col_type const & v,
  tmat2x3<T> const & m);

 template <typename T>
 tmat2x3<T> operator* (
  tmat2x3<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat3x3<T> operator* (
  tmat2x3<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat2x3<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat2x3<T> operator/ (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator/ (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m);


 template <typename T>
 tmat2x3<T> const operator- (
  tmat2x3<T> const & m);

 template <typename T>
 tmat2x3<T> const operator-- (
  tmat2x3<T> const & m,
  int);

 template <typename T>
 tmat2x3<T> const operator++ (
  tmat2x3<T> const & m,
  int);

}
# 236 "/usr/include/sgct/glm/./core/type_mat2x3.hpp" 3 4
 typedef detail::tmat2x3<lowp_float> lowp_mat2x3;






 typedef detail::tmat2x3<mediump_float> mediump_mat2x3;






 typedef detail::tmat2x3<highp_float> highp_mat2x3;


}


# 1 "/usr/include/sgct/glm/./core/type_mat2x3.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat2x3.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat2x3<T>::size_type tmat2x3<T>::length() const
    {
        return 2;
    }

 template <typename T>
 inline typename tmat2x3<T>::size_type tmat2x3<T>::col_size()
 {
  return 3;
 }

 template <typename T>
 inline typename tmat2x3<T>::size_type tmat2x3<T>::row_size()
 {
  return 2;
 }




 template <typename T>
 inline typename tmat2x3<T>::col_type &
 tmat2x3<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat2x3.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat2x3<T>::col_type const &
 tmat2x3<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat2x3.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat2x3<T>::tmat2x3()
    {
        this->value[0] = col_type(T(1), T(0), T(0));
        this->value[1] = col_type(T(0), T(1), T(0));
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  value_type const & s
 )
    {
        this->value[0] = col_type(s, T(0), T(0));
        this->value[1] = col_type(T(0), s, T(0));
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
    (
        value_type const & x0, value_type const & y0, value_type const & z0,
        value_type const & x1, value_type const & y1, value_type const & z1
    )
    {
        this->value[0] = col_type(x0, y0, z0);
        this->value[1] = col_type(x1, y1, z1);
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
    (
        col_type const & v0,
        col_type const & v1
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
    }



 template <typename T>
 template <typename U>
 tmat2x3<T>::tmat2x3
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
        this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 tmat2x3<T>::tmat2x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
        this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
 }

 template <typename T>
 template <typename V1, typename V2>
 tmat2x3<T>::tmat2x3
 (
  tvec3<V1> const & v1,
  tvec3<V2> const & v2
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
 }




    template <typename T>
    template <typename U>
    inline tmat2x3<T>::tmat2x3
 (
  tmat2x3<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
 }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
    }

    template <typename T>
    inline tmat2x3<T>::tmat2x3
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
    }




    template <typename T>
    inline tmat2x3<T>& tmat2x3<T>::operator=
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T>& tmat2x3<T>::operator=
 (
  tmat2x3<U> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T> & tmat2x3<T>::operator+=
 (
  U const & s
 )
    {
        this->value[0] += s;
        this->value[1] += s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T>& tmat2x3<T>::operator+=
 (
  tmat2x3<U> const & m
 )
    {
        this->value[0] += m[0];
        this->value[1] += m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T>& tmat2x3<T>::operator-=
 (
  U const & s
 )
    {
        this->value[0] -= s;
        this->value[1] -= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T>& tmat2x3<T>::operator-=
 (
  tmat2x3<U> const & m
 )
    {
        this->value[0] -= m[0];
        this->value[1] -= m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T>& tmat2x3<T>::operator*=
 (
  U const & s
 )
    {
        this->value[0] *= s;
        this->value[1] *= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T> & tmat2x3<T>::operator*=
 (
  tmat2x3<U> const & m
 )
    {
        return (*this = tmat2x3<U>(*this * m));
    }

    template <typename T>
 template <typename U>
    inline tmat2x3<T> & tmat2x3<T>::operator/=
 (
  U const & s
 )
    {
        this->value[0] /= s;
        this->value[1] /= s;
        return *this;
    }

    template <typename T>
    inline tmat2x3<T> & tmat2x3<T>::operator++ ()
    {
        ++this->value[0];
        ++this->value[1];
        return *this;
    }

    template <typename T>
    inline tmat2x3<T> & tmat2x3<T>::operator-- ()
    {
        --this->value[0];
        --this->value[1];
        return *this;
    }




    template <typename T>
    inline tmat2x3<T> operator+
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
    {
        return tmat2x3<T>(
            m[0] + s,
            m[1] + s);
    }

    template <typename T>
    inline tmat2x3<T> operator+
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
    {
        return tmat2x3<T>(
            m1[0] + m2[0],
            m1[1] + m2[1]);
    }

    template <typename T>
    inline tmat2x3<T> operator-
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
    {
        return tmat2x3<T>(
            m[0] - s,
            m[1] - s);
    }

    template <typename T>
    inline tmat2x3<T> operator-
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
    {
        return tmat2x3<T>(
            m1[0] - m2[0],
            m1[1] - m2[1]);
    }

    template <typename T>
    inline tmat2x3<T> operator*
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
    {
        return tmat2x3<T>(
            m[0] * s,
            m[1] * s);
    }

    template <typename T>
    inline tmat2x3<T> operator*
 (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m
 )
    {
        return tmat2x3<T>(
            m[0] * s,
            m[1] * s);
    }

    template <typename T>
    inline typename tmat2x3<T>::col_type operator*
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::row_type const & v)
    {
        return typename tmat2x3<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y,
            m[0][1] * v.x + m[1][1] * v.y,
            m[0][2] * v.x + m[1][2] * v.y);
    }

    template <typename T>
    inline typename tmat2x3<T>::row_type operator*
 (
  typename tmat2x3<T>::col_type const & v,
  tmat2x3<T> const & m)
    {
        return typename tmat2x3<T>::row_type(
            v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
            v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
    }

 template <typename T>
 inline tmat2x3<T> operator*
 (
  tmat2x3<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

    template <typename T>
    inline tmat3x3<T> operator*
 (
  tmat2x3<T> const & m1,
  tmat3x2<T> const & m2
 )
    {
  typename tmat2x3<T>::value_type SrcA00 = m1[0][0];
  typename tmat2x3<T>::value_type SrcA01 = m1[0][1];
  typename tmat2x3<T>::value_type SrcA02 = m1[0][2];
  typename tmat2x3<T>::value_type SrcA10 = m1[1][0];
  typename tmat2x3<T>::value_type SrcA11 = m1[1][1];
  typename tmat2x3<T>::value_type SrcA12 = m1[1][2];

  typename tmat2x3<T>::value_type SrcB00 = m2[0][0];
  typename tmat2x3<T>::value_type SrcB01 = m2[0][1];
  typename tmat2x3<T>::value_type SrcB10 = m2[1][0];
  typename tmat2x3<T>::value_type SrcB11 = m2[1][1];
  typename tmat2x3<T>::value_type SrcB20 = m2[2][0];
  typename tmat2x3<T>::value_type SrcB21 = m2[2][1];

  tmat3x3<T> Result(tmat3x3<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
    }

 template <typename T>
 inline tmat4x3<T> operator*
 (
  tmat2x3<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return tmat4x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

    template <typename T>
    inline tmat2x3<T> operator/
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
    {
        return tmat2x3<T>(
            m[0] / s,
            m[1] / s);
    }

    template <typename T>
    inline tmat2x3<T> operator/
 (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m
 )
    {
        return tmat2x3<T>(
            s / m[0],
            s / m[1]);
    }


    template <typename T>
    inline tmat2x3<T> const operator-
 (
  tmat2x3<T> const & m
 )
    {
        return tmat2x3<T>(
            -m[0],
            -m[1]);
    }

    template <typename T>
    inline tmat2x3<T> const operator++
 (
  tmat2x3<T> const & m,
  int
 )
    {
        return tmat2x3<T>(
            m[0] + typename tmat2x3<T>::value_type(1),
            m[1] + typename tmat2x3<T>::value_type(1));
    }

    template <typename T>
    inline tmat2x3<T> const operator--
 (
  tmat2x3<T> const & m,
  int
 )
    {
        return tmat2x3<T>(
            m[0] - typename tmat2x3<T>::value_type(1),
            m[1] - typename tmat2x3<T>::value_type(1));
    }




 template <typename T>
 inline bool operator==
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }

}
}
# 257 "/usr/include/sgct/glm/./core/type_mat2x3.hpp" 2 3 4
# 45 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat2x4.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat2x4.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat2x4
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T> col_type;
  typedef tvec2<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat2x4<T> type;
  typedef tmat4x2<T> transpose_type;

 private:

  col_type value[2];

 public:

  tmat2x4();
  tmat2x4(tmat2x4 const & m);

  explicit tmat2x4(
   ctor);
  explicit tmat2x4(
   value_type const & s);
  explicit tmat2x4(
   value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
   value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1);
  explicit tmat2x4(
   col_type const & v0,
   col_type const & v1);



  template <typename U>
  explicit tmat2x4(
            U const & x);

  template <
            typename X1, typename Y1, typename Z1, typename W1,
            typename X2, typename Y2, typename Z2, typename W2>
  explicit tmat2x4(
            X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
            X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2);

  template <typename U, typename V>
  explicit tmat2x4(
            tvec4<U> const & v1,
            tvec4<V> const & v2);



  template <typename U>
  explicit tmat2x4(tmat2x4<U> const & m);

  explicit tmat2x4(tmat2x2<T> const & x);
  explicit tmat2x4(tmat3x3<T> const & x);
  explicit tmat2x4(tmat4x4<T> const & x);
  explicit tmat2x4(tmat2x3<T> const & x);
  explicit tmat2x4(tmat3x2<T> const & x);
  explicit tmat2x4(tmat3x4<T> const & x);
  explicit tmat2x4(tmat4x2<T> const & x);
  explicit tmat2x4(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat2x4<T>& operator= (tmat2x4<T> const & m);
  template <typename U>
  tmat2x4<T>& operator= (tmat2x4<U> const & m);
  template <typename U>
  tmat2x4<T>& operator+= (U const & s);
  template <typename U>
  tmat2x4<T>& operator+= (tmat2x4<U> const & m);
  template <typename U>
  tmat2x4<T>& operator-= (U const & s);
  template <typename U>
  tmat2x4<T>& operator-= (tmat2x4<U> const & m);
  template <typename U>
  tmat2x4<T>& operator*= (U const & s);
  template <typename U>
  tmat2x4<T>& operator*= (tmat2x4<U> const & m);
  template <typename U>
  tmat2x4<T>& operator/= (U const & s);

  tmat2x4<T>& operator++ ();
  tmat2x4<T>& operator-- ();
 };


 template <typename T>
 tmat2x4<T> operator+ (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator+ (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat2x4<T> operator- (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator- (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat2x4<T> operator* (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator* (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m);

 template <typename T>
 typename tmat2x4<T>::col_type operator* (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::row_type const & v);

 template <typename T>
 typename tmat2x4<T>::row_type operator* (
  typename tmat2x4<T>::col_type const & v,
  tmat2x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator* (
  tmat2x4<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat2x4<T> operator* (
  tmat2x4<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat2x4<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat2x4<T> operator/ (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator/ (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m);


 template <typename T>
 tmat2x4<T> const operator- (
  tmat2x4<T> const & m);

 template <typename T>
 tmat2x4<T> const operator-- (
  tmat2x4<T> const & m,
  int);

 template <typename T>
 tmat2x4<T> const operator++ (
  tmat2x4<T> const & m,
  int);

}
# 238 "/usr/include/sgct/glm/./core/type_mat2x4.hpp" 3 4
 typedef detail::tmat2x4<lowp_float> lowp_mat2x4;






 typedef detail::tmat2x4<mediump_float> mediump_mat2x4;






 typedef detail::tmat2x4<highp_float> highp_mat2x4;


}


# 1 "/usr/include/sgct/glm/./core/type_mat2x4.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat2x4.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat2x4<T>::size_type tmat2x4<T>::length() const
    {
        return 2;
    }

 template <typename T>
 inline typename tmat2x4<T>::size_type tmat2x4<T>::col_size()
 {
  return 4;
 }

 template <typename T>
 inline typename tmat2x4<T>::size_type tmat2x4<T>::row_size()
 {
  return 2;
 }




 template <typename T>
 inline typename tmat2x4<T>::col_type &
 tmat2x4<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat2x4.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat2x4<T>::col_type const &
 tmat2x4<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat2x4.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat2x4<T>::tmat2x4()
    {
  value_type const Zero(0);
  value_type const One(1);
        this->value[0] = col_type(One, Zero, Zero, Zero);
        this->value[1] = col_type(Zero, One, Zero, Zero);
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  value_type const & s
 )
    {
  value_type const Zero(0);
        this->value[0] = col_type(s, Zero, Zero, Zero);
        this->value[1] = col_type(Zero, Zero, Zero, Zero);
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
    (
        value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
        value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1
    )
    {
        this->value[0] = col_type(x0, y0, z0, w0);
        this->value[1] = col_type(x1, y1, z1, w1);
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
    (
        col_type const & v0,
        col_type const & v1
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
    }



 template <typename T>
 template <typename U>
 tmat2x4<T>::tmat2x4
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
        this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 tmat2x4<T>::tmat2x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
        this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
 }

 template <typename T>
 template <typename V1, typename V2>
 tmat2x4<T>::tmat2x4
 (
  tvec4<V1> const & v1,
  tvec4<V2> const & v2
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
 }




    template <typename T>
    template <typename U>
    inline tmat2x4<T>::tmat2x4
 (
  tmat2x4<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
 }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(0));
        this->value[1] = col_type(m[1], detail::tvec2<T>(0));
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(0));
        this->value[1] = col_type(m[1], detail::tvec2<T>(0));
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(T(0)));
        this->value[1] = col_type(m[1], detail::tvec2<T>(T(0)));
    }

    template <typename T>
    inline tmat2x4<T>::tmat2x4
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
    }




    template <typename T>
    inline tmat2x4<T>& tmat2x4<T>::operator=
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T>& tmat2x4<T>::operator=
 (
  tmat2x4<U> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T>& tmat2x4<T>::operator+=
 (
  U const & s
 )
    {
        this->value[0] += s;
        this->value[1] += s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T>& tmat2x4<T>::operator+=
 (
  tmat2x4<U> const & m
 )
    {
        this->value[0] += m[0];
        this->value[1] += m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T>& tmat2x4<T>::operator-=
 (
  U const & s
 )
    {
        this->value[0] -= s;
        this->value[1] -= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T>& tmat2x4<T>::operator-=
 (
  tmat2x4<U> const & m
 )
    {
        this->value[0] -= m[0];
        this->value[1] -= m[1];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T>& tmat2x4<T>::operator*=
 (
  U const & s
 )
    {
        this->value[0] *= s;
        this->value[1] *= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T>& tmat2x4<T>::operator*=
 (
  tmat2x4<U> const & m
 )
    {
        return (*this = tmat2x4<T>(*this * m));
    }

    template <typename T>
 template <typename U>
    inline tmat2x4<T> & tmat2x4<T>::operator/=
 (
  U const & s
 )
    {
        this->value[0] /= s;
        this->value[1] /= s;
        return *this;
    }

    template <typename T>
    inline tmat2x4<T>& tmat2x4<T>::operator++ ()
    {
        ++this->value[0];
        ++this->value[1];
        return *this;
    }

    template <typename T>
    inline tmat2x4<T>& tmat2x4<T>::operator-- ()
    {
        --this->value[0];
        --this->value[1];
        return *this;
    }




    template <typename T>
    inline tmat2x4<T> operator+
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
    {
        return tmat2x4<T>(
            m[0] + s,
            m[1] + s);
    }

    template <typename T>
    inline tmat2x4<T> operator+
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
    {
        return tmat2x4<T>(
            m1[0] + m2[0],
            m1[1] + m2[1]);
    }

    template <typename T>
    inline tmat2x4<T> operator-
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
    {
        return tmat2x4<T>(
            m[0] - s,
            m[1] - s);
    }

    template <typename T>
    inline tmat2x4<T> operator-
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
    {
        return tmat2x4<T>(
            m1[0] - m2[0],
            m1[1] - m2[1]);
    }

    template <typename T>
    inline tmat2x4<T> operator*
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
    {
        return tmat2x4<T>(
            m[0] * s,
            m[1] * s);
    }

    template <typename T>
    inline tmat2x4<T> operator*
 (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m
 )
    {
        return tmat2x4<T>(
            m[0] * s,
            m[1] * s);
    }







    template <typename T>
    inline typename tmat2x4<T>::col_type operator*
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::row_type const & v
 )
    {
        return typename tmat2x4<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y,
            m[0][1] * v.x + m[1][1] * v.y,
            m[0][2] * v.x + m[1][2] * v.y,
            m[0][3] * v.x + m[1][3] * v.y);
    }






 template <typename T>
    inline typename tmat2x4<T>::row_type operator*
 (
  typename tmat2x4<T>::col_type const & v,
  tmat2x4<T> const & m
 )
    {
        return typename tmat2x4<T>::row_type(
            v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
            v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
    }

    template <typename T>
    inline tmat4x4<T> operator*
 (
  tmat2x4<T> const & m1,
  tmat4x2<T> const & m2
 )
    {
  typename tmat2x4<T>::value_type SrcA00 = m1[0][0];
  typename tmat2x4<T>::value_type SrcA01 = m1[0][1];
  typename tmat2x4<T>::value_type SrcA02 = m1[0][2];
  typename tmat2x4<T>::value_type SrcA03 = m1[0][3];
  typename tmat2x4<T>::value_type SrcA10 = m1[1][0];
  typename tmat2x4<T>::value_type SrcA11 = m1[1][1];
  typename tmat2x4<T>::value_type SrcA12 = m1[1][2];
  typename tmat2x4<T>::value_type SrcA13 = m1[1][3];

  typename tmat2x4<T>::value_type SrcB00 = m2[0][0];
  typename tmat2x4<T>::value_type SrcB01 = m2[0][1];
  typename tmat2x4<T>::value_type SrcB10 = m2[1][0];
  typename tmat2x4<T>::value_type SrcB11 = m2[1][1];
  typename tmat2x4<T>::value_type SrcB20 = m2[2][0];
  typename tmat2x4<T>::value_type SrcB21 = m2[2][1];
  typename tmat2x4<T>::value_type SrcB30 = m2[3][0];
  typename tmat2x4<T>::value_type SrcB31 = m2[3][1];

  tmat4x4<T> Result(tmat4x4<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
    }

 template <typename T>
 inline tmat2x4<T> operator*
 (
  tmat2x4<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template <typename T>
 inline tmat3x4<T> operator*
 (
  tmat2x4<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

    template <typename T>
    inline tmat2x4<T> operator/
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
    {
        return tmat2x4<T>(
            m[0] / s,
            m[1] / s);
    }

    template <typename T>
    inline tmat2x4<T> operator/
 (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m
 )
    {
        return tmat2x4<T>(
            s / m[0],
            s / m[1]);
    }


    template <typename T>
    inline tmat2x4<T> const operator-
 (
  tmat2x4<T> const & m
 )
    {
        return tmat2x4<T>(
            -m[0],
            -m[1]);
    }

    template <typename T>
    inline tmat2x4<T> const operator++
 (
  tmat2x4<T> const & m,
  int
 )
    {
        return tmat2x4<T>(
            m[0] + typename tmat2x4<T>::value_type(1),
            m[1] + typename tmat2x4<T>::value_type(1));
    }

    template <typename T>
    inline tmat2x4<T> const operator--
 (
  tmat2x4<T> const & m,
  int
 )
    {
        return tmat2x4<T>(
            m[0] - typename tmat2x4<T>::value_type(1),
            m[1] - typename tmat2x4<T>::value_type(1));
    }




 template <typename T>
 inline bool operator==
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }

}
}
# 259 "/usr/include/sgct/glm/./core/type_mat2x4.hpp" 2 3 4
# 46 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat3x2.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat3x2.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat3x2
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T> col_type;
  typedef tvec3<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat3x2<T> type;
  typedef tmat2x3<T> transpose_type;

 private:

  col_type value[3];

 public:

  tmat3x2();
  tmat3x2(tmat3x2 const & m);

  explicit tmat3x2(
   ctor);
  explicit tmat3x2(
   value_type const & s);
  explicit tmat3x2(
   value_type const & x0, value_type const & y0,
   value_type const & x1, value_type const & y1,
   value_type const & x2, value_type const & y2);
  explicit tmat3x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template <typename U>
  explicit tmat3x2(
            U const & x);

  template
        <
            typename X1, typename Y1,
            typename X2, typename Y2,
            typename X3, typename Y3
        >
  explicit tmat3x2(
            X1 const & x1, Y1 const & y1,
            X2 const & x2, Y2 const & y2,
            X3 const & x3, Y3 const & y3);

  template <typename V1, typename V2, typename V3>
  explicit tmat3x2(
            tvec2<V1> const & v1,
            tvec2<V2> const & v2,
            tvec2<V3> const & v3);


  template <typename U>
  explicit tmat3x2(tmat3x2<U> const & m);

  explicit tmat3x2(tmat2x2<T> const & x);
  explicit tmat3x2(tmat3x3<T> const & x);
  explicit tmat3x2(tmat4x4<T> const & x);
  explicit tmat3x2(tmat2x3<T> const & x);
  explicit tmat3x2(tmat2x4<T> const & x);
  explicit tmat3x2(tmat3x4<T> const & x);
  explicit tmat3x2(tmat4x2<T> const & x);
  explicit tmat3x2(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat3x2<T> & operator= (tmat3x2<T> const & m);
  template <typename U>
  tmat3x2<T> & operator= (tmat3x2<U> const & m);
  template <typename U>
  tmat3x2<T> & operator+= (U const & s);
  template <typename U>
  tmat3x2<T> & operator+= (tmat3x2<U> const & m);
  template <typename U>
  tmat3x2<T> & operator-= (U const & s);
  template <typename U>
  tmat3x2<T> & operator-= (tmat3x2<U> const & m);
  template <typename U>
  tmat3x2<T> & operator*= (U const & s);
  template <typename U>
  tmat3x2<T> & operator*= (tmat3x2<U> const & m);
  template <typename U>
  tmat3x2<T> & operator/= (U const & s);

  tmat3x2<T> & operator++ ();
  tmat3x2<T> & operator-- ();
 };


 template <typename T>
 tmat3x2<T> operator+ (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator+ (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat3x2<T> operator- (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator- (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat3x2<T> operator* (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator* (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m);

 template <typename T>
 typename tmat3x2<T>::col_type operator* (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::row_type const & v);

 template <typename T>
 typename tmat3x2<T>::row_type operator* (
  typename tmat3x2<T>::col_type const & v,
  tmat3x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator* (
  tmat3x2<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat3x2<T> operator* (
  tmat3x2<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat3x2<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat3x2<T> operator/ (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator/ (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m);


 template <typename T>
 tmat3x2<T> const operator- (
  tmat3x2<T> const & m);

 template <typename T>
 tmat3x2<T> const operator-- (
  tmat3x2<T> const & m,
  int);

 template <typename T>
 tmat3x2<T> const operator++ (
  tmat3x2<T> const & m,
  int);

}
# 244 "/usr/include/sgct/glm/./core/type_mat3x2.hpp" 3 4
 typedef detail::tmat3x2<lowp_float> lowp_mat3x2;






 typedef detail::tmat3x2<mediump_float> mediump_mat3x2;






 typedef detail::tmat3x2<highp_float> highp_mat3x2;


}


# 1 "/usr/include/sgct/glm/./core/type_mat3x2.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat3x2.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat3x2<T>::size_type tmat3x2<T>::length() const
    {
        return 3;
    }

 template <typename T>
 inline typename tmat3x2<T>::size_type tmat3x2<T>::col_size()
 {
  return 2;
 }

 template <typename T>
 inline typename tmat3x2<T>::size_type tmat3x2<T>::row_size()
 {
  return 3;
 }




 template <typename T>
 inline typename tmat3x2<T>::col_type &
 tmat3x2<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat3x2.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat3x2<T>::col_type const &
 tmat3x2<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat3x2.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat3x2<T>::tmat3x2()
    {
        this->value[0] = col_type(1, 0);
        this->value[1] = col_type(0, 1);
        this->value[2] = col_type(0, 0);
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
  this->value[2] = m.value[2];
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  value_type const & s
 )
    {
        this->value[0] = col_type(s, 0);
        this->value[1] = col_type(0, s);
        this->value[2] = col_type(0, 0);
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
    (
        value_type const & x0, value_type const & y0,
        value_type const & x1, value_type const & y1,
        value_type const & x2, value_type const & y2
    )
    {
        this->value[0] = col_type(x0, y0);
        this->value[1] = col_type(x1, y1);
        this->value[2] = col_type(x2, y2);
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
    (
        col_type const & v0,
        col_type const & v1,
        col_type const & v2
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
        this->value[2] = v2;
    }



 template <typename T>
 template <typename U>
 tmat3x2<T>::tmat3x2
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec2<T>(value_type(s), Zero);
        this->value[1] = tvec2<T>(Zero, value_type(s));
        this->value[2] = tvec2<T>(Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 tmat3x2<T>::tmat3x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1));
        this->value[1] = col_type(value_type(x2), value_type(y2));
        this->value[2] = col_type(value_type(x3), value_type(y3));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3>
 tmat3x2<T>::tmat3x2
 (
  tvec2<V1> const & v1,
  tvec2<V2> const & v2,
  tvec2<V3> const & v3
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
        this->value[2] = col_type(v3);
 }




    template <typename T>
    template <typename U>
    inline tmat3x2<T>::tmat3x2
 (
  tmat3x2<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
 }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = col_type(T(0));
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(T(0));
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(T(0));
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
    }

    template <typename T>
    inline tmat3x2<T>::tmat3x2
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
    }




    template <typename T>
    inline tmat3x2<T>& tmat3x2<T>::operator=
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T>& tmat3x2<T>::operator=
 (
  tmat3x2<U> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T>& tmat3x2<T>::operator+=
 (
  U const & s
 )
    {
        this->value[0] += s;
        this->value[1] += s;
        this->value[2] += s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T>& tmat3x2<T>::operator+=
 (
  tmat3x2<U> const & m
 )
    {
        this->value[0] += m[0];
        this->value[1] += m[1];
        this->value[2] += m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T>& tmat3x2<T>::operator-=
 (
  U const & s
 )
    {
        this->value[0] -= s;
        this->value[1] -= s;
        this->value[2] -= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T>& tmat3x2<T>::operator-=
 (
  tmat3x2<U> const & m
 )
    {
        this->value[0] -= m[0];
        this->value[1] -= m[1];
        this->value[2] -= m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T>& tmat3x2<T>::operator*=
 (
  U const & s
 )
    {
        this->value[0] *= s;
        this->value[1] *= s;
        this->value[2] *= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T>& tmat3x2<T>::operator*=
 (
  tmat3x2<U> const & m
 )
    {
        return (*this = tmat3x2<T>(*this * m));
    }

    template <typename T>
 template <typename U>
    inline tmat3x2<T> & tmat3x2<T>::operator/=
 (
  U const & s
 )
    {
        this->value[0] /= s;
        this->value[1] /= s;
        this->value[2] /= s;
        return *this;
    }

    template <typename T>
    inline tmat3x2<T>& tmat3x2<T>::operator++ ()
    {
        ++this->value[0];
        ++this->value[1];
        ++this->value[2];
        return *this;
    }

    template <typename T>
    inline tmat3x2<T>& tmat3x2<T>::operator-- ()
    {
        --this->value[0];
        --this->value[1];
        --this->value[2];
        return *this;
    }




    template <typename T>
    inline tmat3x2<T> operator+
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
    {
        return tmat3x2<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s);
    }

    template <typename T>
    inline tmat3x2<T> operator+
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
    {
        return tmat3x2<T>(
            m1[0] + m2[0],
            m1[1] + m2[1],
            m1[2] + m2[2]);
    }

    template <typename T>
    inline tmat3x2<T> operator-
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
    {
        return tmat3x2<T>(
            m[0] - s,
            m[1] - s,
            m[2] - s);
    }

    template <typename T>
    inline tmat3x2<T> operator-
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
    {
        return tmat3x2<T>(
            m1[0] - m2[0],
            m1[1] - m2[1],
            m1[2] - m2[2]);
    }

    template <typename T>
    inline tmat3x2<T> operator*
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
    {
        return tmat3x2<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s);
    }

    template <typename T>
    inline tmat3x2<T> operator*
 (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m
 )
    {
        return tmat3x2<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s);
    }

    template <typename T>
    inline typename tmat3x2<T>::col_type operator*
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::row_type const & v)
    {
        return typename tmat3x2<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
            m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
    }

    template <typename T>
    inline typename tmat3x2<T>::row_type operator*
 (
  typename tmat3x2<T>::col_type const & v,
  tmat3x2<T> const & m)
    {
        return typename tmat3x2<T>::row_type(
            v.x * m[0][0] + v.y * m[0][1],
            v.x * m[1][0] + v.y * m[1][1],
            v.x * m[2][0] + v.y * m[2][1]);
    }

    template <typename T>
    inline tmat2x2<T> operator*
 (
  tmat3x2<T> const & m1,
  tmat2x3<T> const & m2
 )
    {
        const T SrcA00 = m1[0][0];
        const T SrcA01 = m1[0][1];
        const T SrcA10 = m1[1][0];
        const T SrcA11 = m1[1][1];
        const T SrcA20 = m1[2][0];
        const T SrcA21 = m1[2][1];

        const T SrcB00 = m2[0][0];
        const T SrcB01 = m2[0][1];
        const T SrcB02 = m2[0][2];
        const T SrcB10 = m2[1][0];
        const T SrcB11 = m2[1][1];
        const T SrcB12 = m2[1][2];

        tmat2x2<T> Result(tmat2x2<T>::null);
        Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
        Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
        Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
        Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
        return Result;
    }

 template <typename T>
 inline tmat3x2<T> operator*
 (
  tmat3x2<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template <typename T>
 inline tmat4x2<T> operator*
 (
  tmat3x2<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

    template <typename T>
    inline tmat3x2<T> operator/
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
    {
        return tmat3x2<T>(
            m[0] / s,
            m[1] / s,
            m[2] / s);
    }

    template <typename T>
    inline tmat3x2<T> operator/
 (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m
 )
    {
        return tmat3x2<T>(
            s / m[0],
            s / m[1],
            s / m[2]);
    }


    template <typename T>
    inline tmat3x2<T> const operator-
 (
  tmat3x2<T> const & m
 )
    {
        return tmat3x2<T>(
            -m[0],
            -m[1],
            -m[2]);
    }

    template <typename T>
    inline tmat3x2<T> const operator++
 (
  tmat3x2<T> const & m,
  int
 )
    {
  typename tmat3x2<T>::value_type One(1);
        return tmat3x2<T>(
            m[0] + One,
            m[1] + One,
            m[2] + One);
    }

    template <typename T>
    inline tmat3x2<T> const operator--
 (
  tmat3x2<T> const & m,
  int
 )
    {
  typename tmat3x2<T>::value_type One(1);
        return tmat3x2<T>(
            m[0] - One,
            m[1] - One,
            m[2] - One);
    }




 template <typename T>
 inline bool operator==
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }

}
}
# 265 "/usr/include/sgct/glm/./core/type_mat3x2.hpp" 2 3 4
# 47 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat3x3.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat3x3.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat3x3
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T> col_type;
  typedef tvec3<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat3x3<T> type;
  typedef tmat3x3<T> transpose_type;

 public:


  tmat3x3<T> _inverse() const;


 private:

  col_type value[3];

 public:

  tmat3x3();
  tmat3x3(tmat3x3 const & m);

  explicit tmat3x3(
   ctor Null);
  explicit tmat3x3(
   value_type const & s);
  explicit tmat3x3(
   value_type const & x0, value_type const & y0, value_type const & z0,
   value_type const & x1, value_type const & y1, value_type const & z1,
   value_type const & x2, value_type const & y2, value_type const & z2);
  explicit tmat3x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template <typename U>
  explicit tmat3x3(
            U const & x);

  template
        <
            typename X1, typename Y1, typename Z1,
            typename X2, typename Y2, typename Z2,
            typename X3, typename Y3, typename Z3
        >
  explicit tmat3x3(
            X1 const & x1, Y1 const & y1, Z1 const & z1,
            X2 const & x2, Y2 const & y2, Z2 const & z2,
            X3 const & x3, Y3 const & y3, Z3 const & z3);

  template <typename V1, typename V2, typename V3>
  explicit tmat3x3(
            tvec3<V1> const & v1,
            tvec3<V2> const & v2,
            tvec3<V3> const & v3);


  template <typename U>
  explicit tmat3x3(tmat3x3<U> const & m);

  explicit tmat3x3(tmat2x2<T> const & x);
  explicit tmat3x3(tmat4x4<T> const & x);
  explicit tmat3x3(tmat2x3<T> const & x);
  explicit tmat3x3(tmat3x2<T> const & x);
  explicit tmat3x3(tmat2x4<T> const & x);
  explicit tmat3x3(tmat4x2<T> const & x);
  explicit tmat3x3(tmat3x4<T> const & x);
  explicit tmat3x3(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat3x3<T>& operator= (tmat3x3<T> const & m);
  template <typename U>
  tmat3x3<T>& operator= (tmat3x3<U> const & m);
  template <typename U>
  tmat3x3<T>& operator+= (U const & s);
  template <typename U>
  tmat3x3<T>& operator+= (tmat3x3<U> const & m);
  template <typename U>
  tmat3x3<T>& operator-= (U const & s);
  template <typename U>
  tmat3x3<T>& operator-= (tmat3x3<U> const & m);
  template <typename U>
  tmat3x3<T>& operator*= (U const & s);
  template <typename U>
  tmat3x3<T>& operator*= (tmat3x3<U> const & m);
  template <typename U>
  tmat3x3<T>& operator/= (U const & s);
  template <typename U>
  tmat3x3<T>& operator/= (tmat3x3<U> const & m);
  tmat3x3<T>& operator++ ();
  tmat3x3<T>& operator-- ();
 };


 template <typename T>
 tmat3x3<T> operator+ (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator+ (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator+ (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat3x3<T> operator- (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator- (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator- (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat3x3<T> operator* (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator* (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 typename tmat3x3<T>::col_type operator* (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v);

 template <typename T>
 typename tmat3x3<T>::row_type operator* (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator* (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat2x3<T> operator* (
  tmat3x3<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat3x3<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat3x3<T> operator/ (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator/ (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 typename tmat3x3<T>::col_type operator/ (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v);

 template <typename T>
 typename tmat3x3<T>::row_type operator/ (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator/ (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);


 template <typename T>
 tmat3x3<T> const operator- (
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> const operator-- (
  tmat3x3<T> const & m,
  int);

 template <typename T>
 tmat3x3<T> const operator++ (
  tmat3x3<T> const & m,
  int);

}
# 276 "/usr/include/sgct/glm/./core/type_mat3x3.hpp" 3 4
 typedef detail::tmat3x3<lowp_float> lowp_mat3;






 typedef detail::tmat3x3<mediump_float> mediump_mat3;






 typedef detail::tmat3x3<highp_float> highp_mat3;






 typedef detail::tmat3x3<lowp_float> lowp_mat3x3;






 typedef detail::tmat3x3<mediump_float> mediump_mat3x3;






 typedef detail::tmat3x3<highp_float> highp_mat3x3;


}


# 1 "/usr/include/sgct/glm/./core/type_mat3x3.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat3x3.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat3x3<T>::size_type tmat3x3<T>::length() const
    {
        return 3;
    }

 template <typename T>
 inline typename tmat3x3<T>::size_type tmat3x3<T>::col_size()
 {
  return 3;
 }

 template <typename T>
 inline typename tmat3x3<T>::size_type tmat3x3<T>::row_size()
 {
  return 3;
 }




 template <typename T>
 inline typename tmat3x3<T>::col_type &
 tmat3x3<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat3x3.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat3x3<T>::col_type const &
 tmat3x3<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat3x3.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat3x3<T>::tmat3x3()
    {
  value_type const Zero(0);
  value_type const One(1);
        this->value[0] = col_type(One, Zero, Zero);
        this->value[1] = col_type(Zero, One, Zero);
        this->value[2] = col_type(Zero, Zero, One);
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
        this->value[2] = m.value[2];
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  value_type const & s
 )
    {
  value_type const Zero(0);
        this->value[0] = col_type(s, Zero, Zero);
        this->value[1] = col_type(Zero, s, Zero);
        this->value[2] = col_type(Zero, Zero, s);
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
    (
        value_type const & x0, value_type const & y0, value_type const & z0,
        value_type const & x1, value_type const & y1, value_type const & z1,
        value_type const & x2, value_type const & y2, value_type const & z2
    )
    {
        this->value[0] = col_type(x0, y0, z0);
        this->value[1] = col_type(x1, y1, z1);
        this->value[2] = col_type(x2, y2, z2);
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
    (
        col_type const & v0,
        col_type const & v1,
        col_type const & v2
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
        this->value[2] = v2;
    }



 template <typename T>
 template <typename U>
 tmat3x3<T>::tmat3x3
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
        this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
        this->value[2] = tvec3<T>(Zero, Zero, value_type(s));
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 tmat3x3<T>::tmat3x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
        this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
        this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3>
 tmat3x3<T>::tmat3x3
 (
  tvec3<V1> const & v1,
  tvec3<V2> const & v2,
  tvec3<V3> const & v3
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
        this->value[2] = col_type(v3);
 }




    template <typename T>
    template <typename U>
    inline tmat3x3<T>::tmat3x3
 (
  tmat3x3<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
 }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
    }

 template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(m[2], value_type(1));
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(m[2], value_type(1));
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
    }

    template <typename T>
    inline tmat3x3<T>::tmat3x3
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
    }




    template <typename T>
    inline tmat3x3<T> & tmat3x3<T>::operator=
 (
  tmat3x3<T> const & m
 )
    {
     this->value[0] = m[0];
     this->value[1] = m[1];
        this->value[2] = m[2];
     return *this;
    }

    template <typename T>
    template <typename U>
 inline tmat3x3<T> & tmat3x3<T>::operator=
 (
  tmat3x3<U> const & m
 )
    {
     this->value[0] = m[0];
     this->value[1] = m[1];
        this->value[2] = m[2];
     return *this;
    }

    template <typename T>
 template <typename U>
 inline tmat3x3<T> & tmat3x3<T>::operator+=
 (
  U const & s
 )
    {
     this->value[0] += s;
     this->value[1] += s;
        this->value[2] += s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x3<T> & tmat3x3<T>::operator+=
 (
  tmat3x3<U> const & m
 )
    {
     this->value[0] += m[0];
     this->value[1] += m[1];
        this->value[2] += m[2];
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x3<T> & tmat3x3<T>::operator-=
 (
  U const & s
 )
    {
     this->value[0] -= s;
     this->value[1] -= s;
        this->value[2] -= s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x3<T> & tmat3x3<T>::operator-=
 (
  tmat3x3<U> const & m
 )
    {
     this->value[0] -= m[0];
     this->value[1] -= m[1];
        this->value[2] -= m[2];
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x3<T> & tmat3x3<T>::operator*=
 (
  U const & s
 )
    {
     this->value[0] *= s;
     this->value[1] *= s;
        this->value[2] *= s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x3<T> & tmat3x3<T>::operator*=
 (
  tmat3x3<U> const & m
 )
    {
        return (*this = *this * m);
    }

    template <typename T>
 template <typename U>
    inline tmat3x3<T> & tmat3x3<T>::operator/=
 (
  U const & s
 )
    {
     this->value[0] /= s;
     this->value[1] /= s;
        this->value[2] /= s;
     return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x3<T> & tmat3x3<T>::operator/=
 (
  tmat3x3<U> const & m
 )
    {
        return (*this = *this / m);
    }

    template <typename T>
    inline tmat3x3<T> & tmat3x3<T>::operator++ ()
    {
     ++this->value[0];
     ++this->value[1];
        ++this->value[2];
     return *this;
    }

    template <typename T>
    inline tmat3x3<T> & tmat3x3<T>::operator-- ()
    {
     --this->value[0];
     --this->value[1];
        --this->value[2];
     return *this;
    }

    template <typename T>
    inline tmat3x3<T> tmat3x3<T>::_inverse() const
    {
        T S00 = value[0][0];
        T S01 = value[0][1];
        T S02 = value[0][2];

        T S10 = value[1][0];
        T S11 = value[1][1];
        T S12 = value[1][2];

        T S20 = value[2][0];
        T S21 = value[2][1];
        T S22 = value[2][2];
# 463 "/usr/include/sgct/glm/./core/type_mat3x3.inl" 3 4
        tmat3x3<T> Inverse(
            S11 * S22 - S21 * S12,
            S12 * S20 - S22 * S10,
            S10 * S21 - S20 * S11,
            S02 * S21 - S01 * S22,
            S00 * S22 - S02 * S20,
            S01 * S20 - S00 * S21,
            S12 * S01 - S11 * S02,
            S10 * S02 - S12 * S00,
            S11 * S00 - S10 * S01);

        T Determinant = S00 * (S11 * S22 - S21 * S12)
                      - S10 * (S01 * S22 - S21 * S02)
                      + S20 * (S01 * S12 - S11 * S02);

        Inverse /= Determinant;
        return Inverse;
    }




    template <typename T>
    inline tmat3x3<T> operator+
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
    {
        return tmat3x3<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s);
    }

    template <typename T>
    inline tmat3x3<T> operator+
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
    {
        return tmat3x3<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s);
    }

    template <typename T>
    inline tmat3x3<T> operator+
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
    {
        return tmat3x3<T>(
            m1[0] + m2[0],
            m1[1] + m2[1],
            m1[2] + m2[2]);
    }

    template <typename T>
    inline tmat3x3<T> operator-
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
    {
        return tmat3x3<T>(
            m[0] - s,
            m[1] - s,
            m[2] - s);
    }

    template <typename T>
    inline tmat3x3<T> operator-
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
    {
        return tmat3x3<T>(
            s - m[0],
            s - m[1],
            s - m[2]);
    }

    template <typename T>
    inline tmat3x3<T> operator-
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
    {
        return tmat3x3<T>(
            m1[0] - m2[0],
            m1[1] - m2[1],
            m1[2] - m2[2]);
    }

    template <typename T>
    inline tmat3x3<T> operator*
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
    {
        return tmat3x3<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s);
    }

    template <typename T>
    inline tmat3x3<T> operator*
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
    {
        return tmat3x3<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s);
    }

    template <typename T>
    inline typename tmat3x3<T>::col_type operator*
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v
 )
    {
        return typename tmat3x3<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
            m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
            m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
    }

    template <typename T>
    inline typename tmat3x3<T>::row_type operator*
 (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m
 )
    {
        return typename tmat3x3<T>::row_type(
            m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
            m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
            m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
    }

    template <typename T>
    inline tmat3x3<T> operator*
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
    {
  typename tmat3x3<T>::value_type const SrcA00 = m1[0][0];
  typename tmat3x3<T>::value_type const SrcA01 = m1[0][1];
  typename tmat3x3<T>::value_type const SrcA02 = m1[0][2];
  typename tmat3x3<T>::value_type const SrcA10 = m1[1][0];
  typename tmat3x3<T>::value_type const SrcA11 = m1[1][1];
  typename tmat3x3<T>::value_type const SrcA12 = m1[1][2];
  typename tmat3x3<T>::value_type const SrcA20 = m1[2][0];
  typename tmat3x3<T>::value_type const SrcA21 = m1[2][1];
  typename tmat3x3<T>::value_type const SrcA22 = m1[2][2];

  typename tmat3x3<T>::value_type const SrcB00 = m2[0][0];
  typename tmat3x3<T>::value_type const SrcB01 = m2[0][1];
  typename tmat3x3<T>::value_type const SrcB02 = m2[0][2];
  typename tmat3x3<T>::value_type const SrcB10 = m2[1][0];
  typename tmat3x3<T>::value_type const SrcB11 = m2[1][1];
  typename tmat3x3<T>::value_type const SrcB12 = m2[1][2];
  typename tmat3x3<T>::value_type const SrcB20 = m2[2][0];
  typename tmat3x3<T>::value_type const SrcB21 = m2[2][1];
  typename tmat3x3<T>::value_type const SrcB22 = m2[2][2];

  tmat3x3<T> Result(tmat3x3<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
    }

 template <typename T>
 inline tmat2x3<T> operator*
 (
  tmat3x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template <typename T>
 inline tmat4x3<T> operator*
 (
  tmat3x3<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return tmat4x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

    template <typename T>
    inline tmat3x3<T> operator/
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
    {
        return tmat3x3<T>(
            m[0] / s,
            m[1] / s,
            m[2] / s);
    }

    template <typename T>
    inline tmat3x3<T> operator/
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
    {
        return tmat3x3<T>(
            s / m[0],
            s / m[1],
            s / m[2]);
    }

 template <typename T>
 inline typename tmat3x3<T>::col_type operator/
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v
 )
 {
  return m._inverse() * v;
 }

 template <typename T>
 inline typename tmat3x3<T>::row_type operator/
 (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m
 )
 {
  return v * m._inverse();
 }

 template <typename T>
 inline tmat3x3<T> operator/
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return m1 * m2._inverse();
 }


    template <typename T>
    inline tmat3x3<T> const operator-
 (
  tmat3x3<T> const & m
 )
    {
        return tmat3x3<T>(
            -m[0],
            -m[1],
            -m[2]);
    }

    template <typename T>
    inline tmat3x3<T> const operator++
 (
  tmat3x3<T> const & m,
  int
 )
    {
        return tmat3x3<T>(
            m[0] + T(1),
            m[1] + T(1),
            m[2] + T(1));
    }

    template <typename T>
    inline tmat3x3<T> const operator--
 (
  tmat3x3<T> const & m,
  int
 )
    {
        return tmat3x3<T>(
            m[0] - T(1),
            m[1] - T(1),
            m[2] - T(1));
    }




 template <typename T>
 inline bool operator==
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }

}
}
# 318 "/usr/include/sgct/glm/./core/type_mat3x3.hpp" 2 3 4
# 48 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat3x4.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat3x4.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat3x4
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T> col_type;
  typedef tvec3<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat3x4<T> type;
  typedef tmat4x3<T> transpose_type;

 private:

  col_type value[3];

 public:

  tmat3x4();
  tmat3x4(tmat3x4 const & m);

  explicit tmat3x4(
   ctor Null);
  explicit tmat3x4(
   value_type const & s);
  explicit tmat3x4(
   value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
   value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
   value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2);
  explicit tmat3x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template <typename U>
  explicit tmat3x4(
            U const & x);

  template
        <
            typename X1, typename Y1, typename Z1, typename W1,
            typename X2, typename Y2, typename Z2, typename W2,
            typename X3, typename Y3, typename Z3, typename W3
        >
  explicit tmat3x4(
            X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
            X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
            X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3);

  template <typename V1, typename V2, typename V3>
  explicit tmat3x4(
            tvec4<V1> const & v1,
            tvec4<V2> const & v2,
            tvec4<V3> const & v3);


  template <typename U>
  explicit tmat3x4(tmat3x4<U> const & m);

  explicit tmat3x4(tmat2x2<T> const & x);
  explicit tmat3x4(tmat3x3<T> const & x);
  explicit tmat3x4(tmat4x4<T> const & x);
  explicit tmat3x4(tmat2x3<T> const & x);
  explicit tmat3x4(tmat3x2<T> const & x);
  explicit tmat3x4(tmat2x4<T> const & x);
  explicit tmat3x4(tmat4x2<T> const & x);
  explicit tmat3x4(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat3x4<T> & operator= (tmat3x4<T> const & m);
  template <typename U>
  tmat3x4<T> & operator= (tmat3x4<U> const & m);
  template <typename U>
  tmat3x4<T> & operator+= (U const & s);
  template <typename U>
  tmat3x4<T> & operator+= (tmat3x4<U> const & m);
  template <typename U>
  tmat3x4<T> & operator-= (U const & s);
  template <typename U>
  tmat3x4<T> & operator-= (tmat3x4<U> const & m);
  template <typename U>
  tmat3x4<T> & operator*= (U const & s);
  template <typename U>
  tmat3x4<T> & operator*= (tmat3x4<U> const & m);
  template <typename U>
  tmat3x4<T> & operator/= (U const & s);

  tmat3x4<T> & operator++ ();
  tmat3x4<T> & operator-- ();
 };


 template <typename T>
 tmat3x4<T> operator+ (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator+ (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat3x4<T> operator- (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator- (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator* (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m);

 template <typename T>
 typename tmat3x4<T>::col_type operator* (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::row_type const & v);

 template <typename T>
 typename tmat3x4<T>::row_type operator* (
  typename tmat3x4<T>::col_type const & v,
  tmat3x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator* (
  tmat3x4<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat2x4<T> operator* (
  tmat3x4<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat3x4<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat3x4<T> operator/ (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator/ (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m);


 template <typename T>
 tmat3x4<T> const operator- (
  tmat3x4<T> const & m);

 template <typename T>
 tmat3x4<T> const operator-- (
  tmat3x4<T> const & m,
  int);

 template <typename T>
 tmat3x4<T> const operator++ (
  tmat3x4<T> const & m,
  int);

}
# 244 "/usr/include/sgct/glm/./core/type_mat3x4.hpp" 3 4
 typedef detail::tmat3x4<lowp_float> lowp_mat3x4;






 typedef detail::tmat3x4<mediump_float> mediump_mat3x4;






 typedef detail::tmat3x4<highp_float> highp_mat3x4;


}


# 1 "/usr/include/sgct/glm/./core/type_mat3x4.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat3x4.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat3x4<T>::size_type tmat3x4<T>::length() const
    {
        return 3;
    }

 template <typename T>
 inline typename tmat3x4<T>::size_type tmat3x4<T>::col_size()
 {
  return 4;
 }

 template <typename T>
 inline typename tmat3x4<T>::size_type tmat3x4<T>::row_size()
 {
  return 3;
 }




 template <typename T>
 inline typename tmat3x4<T>::col_type &
 tmat3x4<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat3x4.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat3x4<T>::col_type const &
 tmat3x4<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat3x4.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat3x4<T>::tmat3x4()
    {
        this->value[0] = col_type(1, 0, 0, 0);
        this->value[1] = col_type(0, 1, 0, 0);
        this->value[2] = col_type(0, 0, 1, 0);
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
        this->value[2] = m.value[2];
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  value_type const & s
 )
    {
  value_type const Zero(0);
        this->value[0] = col_type(s, Zero, Zero, Zero);
        this->value[1] = col_type(Zero, s, Zero, Zero);
        this->value[2] = col_type(Zero, Zero, s, Zero);
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
    (
  value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
        value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
        value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2
    )
    {
        this->value[0] = col_type(x0, y0, z0, w0);
        this->value[1] = col_type(x1, y1, z1, w1);
        this->value[2] = col_type(x2, y2, z2, w2);
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
    (
        col_type const & v0,
        col_type const & v1,
        col_type const & v2
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
        this->value[2] = v2;
    }



 template <typename T>
 template <typename U>
 tmat3x4<T>::tmat3x4
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
        this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
        this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3>
 tmat3x4<T>::tmat3x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
        this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
        this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3), value_type(w3));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3>
 tmat3x4<T>::tmat3x4
 (
  tvec4<V1> const & v1,
  tvec4<V2> const & v2,
  tvec4<V3> const & v3
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
        this->value[2] = col_type(v3);
 }


    template <typename T>
    template <typename U>
    inline tmat3x4<T>::tmat3x4
 (
  tmat3x4<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
 }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(0));
        this->value[1] = col_type(m[1], detail::tvec2<T>(0));
        this->value[2] = col_type(T(0), T(0), T(1), T(0));
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
        this->value[2] = col_type(m[2], T(0));
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
        this->value[2] = col_type(T(0), T(0), T(1), T(0));
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(0));
        this->value[1] = col_type(m[1], detail::tvec2<T>(0));
        this->value[2] = col_type(m[2], T(0), T(1));
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(T(0), T(0), T(1), T(0));
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(T(0)));
        this->value[1] = col_type(m[1], detail::tvec2<T>(T(0)));
        this->value[2] = col_type(m[2], detail::tvec2<T>(T(1), T(0)));
    }

    template <typename T>
    inline tmat3x4<T>::tmat3x4
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
        this->value[2] = col_type(m[2], T(0));
    }




    template <typename T>
    inline tmat3x4<T>& tmat3x4<T>::operator=
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T>& tmat3x4<T>::operator=
 (
  tmat3x4<U> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T>& tmat3x4<T>::operator+=
 (
  U const & s
 )
    {
        this->value[0] += s;
        this->value[1] += s;
        this->value[2] += s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T>& tmat3x4<T>::operator+=
 (
  tmat3x4<U> const & m
 )
    {
        this->value[0] += m[0];
        this->value[1] += m[1];
        this->value[2] += m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T>& tmat3x4<T>::operator-=
 (
  U const & s
 )
    {
        this->value[0] -= s;
        this->value[1] -= s;
        this->value[2] -= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T>& tmat3x4<T>::operator-=
 (
  tmat3x4<U> const & m
 )
    {
        this->value[0] -= m[0];
        this->value[1] -= m[1];
        this->value[2] -= m[2];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T>& tmat3x4<T>::operator*=
 (
  U const & s
 )
    {
        this->value[0] *= s;
        this->value[1] *= s;
        this->value[2] *= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T>& tmat3x4<T>::operator*=
 (
  tmat3x4<U> const & m
 )
    {
        return (*this = tmat3x4<T>(*this * m));
    }

    template <typename T>
 template <typename U>
    inline tmat3x4<T> & tmat3x4<T>::operator/=
 (
  U const & s
 )
    {
        this->value[0] /= s;
        this->value[1] /= s;
        this->value[2] /= s;
        return *this;
    }

    template <typename T>
    inline tmat3x4<T>& tmat3x4<T>::operator++ ()
    {
        ++this->value[0];
        ++this->value[1];
        ++this->value[2];
        return *this;
    }

    template <typename T>
    inline tmat3x4<T>& tmat3x4<T>::operator-- ()
    {
        --this->value[0];
        --this->value[1];
        --this->value[2];
        return *this;
    }




    template <typename T>
    inline tmat3x4<T> operator+
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
    {
        return tmat3x4<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s);
    }

    template <typename T>
    inline tmat3x4<T> operator+
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
    {
        return tmat3x4<T>(
            m1[0] + m2[0],
            m1[1] + m2[1],
            m1[2] + m2[2]);
    }

    template <typename T>
 inline tmat3x4<T> operator-
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
    {
        return tmat3x4<T>(
            m[0] - s,
            m[1] - s,
            m[2] - s);
    }

    template <typename T>
    inline tmat3x4<T> operator-
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
    {
        return tmat3x4<T>(
            m1[0] - m2[0],
            m1[1] - m2[1],
            m1[2] - m2[2]);
    }

    template <typename T>
    inline tmat3x4<T> operator*
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
    {
        return tmat3x4<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s);
    }

    template <typename T>
    inline tmat3x4<T> operator*
 (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m
 )
    {
        return tmat3x4<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s);
    }

    template <typename T>
    inline typename tmat3x4<T>::col_type operator*
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::row_type const & v
 )
    {
        return typename tmat3x4<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
            m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
            m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
            m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
    }






    template <typename T>
    inline typename tmat3x4<T>::row_type operator*
 (
  typename tmat3x4<T>::col_type const & v,
  tmat3x4<T> const & m
 )
    {
  return typename tmat3x4<T>::row_type(
            v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
            v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
            v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
    }

    template <typename T>
    inline tmat4x4<T> operator*
 (
  tmat3x4<T> const & m1,
  tmat4x3<T> const & m2
 )
    {
        const T SrcA00 = m1[0][0];
        const T SrcA01 = m1[0][1];
        const T SrcA02 = m1[0][2];
        const T SrcA03 = m1[0][3];
        const T SrcA10 = m1[1][0];
        const T SrcA11 = m1[1][1];
        const T SrcA12 = m1[1][2];
        const T SrcA13 = m1[1][3];
        const T SrcA20 = m1[2][0];
        const T SrcA21 = m1[2][1];
        const T SrcA22 = m1[2][2];
        const T SrcA23 = m1[2][3];

        const T SrcB00 = m2[0][0];
        const T SrcB01 = m2[0][1];
        const T SrcB02 = m2[0][2];
        const T SrcB10 = m2[1][0];
        const T SrcB11 = m2[1][1];
        const T SrcB12 = m2[1][2];
        const T SrcB20 = m2[2][0];
        const T SrcB21 = m2[2][1];
        const T SrcB22 = m2[2][2];
        const T SrcB30 = m2[3][0];
        const T SrcB31 = m2[3][1];
        const T SrcB32 = m2[3][2];

        tmat4x4<T> Result(tmat4x4<T>::null);
        Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
        Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
        Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
        Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
        Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
        Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
        Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
        Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
        Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
        Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
        Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
        Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
        Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
        Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
        Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
        Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
        return Result;
    }

 template <typename T>
 inline tmat2x4<T> operator*
 (
  tmat3x4<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template <typename T>
 inline tmat3x4<T> operator*
 (
  tmat3x4<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

    template <typename T>
    inline tmat3x4<T> operator/
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
    {
        return tmat3x4<T>(
            m[0] / s,
            m[1] / s,
            m[2] / s);
    }

    template <typename T>
    inline tmat3x4<T> operator/
 (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m
 )
    {
        return tmat3x4<T>(
            s / m[0],
            s / m[1],
            s / m[2]);
    }


    template <typename T>
    inline tmat3x4<T> const operator-
 (
  tmat3x4<T> const & m
 )
    {
        return tmat3x4<T>(
            -m[0],
            -m[1],
            -m[2]);
    }

    template <typename T>
    inline tmat3x4<T> const operator++
 (
  tmat3x4<T> const & m,
  int
 )
    {
        return tmat3x4<T>(
            m[0] + T(1),
            m[1] + T(1),
            m[2] + T(1));
    }

    template <typename T>
    inline tmat3x4<T> const operator--
 (
  tmat3x4<T> const & m,
  int
 )
    {
        return tmat3x4<T>(
            m[0] - T(1),
            m[1] - T(1),
            m[2] - T(1));
 }




 template <typename T>
 inline bool operator==
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }

}
}
# 265 "/usr/include/sgct/glm/./core/type_mat3x4.hpp" 2 3 4
# 49 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat4x2.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat4x2.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat4x2
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T> col_type;
  typedef tvec4<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat4x2<T> type;
  typedef tmat2x4<T> transpose_type;

 private:

  col_type value[4];

 public:

  tmat4x2();
  tmat4x2(tmat4x2 const & m);

  explicit tmat4x2(
   ctor Null);
  explicit tmat4x2(
   value_type const & x);
  explicit tmat4x2(
   value_type const & x0, value_type const & y0,
   value_type const & x1, value_type const & y1,
   value_type const & x2, value_type const & y2,
   value_type const & x3, value_type const & y3);
  explicit tmat4x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <typename U>
  explicit tmat4x2(
            U const & x);

  template
        <
            typename X1, typename Y1,
            typename X2, typename Y2,
            typename X3, typename Y3,
            typename X4, typename Y4
        >
  explicit tmat4x2(
            X1 const & x1, Y1 const & y1,
            X2 const & x2, Y2 const & y2,
            X3 const & x3, Y3 const & y3,
            X4 const & x4, Y4 const & y4);

  template <typename V1, typename V2, typename V3, typename V4>
  explicit tmat4x2(
            tvec2<V1> const & v1,
            tvec2<V2> const & v2,
            tvec2<V3> const & v3,
            tvec2<V4> const & v4);


  template <typename U>
  explicit tmat4x2(tmat4x2<U> const & m);

  explicit tmat4x2(tmat2x2<T> const & x);
  explicit tmat4x2(tmat3x3<T> const & x);
  explicit tmat4x2(tmat4x4<T> const & x);
  explicit tmat4x2(tmat2x3<T> const & x);
  explicit tmat4x2(tmat3x2<T> const & x);
  explicit tmat4x2(tmat2x4<T> const & x);
  explicit tmat4x2(tmat4x3<T> const & x);
  explicit tmat4x2(tmat3x4<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat4x2<T>& operator= (tmat4x2<T> const & m);
  template <typename U>
  tmat4x2<T>& operator= (tmat4x2<U> const & m);
  template <typename U>
  tmat4x2<T>& operator+= (U const & s);
  template <typename U>
  tmat4x2<T>& operator+= (tmat4x2<U> const & m);
  template <typename U>
  tmat4x2<T>& operator-= (U const & s);
  template <typename U>
  tmat4x2<T>& operator-= (tmat4x2<U> const & m);
  template <typename U>
  tmat4x2<T>& operator*= (U const & s);
  template <typename U>
  tmat4x2<T>& operator*= (tmat4x2<U> const & m);
  template <typename U>
  tmat4x2<T>& operator/= (U const & s);

  tmat4x2<T>& operator++ ();
  tmat4x2<T>& operator-- ();
 };


 template <typename T>
 tmat4x2<T> operator+ (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator+ (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat4x2<T> operator- (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator- (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator* (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m);

 template <typename T>
 typename tmat4x2<T>::col_type operator* (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::row_type const & v);

 template <typename T>
 typename tmat4x2<T>::row_type operator* (
  typename tmat4x2<T>::col_type const & v,
  tmat4x2<T> const & m);

 template <typename T>
 tmat3x2<T> operator* (
  tmat4x2<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat4x2<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat2x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat4x2<T> operator/ (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator/ (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m);


 template <typename T>
 tmat4x2<T> const operator- (
  tmat4x2<T> const & m);

 template <typename T>
 tmat4x2<T> const operator-- (
  tmat4x2<T> const & m,
  int);

 template <typename T>
 tmat4x2<T> const operator++ (
  tmat4x2<T> const & m,
  int);

}
# 249 "/usr/include/sgct/glm/./core/type_mat4x2.hpp" 3 4
 typedef detail::tmat4x2<lowp_float> lowp_mat4x2;






 typedef detail::tmat4x2<mediump_float> mediump_mat4x2;






 typedef detail::tmat4x2<highp_float> highp_mat4x2;


}


# 1 "/usr/include/sgct/glm/./core/type_mat4x2.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat4x2.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat4x2<T>::size_type tmat4x2<T>::length() const
    {
        return 4;
    }

 template <typename T>
 inline typename tmat4x2<T>::size_type tmat4x2<T>::col_size()
 {
  return 2;
 }

 template <typename T>
 inline typename tmat4x2<T>::size_type tmat4x2<T>::row_size()
 {
  return 4;
 }




 template <typename T>
 inline typename tmat4x2<T>::col_type &
 tmat4x2<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat4x2.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat4x2<T>::col_type const &
 tmat4x2<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat4x2.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat4x2<T>::tmat4x2()
    {
  value_type const Zero(0);
  value_type const One(1);
        this->value[0] = col_type(One, Zero);
        this->value[1] = col_type(Zero, One);
        this->value[2] = col_type(Zero, Zero);
        this->value[3] = col_type(Zero, Zero);
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
        this->value[2] = m.value[2];
        this->value[3] = m.value[3];
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  value_type const & s
 )
    {
  value_type const Zero(0);
        this->value[0] = col_type(s, Zero);
        this->value[1] = col_type(Zero, s);
        this->value[2] = col_type(Zero, Zero);
        this->value[3] = col_type(Zero, Zero);
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
    (
        value_type const & x0, value_type const & y0,
        value_type const & x1, value_type const & y1,
        value_type const & x2, value_type const & y2,
        value_type const & x3, value_type const & y3
    )
    {
        this->value[0] = col_type(x0, y0);
        this->value[1] = col_type(x1, y1);
        this->value[2] = col_type(x2, y2);
        this->value[3] = col_type(x3, y3);
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
    (
        col_type const & v0,
        col_type const & v1,
        col_type const & v2,
        col_type const & v3
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
        this->value[2] = v2;
        this->value[3] = v3;
    }



 template <typename T>
 template <typename U>
 tmat4x2<T>::tmat4x2
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec2<T>(value_type(s), Zero);
        this->value[1] = tvec2<T>(Zero, value_type(s));
        this->value[2] = tvec2<T>(Zero, Zero);
        this->value[3] = tvec2<T>(Zero, Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3,
  typename X4, typename Y4>
 tmat4x2<T>::tmat4x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3,
  X4 const & x4, Y4 const & y4
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1));
        this->value[1] = col_type(value_type(x2), value_type(y2));
        this->value[2] = col_type(value_type(x3), value_type(y3));
  this->value[3] = col_type(value_type(x4), value_type(y4));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3, typename V4>
 tmat4x2<T>::tmat4x2
 (
  tvec2<V1> const & v1,
  tvec2<V2> const & v2,
  tvec2<V3> const & v3,
  tvec2<V4> const & v4
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
        this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }


    template <typename T>
    template <typename U>
    inline tmat4x2<T>::tmat4x2
 (
  tmat4x2<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(m[3]);
 }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(value_type(0));
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(m[3]);
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(value_type(0));
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(value_type(0));
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(m[3]);
    }

    template <typename T>
    inline tmat4x2<T>::tmat4x2
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(value_type(0));
    }




    template <typename T>
    inline tmat4x2<T>& tmat4x2<T>::operator=
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        this->value[3] = m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T>& tmat4x2<T>::operator=
 (
  tmat4x2<U> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        this->value[3] = m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T> & tmat4x2<T>::operator+=
 (
  U const & s
 )
    {
        this->value[0] += s;
        this->value[1] += s;
        this->value[2] += s;
        this->value[3] += s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T> & tmat4x2<T>::operator+=
 (
  tmat4x2<U> const & m
 )
    {
        this->value[0] += m[0];
        this->value[1] += m[1];
        this->value[2] += m[2];
        this->value[3] += m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T> & tmat4x2<T>::operator-=
 (
  U const & s
 )
    {
        this->value[0] -= s;
        this->value[1] -= s;
        this->value[2] -= s;
        this->value[3] -= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T> & tmat4x2<T>::operator-=
 (
  tmat4x2<U> const & m
 )
    {
        this->value[0] -= m[0];
        this->value[1] -= m[1];
        this->value[2] -= m[2];
        this->value[3] -= m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T> & tmat4x2<T>::operator*=
 (
  U const & s
 )
    {
        this->value[0] *= s;
        this->value[1] *= s;
        this->value[2] *= s;
        this->value[3] *= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T> & tmat4x2<T>::operator*=
 (
  tmat4x2<U> const & m
 )
    {
        return (*this = tmat4x2<T>(*this * m));
    }

    template <typename T>
 template <typename U>
    inline tmat4x2<T> & tmat4x2<T>::operator/=
 (
  U const & s
 )
    {
        this->value[0] /= s;
        this->value[1] /= s;
        this->value[2] /= s;
        this->value[3] /= s;
        return *this;
    }

    template <typename T>
    inline tmat4x2<T> & tmat4x2<T>::operator++ ()
    {
        ++this->value[0];
        ++this->value[1];
        ++this->value[2];
        ++this->value[3];
        return *this;
    }

    template <typename T>
    inline tmat4x2<T> & tmat4x2<T>::operator-- ()
    {
        --this->value[0];
        --this->value[1];
        --this->value[2];
        --this->value[3];
        return *this;
    }




    template <typename T>
    inline tmat4x2<T> operator+
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
    {
        return tmat4x2<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s,
            m[3] + s);
    }

    template <typename T>
    inline tmat4x2<T> operator+
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
    {
        return tmat4x2<T>(
            m1[0] + m2[0],
            m1[1] + m2[1],
            m1[2] + m2[2],
            m1[3] + m2[3]);
    }

    template <typename T>
    inline tmat4x2<T> operator-
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
    {
        return tmat4x2<T>(
            m[0] - s,
            m[1] - s,
            m[2] - s,
            m[3] - s);
    }

    template <typename T>
    inline tmat4x2<T> operator-
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
    {
        return tmat4x2<T>(
            m1[0] - m2[0],
            m1[1] - m2[1],
            m1[2] - m2[2],
            m1[3] - m2[3]);
    }

    template <typename T>
    inline tmat4x2<T> operator*
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
    {
        return tmat4x2<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s,
            m[3] * s);
    }

    template <typename T>
    inline tmat4x2<T> operator*
 (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m
 )
    {
        return tmat4x2<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s,
            m[3] * s);
    }

    template <typename T>
    inline typename tmat4x2<T>::col_type operator*
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::row_type const & v)
    {
        return typename tmat4x2<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
            m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
    }

    template <typename T>
    inline typename tmat4x2<T>::row_type operator*
 (
  typename tmat4x2<T>::col_type const & v,
  tmat4x2<T> const & m)
    {
        return typename tmat4x2<T>::row_type(
            v.x * m[0][0] + v.y * m[0][1],
            v.x * m[1][0] + v.y * m[1][1],
            v.x * m[2][0] + v.y * m[2][1],
            v.x * m[3][0] + v.y * m[3][1]);
    }

    template <typename T>
    inline tmat2x2<T> operator*
 (
  tmat4x2<T> const & m1,
  tmat2x4<T> const & m2
 )
    {
        T const SrcA00 = m1[0][0];
        T const SrcA01 = m1[0][1];
        T const SrcA10 = m1[1][0];
        T const SrcA11 = m1[1][1];
        T const SrcA20 = m1[2][0];
        T const SrcA21 = m1[2][1];
        T const SrcA30 = m1[3][0];
        T const SrcA31 = m1[3][1];

        T const SrcB00 = m2[0][0];
        T const SrcB01 = m2[0][1];
        T const SrcB02 = m2[0][2];
        T const SrcB03 = m2[0][3];
        T const SrcB10 = m2[1][0];
        T const SrcB11 = m2[1][1];
        T const SrcB12 = m2[1][2];
        T const SrcB13 = m2[1][3];

        tmat2x2<T> Result(tmat2x2<T>::null);
        Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
        Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
        Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
        Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
        return Result;
    }

 template <typename T>
 inline tmat3x2<T> operator*
 (
  tmat4x2<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template <typename T>
 inline tmat4x2<T> operator*
 (
  tmat4x2<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

    template <typename T>
    inline tmat4x2<T> operator/
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
    {
        return tmat4x2<T>(
            m[0] / s,
            m[1] / s,
            m[2] / s,
            m[3] / s);
    }

    template <typename T>
    inline tmat4x2<T> operator/
 (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m
 )
    {
        return tmat4x2<T>(
            s / m[0],
            s / m[1],
            s / m[2],
            s / m[3]);
    }


    template <typename T>
    inline tmat4x2<T> const operator-
 (
  tmat4x2<T> const & m
 )
    {
        return tmat4x2<T>(
            -m[0],
            -m[1],
            -m[2],
            -m[3]);
    }

    template <typename T>
    inline tmat4x2<T> const operator++
 (
  tmat4x2<T> const & m,
  int
 )
    {
        return tmat4x2<T>(
   m[0] + typename tmat4x2<T>::value_type(1),
            m[1] + typename tmat4x2<T>::value_type(1),
            m[2] + typename tmat4x2<T>::value_type(1),
            m[3] + typename tmat4x2<T>::value_type(1));
    }

    template <typename T>
    inline tmat4x2<T> const operator--
 (
  tmat4x2<T> const & m,
  int
 )
    {
        return tmat4x2<T>(
            m[0] - typename tmat4x2<T>::value_type(1),
            m[1] - typename tmat4x2<T>::value_type(1),
            m[2] - typename tmat4x2<T>::value_type(1),
            m[3] - typename tmat4x2<T>::value_type(1));
    }




 template <typename T>
 inline bool operator==
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }

}
}
# 270 "/usr/include/sgct/glm/./core/type_mat4x2.hpp" 2 3 4
# 50 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat4x3.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat4x3.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat4x3
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T> col_type;
  typedef tvec4<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat4x3<T> type;
  typedef tmat3x4<T> transpose_type;

 private:

  col_type value[4];

 public:

  tmat4x3();
  tmat4x3(tmat4x3 const & m);

  explicit tmat4x3(
   ctor Null);
  explicit tmat4x3(
   value_type const & x);
  explicit tmat4x3(
   value_type const & x0, value_type const & y0, value_type const & z0,
   value_type const & x1, value_type const & y1, value_type const & z1,
   value_type const & x2, value_type const & y2, value_type const & z2,
   value_type const & x3, value_type const & y3, value_type const & z3);
  explicit tmat4x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
            col_type const & v3);



  template <typename U>
  explicit tmat4x3(
            U const & x);

  template <
            typename X1, typename Y1, typename Z1,
            typename X2, typename Y2, typename Z2,
            typename X3, typename Y3, typename Z3,
            typename X4, typename Y4, typename Z4>
  explicit tmat4x3(
            X1 const & x1, Y1 const & y1, Z1 const & z1,
            X2 const & x2, Y2 const & y2, Z2 const & z2,
            X3 const & x3, Y3 const & y3, Z3 const & z3,
            X4 const & x4, Y4 const & y4, Z4 const & z4);

  template <typename V1, typename V2, typename V3, typename V4>
  explicit tmat4x3(
            tvec3<V1> const & v1,
            tvec3<V2> const & v2,
            tvec3<V3> const & v3,
            tvec3<V4> const & v4);


  template <typename U>
  explicit tmat4x3(tmat4x3<U> const & m);

  explicit tmat4x3(tmat2x2<T> const & x);
  explicit tmat4x3(tmat3x3<T> const & x);
  explicit tmat4x3(tmat4x4<T> const & x);
  explicit tmat4x3(tmat2x3<T> const & x);
  explicit tmat4x3(tmat3x2<T> const & x);
  explicit tmat4x3(tmat2x4<T> const & x);
  explicit tmat4x3(tmat4x2<T> const & x);
  explicit tmat4x3(tmat3x4<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat4x3<T> & operator= (tmat4x3<T> const & m);
  template <typename U>
  tmat4x3<T> & operator= (tmat4x3<U> const & m);
  template <typename U>
  tmat4x3<T> & operator+= (U const & s);
  template <typename U>
  tmat4x3<T> & operator+= (tmat4x3<U> const & m);
  template <typename U>
  tmat4x3<T> & operator-= (U const & s);
  template <typename U>
  tmat4x3<T> & operator-= (tmat4x3<U> const & m);
  template <typename U>
  tmat4x3<T> & operator*= (U const & s);
  template <typename U>
  tmat4x3<T> & operator*= (tmat4x3<U> const & m);
  template <typename U>
  tmat4x3<T> & operator/= (U const & s);

  tmat4x3<T> & operator++ ();
  tmat4x3<T> & operator-- ();
 };


 template <typename T>
 tmat4x3<T> operator+ (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator+ (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat4x3<T> operator- (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator- (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator* (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m);

 template <typename T>
 typename tmat4x3<T>::col_type operator* (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::row_type const & v);

 template <typename T>
 typename tmat4x3<T>::row_type operator* (
  typename tmat4x3<T>::col_type const & v,
  tmat4x3<T> const & m);

 template <typename T>
 tmat2x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat3x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x3<T> operator/ (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator/ (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m);


 template <typename T>
 tmat4x3<T> const operator- (
  tmat4x3<T> const & m);

 template <typename T>
 tmat4x3<T> const operator-- (
  tmat4x3<T> const & m,
  int);

 template <typename T>
 tmat4x3<T> const operator++ (
  tmat4x3<T> const & m,
  int);

}
# 247 "/usr/include/sgct/glm/./core/type_mat4x3.hpp" 3 4
 typedef detail::tmat4x3<lowp_float> lowp_mat4x3;






 typedef detail::tmat4x3<mediump_float> mediump_mat4x3;






 typedef detail::tmat4x3<highp_float> highp_mat4x3;


}


# 1 "/usr/include/sgct/glm/./core/type_mat4x3.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat4x3.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat4x3<T>::size_type tmat4x3<T>::length() const
    {
        return 4;
    }

 template <typename T>
 inline typename tmat4x3<T>::size_type tmat4x3<T>::col_size()
 {
  return 3;
 }

 template <typename T>
 inline typename tmat4x3<T>::size_type tmat4x3<T>::row_size()
 {
  return 4;
 }




 template <typename T>
 inline typename tmat4x3<T>::col_type &
 tmat4x3<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat4x3.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat4x3<T>::col_type const &
 tmat4x3<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat4x3.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat4x3<T>::tmat4x3()
    {
  value_type const Zero(0);
  value_type const One(1);
        this->value[0] = col_type(One, Zero, Zero);
        this->value[1] = col_type(Zero, One, Zero);
        this->value[2] = col_type(Zero, Zero, One);
        this->value[3] = col_type(Zero, Zero, Zero);
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
        this->value[2] = m.value[2];
        this->value[3] = m.value[3];
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  value_type const & s
 )
    {
  value_type const Zero(0);
        this->value[0] = col_type(s, Zero, Zero);
        this->value[1] = col_type(Zero, s, Zero);
        this->value[2] = col_type(Zero, Zero, s);
        this->value[3] = col_type(Zero, Zero, Zero);
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
    (
        value_type const & x0, value_type const & y0, value_type const & z0,
        value_type const & x1, value_type const & y1, value_type const & z1,
        value_type const & x2, value_type const & y2, value_type const & z2,
        value_type const & x3, value_type const & y3, value_type const & z3
    )
    {
        this->value[0] = col_type(x0, y0, z0);
        this->value[1] = col_type(x1, y1, z1);
        this->value[2] = col_type(x2, y2, z2);
        this->value[3] = col_type(x3, y3, z3);
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
    (
        col_type const & v0,
        col_type const & v1,
        col_type const & v2,
        col_type const & v3
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
        this->value[2] = v2;
        this->value[3] = v3;
    }



 template <typename T>
 template <typename U>
 tmat4x3<T>::tmat4x3
 (
  U const & s
 )
 {
  value_type const Zero(0);
        this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
        this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
        this->value[2] = tvec3<T>(Zero, Zero, value_type(s));
        this->value[3] = tvec3<T>(Zero, Zero, Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3,
  typename X4, typename Y4, typename Z4>
 tmat4x3<T>::tmat4x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3,
  X4 const & x4, Y4 const & y4, Z4 const & z4
 )
 {
        this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
        this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
        this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3));
  this->value[3] = col_type(value_type(x4), value_type(y4), value_type(z4));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3, typename V4>
 tmat4x3<T>::tmat4x3
 (
  tvec3<V1> const & v1,
  tvec3<V2> const & v2,
  tvec3<V3> const & v3,
  tvec3<V4> const & v4
 )
 {
        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
        this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }




    template <typename T>
    template <typename U>
    inline tmat4x3<T>::tmat4x3
 (
  tmat4x3<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(m[3]);
 }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(m[2], value_type(1));
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(m[3]);
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(value_type(0), value_type(0), value_type(1));
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(m[2], value_type(1));
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(value_type(0), value_type(0), value_type(1));
        this->value[3] = col_type(value_type(0));
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(m[2], value_type(1));
        this->value[3] = col_type(m[3], value_type(0));
    }

    template <typename T>
    inline tmat4x3<T>::tmat4x3
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(value_type(0));
    }




 template <typename T>
    inline tmat4x3<T>& tmat4x3<T>::operator=
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        this->value[3] = m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T>& tmat4x3<T>::operator=
 (
  tmat4x3<U> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        this->value[3] = m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T> & tmat4x3<T>::operator+=
 (
  U const & s
 )
    {
        this->value[0] += s;
        this->value[1] += s;
        this->value[2] += s;
        this->value[3] += s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T> & tmat4x3<T>::operator+=
 (
  tmat4x3<U> const & m
 )
    {
        this->value[0] += m[0];
        this->value[1] += m[1];
        this->value[2] += m[2];
        this->value[3] += m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T> & tmat4x3<T>::operator-=
 (
  U const & s
 )
    {
        this->value[0] -= s;
        this->value[1] -= s;
        this->value[2] -= s;
        this->value[3] -= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T> & tmat4x3<T>::operator-=
 (
  tmat4x3<U> const & m
 )
    {
        this->value[0] -= m[0];
        this->value[1] -= m[1];
        this->value[2] -= m[2];
        this->value[3] -= m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T> & tmat4x3<T>::operator*=
 (
  U const & s
 )
    {
        this->value[0] *= s;
        this->value[1] *= s;
        this->value[2] *= s;
        this->value[3] *= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T> & tmat4x3<T>::operator*=
 (
  tmat4x3<U> const & m
 )
    {
        return (*this = tmat4x3<T>(*this * m));
    }

    template <typename T>
 template <typename U>
    inline tmat4x3<T> & tmat4x3<T>::operator/=
 (
  U const & s
 )
    {
        this->value[0] /= s;
        this->value[1] /= s;
        this->value[2] /= s;
        this->value[3] /= s;
        return *this;
    }

    template <typename T>
    inline tmat4x3<T> & tmat4x3<T>::operator++ ()
    {
        ++this->value[0];
        ++this->value[1];
        ++this->value[2];
        ++this->value[3];
        return *this;
    }

    template <typename T>
    inline tmat4x3<T> & tmat4x3<T>::operator-- ()
    {
        --this->value[0];
        --this->value[1];
        --this->value[2];
        --this->value[3];
        return *this;
    }




    template <typename T>
    inline tmat4x3<T> operator+ (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s)
    {
        return tmat4x3<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s,
            m[3] + s);
    }

    template <typename T>
    inline tmat4x3<T> operator+ (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2)
    {
        return tmat4x3<T>(
            m1[0] + m2[0],
            m1[1] + m2[1],
            m1[2] + m2[2],
            m1[3] + m2[3]);
    }

    template <typename T>
    inline tmat4x3<T> operator- (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s)
    {
        return tmat4x3<T>(
            m[0] - s,
            m[1] - s,
            m[2] - s,
            m[3] - s);
    }

    template <typename T>
    inline tmat4x3<T> operator- (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2)
    {
        return tmat4x3<T>(
            m1[0] - m2[0],
            m1[1] - m2[1],
            m1[2] - m2[2],
            m1[3] - m2[3]);
    }

    template <typename T>
    inline tmat4x3<T> operator* (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s)
    {
        return tmat4x3<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s,
            m[3] * s);
    }

    template <typename T>
    inline tmat4x3<T> operator* (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m)
    {
        return tmat4x3<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s,
            m[3] * s);
    }

    template <typename T>
    inline typename tmat4x3<T>::col_type operator*
 (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::row_type const & v)
    {
        return typename tmat4x3<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
            m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
            m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
    }

    template <typename T>
    inline typename tmat4x3<T>::row_type operator*
 (
  typename tmat4x3<T>::col_type const & v,
  tmat4x3<T> const & m)
    {
        return typename tmat4x3<T>::row_type(
            v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
            v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
            v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
            v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
    }

 template <typename T>
 inline tmat2x3<T> operator*
 (
  tmat4x3<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

    template <typename T>
    inline tmat3x3<T> operator*
 (
  tmat4x3<T> const & m1,
  tmat3x4<T> const & m2
 )
    {
        T const SrcA00 = m1[0][0];
        T const SrcA01 = m1[0][1];
        T const SrcA02 = m1[0][2];
        T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
        T const SrcA12 = m1[1][2];
        T const SrcA20 = m1[2][0];
        T const SrcA21 = m1[2][1];
        T const SrcA22 = m1[2][2];
        T const SrcA30 = m1[3][0];
        T const SrcA31 = m1[3][1];
        T const SrcA32 = m1[3][2];

        T const SrcB00 = m2[0][0];
        T const SrcB01 = m2[0][1];
        T const SrcB02 = m2[0][2];
        T const SrcB03 = m2[0][3];
        T const SrcB10 = m2[1][0];
        T const SrcB11 = m2[1][1];
        T const SrcB12 = m2[1][2];
        T const SrcB13 = m2[1][3];
        T const SrcB20 = m2[2][0];
        T const SrcB21 = m2[2][1];
        T const SrcB22 = m2[2][2];
        T const SrcB23 = m2[2][3];

        tmat3x3<T> Result(tmat3x3<T>::null);
        Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
        Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
        Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
        Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
        Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
        Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
        Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
        Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
        Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
        return Result;
    }

 template <typename T>
 inline tmat4x3<T> operator*
 (
  tmat4x3<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return tmat4x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

    template <typename T>
    inline tmat4x3<T> operator/
 (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s
 )
    {
        return tmat4x3<T>(
            m[0] / s,
            m[1] / s,
            m[2] / s,
            m[3] / s);
    }

    template <typename T>
    inline tmat4x3<T> operator/
 (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m
 )
    {
        return tmat4x3<T>(
            s / m[0],
            s / m[1],
            s / m[2],
            s / m[3]);
    }


    template <typename T>
    inline tmat4x3<T> const operator-
 (
  tmat4x3<T> const & m
 )
    {
        return tmat4x3<T>(
            -m[0],
            -m[1],
            -m[2],
            -m[3]);
    }

    template <typename T>
    inline tmat4x3<T> const operator++
 (
  tmat4x3<T> const & m,
  int
 )
    {
        return tmat4x3<T>(
            m[0] + T(1),
            m[1] + T(1),
            m[2] + T(1),
            m[3] + T(1));
    }

    template <typename T>
    inline tmat4x3<T> const operator--
 (
  tmat4x3<T> const & m,
  int
 )
    {
        return tmat4x3<T>(
            m[0] - T(1),
            m[1] - T(1),
            m[2] - T(1),
            m[3] - T(1));
    }




 template <typename T>
 inline bool operator==
 (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }

}
}
# 268 "/usr/include/sgct/glm/./core/type_mat4x3.hpp" 2 3 4
# 51 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/type_mat4x4.hpp" 1 3 4
# 34 "/usr/include/sgct/glm/./core/type_mat4x4.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;



 template <typename T>
 struct tmat4x4
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T> col_type;
  typedef tvec4<T> row_type;
        size_type length() const;
  static size_type col_size();
  static size_type row_size();

  typedef tmat4x4<T> type;
  typedef tmat4x4<T> transpose_type;

 public:


  tmat4x4<T> _inverse() const;


 private:

  col_type value[4];

 public:

  tmat4x4();
  tmat4x4(tmat4x4 const & m);

  explicit tmat4x4(
   ctor Null);
  explicit tmat4x4(
   value_type const & x);
  explicit tmat4x4(
   value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
   value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
   value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2,
   value_type const & x3, value_type const & y3, value_type const & z3, value_type const & w3);
  explicit tmat4x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <typename U>
  explicit tmat4x4(
            U const & x);

  template <
            typename X1, typename Y1, typename Z1, typename W1,
            typename X2, typename Y2, typename Z2, typename W2,
            typename X3, typename Y3, typename Z3, typename W3,
            typename X4, typename Y4, typename Z4, typename W4>
  explicit tmat4x4(
            X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
            X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
            X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
            X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

  template <typename V1, typename V2, typename V3, typename V4>
  explicit tmat4x4(
            tvec4<V1> const & v1,
            tvec4<V2> const & v2,
            tvec4<V3> const & v3,
            tvec4<V4> const & v4);


  template <typename U>
  explicit tmat4x4(tmat4x4<U> const & m);

  explicit tmat4x4(tmat2x2<T> const & x);
  explicit tmat4x4(tmat3x3<T> const & x);
  explicit tmat4x4(tmat2x3<T> const & x);
  explicit tmat4x4(tmat3x2<T> const & x);
  explicit tmat4x4(tmat2x4<T> const & x);
  explicit tmat4x4(tmat4x2<T> const & x);
  explicit tmat4x4(tmat3x4<T> const & x);
  explicit tmat4x4(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat4x4<T> & operator= (tmat4x4<T> const & m);
  template <typename U>
  tmat4x4<T> & operator= (tmat4x4<U> const & m);
  template <typename U>
  tmat4x4<T> & operator+= (U const & s);
  template <typename U>
  tmat4x4<T> & operator+= (tmat4x4<U> const & m);
  template <typename U>
  tmat4x4<T> & operator-= (U const & s);
  template <typename U>
  tmat4x4<T> & operator-= (tmat4x4<U> const & m);
  template <typename U>
  tmat4x4<T> & operator*= (U const & s);
  template <typename U>
  tmat4x4<T> & operator*= (tmat4x4<U> const & m);
  template <typename U>
  tmat4x4<T> & operator/= (U const & s);
  template <typename U>
  tmat4x4<T> & operator/= (tmat4x4<U> const & m);
  tmat4x4<T> & operator++ ();
  tmat4x4<T> & operator-- ();
 };


 template <typename T>
 tmat4x4<T> operator+ (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator+ (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator+ (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator- (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator- (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator- (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator* (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator* (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 typename tmat4x4<T>::col_type operator* (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v);

 template <typename T>
 typename tmat4x4<T>::row_type operator* (
  typename tmat4x4<T>::col_type const & v,
  tmat4x4<T> const & m);

 template <typename T>
 tmat2x4<T> operator* (
  tmat4x4<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat4x4<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator* (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator/ (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator/ (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 typename tmat4x4<T>::col_type operator/ (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v);

 template <typename T>
 typename tmat4x4<T>::row_type operator/ (
  typename tmat4x4<T>::col_type & v,
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator/ (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);


 template <typename T>
 tmat4x4<T> const operator- (
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> const operator-- (
  tmat4x4<T> const & m, int);

 template <typename T>
 tmat4x4<T> const operator++ (
  tmat4x4<T> const & m, int);

}
# 277 "/usr/include/sgct/glm/./core/type_mat4x4.hpp" 3 4
 typedef detail::tmat4x4<lowp_float> lowp_mat4;






 typedef detail::tmat4x4<mediump_float> mediump_mat4;






 typedef detail::tmat4x4<highp_float> highp_mat4;






 typedef detail::tmat4x4<lowp_float> lowp_mat4x4;






 typedef detail::tmat4x4<mediump_float> mediump_mat4x4;






 typedef detail::tmat4x4<highp_float> highp_mat4x4;


}


# 1 "/usr/include/sgct/glm/./core/type_mat4x4.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/type_mat4x4.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline typename tmat4x4<T>::size_type tmat4x4<T>::length() const
    {
        return 4;
    }

 template <typename T>
 inline typename tmat4x4<T>::size_type tmat4x4<T>::col_size()
 {
  return 4;
 }

 template <typename T>
 inline typename tmat4x4<T>::size_type tmat4x4<T>::row_size()
 {
  return 4;
 }




 template <typename T>
 inline typename tmat4x4<T>::col_type &
 tmat4x4<T>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat4x4.inl", 60, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T>
 inline typename tmat4x4<T>::col_type const &
 tmat4x4<T>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/sgct/glm/./core/type_mat4x4.inl", 71, __PRETTY_FUNCTION__));
  return this->value[i];
 }




    template <typename T>
    inline tmat4x4<T>::tmat4x4()
    {
  value_type Zero(0);
  value_type One(1);
        this->value[0] = col_type(One, Zero, Zero, Zero);
        this->value[1] = col_type(Zero, One, Zero, Zero);
        this->value[2] = col_type(Zero, Zero, One, Zero);
        this->value[3] = col_type(Zero, Zero, Zero, One);
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat4x4<T> const & m
 )
    {
        this->value[0] = m.value[0];
        this->value[1] = m.value[1];
        this->value[2] = m.value[2];
        this->value[3] = m.value[3];
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  ctor
 )
    {}

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  value_type const & s
 )
    {
  value_type const Zero(0);
        this->value[0] = col_type(s, Zero, Zero, Zero);
        this->value[1] = col_type(Zero, s, Zero, Zero);
        this->value[2] = col_type(Zero, Zero, s, Zero);
        this->value[3] = col_type(Zero, Zero, Zero, s);
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
    (
        value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
        value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
        value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2,
        value_type const & x3, value_type const & y3, value_type const & z3, value_type const & w3
    )
    {
        this->value[0] = col_type(x0, y0, z0, w0);
        this->value[1] = col_type(x1, y1, z1, w1);
        this->value[2] = col_type(x2, y2, z2, w2);
        this->value[3] = col_type(x3, y3, z3, w3);
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
    (
        col_type const & v0,
        col_type const & v1,
        col_type const & v2,
        col_type const & v3
    )
    {
        this->value[0] = v0;
        this->value[1] = v1;
        this->value[2] = v2;
        this->value[3] = v3;
    }

    template <typename T>
    template <typename U>
    inline tmat4x4<T>::tmat4x4
 (
  tmat4x4<U> const & m
 )
    {
        this->value[0] = col_type(m[0]);
        this->value[1] = col_type(m[1]);
        this->value[2] = col_type(m[2]);
        this->value[3] = col_type(m[3]);
 }



 template <typename T>
 template <typename U>
 tmat4x4<T>::tmat4x4
 (
  U const & s
 )
 {
  ;

  value_type const Zero(0);
        this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
        this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
        this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);
        this->value[3] = tvec4<T>(Zero, Zero, Zero, value_type(s));
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 tmat4x4<T>::tmat4x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
  X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
 )
 {
  ;
  ;
  ;
  ;

  ;
  ;
  ;
  ;

  ;
  ;
  ;
  ;

  ;
  ;
  ;
  ;

        this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
        this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
        this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3), value_type(w3));
  this->value[3] = col_type(value_type(x4), value_type(y4), value_type(z4), value_type(w4));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3, typename V4>
 tmat4x4<T>::tmat4x4
 (
  tvec4<V1> const & v1,
  tvec4<V2> const & v2,
  tvec4<V3> const & v3,
  tvec4<V4> const & v4
 )
 {
  ;
  ;
  ;
  ;

        this->value[0] = col_type(v1);
        this->value[1] = col_type(v2);
        this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat2x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(0));
        this->value[1] = col_type(m[1], detail::tvec2<T>(0));
        this->value[2] = col_type(value_type(0));
        this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat3x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(m[2], value_type(0));
        this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
    }

 template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat2x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], value_type(0));
        this->value[1] = col_type(m[1], value_type(0));
        this->value[2] = col_type(value_type(0));
        this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat3x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(0));
        this->value[1] = col_type(m[1], detail::tvec2<T>(0));
        this->value[2] = col_type(m[2], detail::tvec2<T>(0));
        this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat2x4<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = col_type(T(0));
        this->value[3] = col_type(T(0), T(0), T(0), T(1));
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat4x2<T> const & m
 )
    {
        this->value[0] = col_type(m[0], detail::tvec2<T>(0));
        this->value[1] = col_type(m[1], detail::tvec2<T>(0));
        this->value[2] = col_type(T(0));
        this->value[3] = col_type(T(0), T(0), T(0), T(1));
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat3x4<T> const & m
 )
    {
        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        this->value[3] = col_type(T(0), T(0), T(0), T(1));
    }

    template <typename T>
    inline tmat4x4<T>::tmat4x4
 (
  tmat4x3<T> const & m
 )
    {
        this->value[0] = col_type(m[0], T(0));
        this->value[1] = col_type(m[1], T(0));
        this->value[2] = col_type(m[2], T(0));
        this->value[3] = col_type(m[3], T(1));
    }




    template <typename T>
    inline tmat4x4<T>& tmat4x4<T>::operator=
 (
  tmat4x4<T> const & m
 )
    {


        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        this->value[3] = m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T>& tmat4x4<T>::operator=
 (
  tmat4x4<U> const & m
 )
    {


        this->value[0] = m[0];
        this->value[1] = m[1];
        this->value[2] = m[2];
        this->value[3] = m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T>& tmat4x4<T>::operator+=
 (
  U const & s
 )
    {
        this->value[0] += s;
        this->value[1] += s;
        this->value[2] += s;
        this->value[3] += s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T>& tmat4x4<T>::operator+=
 (
  tmat4x4<U> const & m
 )
    {
        this->value[0] += m[0];
        this->value[1] += m[1];
        this->value[2] += m[2];
        this->value[3] += m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T> & tmat4x4<T>::operator-=
 (
  U const & s
 )
    {
        this->value[0] -= s;
        this->value[1] -= s;
        this->value[2] -= s;
        this->value[3] -= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T> & tmat4x4<T>::operator-=
 (
  tmat4x4<U> const & m
 )
    {
        this->value[0] -= m[0];
        this->value[1] -= m[1];
        this->value[2] -= m[2];
        this->value[3] -= m[3];
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T> & tmat4x4<T>::operator*=
 (
  U const & s
 )
    {
        this->value[0] *= s;
        this->value[1] *= s;
        this->value[2] *= s;
        this->value[3] *= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T> & tmat4x4<T>::operator*=
 (
  tmat4x4<U> const & m
 )
    {
        return (*this = *this * m);
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T> & tmat4x4<T>::operator/=
 (
  U const & s
 )
    {
        this->value[0] /= s;
        this->value[1] /= s;
        this->value[2] /= s;
        this->value[3] /= s;
        return *this;
    }

    template <typename T>
 template <typename U>
    inline tmat4x4<T> & tmat4x4<T>::operator/=
 (
  tmat4x4<U> const & m
 )
    {
        return (*this = *this / m);
    }

    template <typename T>
    inline tmat4x4<T> & tmat4x4<T>::operator++ ()
    {
        ++this->value[0];
        ++this->value[1];
        ++this->value[2];
        ++this->value[3];
        return *this;
    }

    template <typename T>
    inline tmat4x4<T> & tmat4x4<T>::operator-- ()
    {
        --this->value[0];
        --this->value[1];
        --this->value[2];
        --this->value[3];
        return *this;
    }

    template <typename T>
    inline tmat4x4<T> tmat4x4<T>::_inverse() const
    {

        value_type SubFactor00 = this->value[2][2] * this->value[3][3] - this->value[3][2] * this->value[2][3];
        value_type SubFactor01 = this->value[2][1] * this->value[3][3] - this->value[3][1] * this->value[2][3];
        value_type SubFactor02 = this->value[2][1] * this->value[3][2] - this->value[3][1] * this->value[2][2];
        value_type SubFactor03 = this->value[2][0] * this->value[3][3] - this->value[3][0] * this->value[2][3];
        value_type SubFactor04 = this->value[2][0] * this->value[3][2] - this->value[3][0] * this->value[2][2];
        value_type SubFactor05 = this->value[2][0] * this->value[3][1] - this->value[3][0] * this->value[2][1];
        value_type SubFactor06 = this->value[1][2] * this->value[3][3] - this->value[3][2] * this->value[1][3];
        value_type SubFactor07 = this->value[1][1] * this->value[3][3] - this->value[3][1] * this->value[1][3];
        value_type SubFactor08 = this->value[1][1] * this->value[3][2] - this->value[3][1] * this->value[1][2];
        value_type SubFactor09 = this->value[1][0] * this->value[3][3] - this->value[3][0] * this->value[1][3];
        value_type SubFactor10 = this->value[1][0] * this->value[3][2] - this->value[3][0] * this->value[1][2];
        value_type SubFactor11 = this->value[1][1] * this->value[3][3] - this->value[3][1] * this->value[1][3];
        value_type SubFactor12 = this->value[1][0] * this->value[3][1] - this->value[3][0] * this->value[1][1];
        value_type SubFactor13 = this->value[1][2] * this->value[2][3] - this->value[2][2] * this->value[1][3];
        value_type SubFactor14 = this->value[1][1] * this->value[2][3] - this->value[2][1] * this->value[1][3];
        value_type SubFactor15 = this->value[1][1] * this->value[2][2] - this->value[2][1] * this->value[1][2];
        value_type SubFactor16 = this->value[1][0] * this->value[2][3] - this->value[2][0] * this->value[1][3];
        value_type SubFactor17 = this->value[1][0] * this->value[2][2] - this->value[2][0] * this->value[1][2];
        value_type SubFactor18 = this->value[1][0] * this->value[2][1] - this->value[2][0] * this->value[1][1];
# 544 "/usr/include/sgct/glm/./core/type_mat4x4.inl" 3 4
        tmat4x4<T> Inverse(
            + this->value[1][1] * SubFactor00 - this->value[1][2] * SubFactor01 + this->value[1][3] * SubFactor02,
            - this->value[1][0] * SubFactor00 + this->value[1][2] * SubFactor03 - this->value[1][3] * SubFactor04,
            + this->value[1][0] * SubFactor01 - this->value[1][1] * SubFactor03 + this->value[1][3] * SubFactor05,
            - this->value[1][0] * SubFactor02 + this->value[1][1] * SubFactor04 - this->value[1][2] * SubFactor05,

            - this->value[0][1] * SubFactor00 + this->value[0][2] * SubFactor01 - this->value[0][3] * SubFactor02,
            + this->value[0][0] * SubFactor00 - this->value[0][2] * SubFactor03 + this->value[0][3] * SubFactor04,
            - this->value[0][0] * SubFactor01 + this->value[0][1] * SubFactor03 - this->value[0][3] * SubFactor05,
            + this->value[0][0] * SubFactor02 - this->value[0][1] * SubFactor04 + this->value[0][2] * SubFactor05,

            + this->value[0][1] * SubFactor06 - this->value[0][2] * SubFactor07 + this->value[0][3] * SubFactor08,
            - this->value[0][0] * SubFactor06 + this->value[0][2] * SubFactor09 - this->value[0][3] * SubFactor10,
            + this->value[0][0] * SubFactor11 - this->value[0][1] * SubFactor09 + this->value[0][3] * SubFactor12,
            - this->value[0][0] * SubFactor08 + this->value[0][1] * SubFactor10 - this->value[0][2] * SubFactor12,

            - this->value[0][1] * SubFactor13 + this->value[0][2] * SubFactor14 - this->value[0][3] * SubFactor15,
            + this->value[0][0] * SubFactor13 - this->value[0][2] * SubFactor16 + this->value[0][3] * SubFactor17,
            - this->value[0][0] * SubFactor14 + this->value[0][1] * SubFactor16 - this->value[0][3] * SubFactor18,
            + this->value[0][0] * SubFactor15 - this->value[0][1] * SubFactor17 + this->value[0][2] * SubFactor18);

        value_type Determinant =
   + this->value[0][0] * Inverse[0][0]
   + this->value[0][1] * Inverse[1][0]
   + this->value[0][2] * Inverse[2][0]
   + this->value[0][3] * Inverse[3][0];

        Inverse /= Determinant;
        return Inverse;
    }


    template <typename T>
    inline tmat4x4<T> operator+
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
    {
        return tmat4x4<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s,
            m[3] + s);
    }

    template <typename T>
    inline tmat4x4<T> operator+
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
    {
        return tmat4x4<T>(
            m[0] + s,
            m[1] + s,
            m[2] + s,
            m[3] + s);
    }

    template <typename T>
    inline tmat4x4<T> operator+
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
    {
        return tmat4x4<T>(
            m1[0] + m2[0],
            m1[1] + m2[1],
            m1[2] + m2[2],
            m1[3] + m2[3]);
    }

    template <typename T>
    inline tmat4x4<T> operator-
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
    {
        return tmat4x4<T>(
            m[0] - s,
            m[1] - s,
            m[2] - s,
            m[3] - s);
    }

    template <typename T>
    inline tmat4x4<T> operator-
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
    {
        return tmat4x4<T>(
            s - m[0],
            s - m[1],
            s - m[2],
            s - m[3]);
    }

    template <typename T>
    inline tmat4x4<T> operator-
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
    {
        return tmat4x4<T>(
            m1[0] - m2[0],
            m1[1] - m2[1],
            m1[2] - m2[2],
            m1[3] - m2[3]);
    }

    template <typename T>
    inline tmat4x4<T> operator*
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
    {
        return tmat4x4<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s,
            m[3] * s);
    }

    template <typename T>
    inline tmat4x4<T> operator*
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
    {
        return tmat4x4<T>(
            m[0] * s,
            m[1] * s,
            m[2] * s,
            m[3] * s);
    }

    template <typename T>
    inline typename tmat4x4<T>::col_type operator*
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v
 )
    {
        return typename tmat4x4<T>::col_type(
            m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
            m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
            m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w,
            m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z + m[3][3] * v.w);
    }

    template <typename T>
    inline typename tmat4x4<T>::row_type operator*
 (
  typename tmat4x4<T>::col_type const & v,
  tmat4x4<T> const & m
 )
    {
        return typename tmat4x4<T>::row_type(
            m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,
            m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
            m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
            m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w);
    }

 template <typename T>
 inline tmat2x4<T> operator*
 (
  tmat4x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template <typename T>
 inline tmat3x4<T> operator*
 (
  tmat4x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

    template <typename T>
    inline tmat4x4<T> operator*
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
    {
  typename tmat4x4<T>::col_type const SrcA0 = m1[0];
  typename tmat4x4<T>::col_type const SrcA1 = m1[1];
  typename tmat4x4<T>::col_type const SrcA2 = m1[2];
  typename tmat4x4<T>::col_type const SrcA3 = m1[3];

  typename tmat4x4<T>::col_type const SrcB0 = m2[0];
  typename tmat4x4<T>::col_type const SrcB1 = m2[1];
  typename tmat4x4<T>::col_type const SrcB2 = m2[2];
  typename tmat4x4<T>::col_type const SrcB3 = m2[3];

        tmat4x4<T> Result(tmat4x4<T>::null);
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
        return Result;
    }

    template <typename T>
    inline tmat4x4<T> operator/
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
    {
        return tmat4x4<T>(
            m[0] / s,
            m[1] / s,
            m[2] / s,
            m[3] / s);
    }

    template <typename T>
    inline tmat4x4<T> operator/
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
    {
        return tmat4x4<T>(
            s / m[0],
            s / m[1],
            s / m[2],
            s / m[3]);
    }

    template <typename T>
    inline typename tmat4x4<T>::col_type operator/
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v
 )
    {
        return m._inverse() * v;
    }

    template <typename T>
    inline typename tmat4x4<T>::row_type operator/
 (
  typename tmat4x4<T>::col_type const & v,
  tmat4x4<T> const & m
 )
    {
        return v * m._inverse();
    }

    template <typename T>
    inline tmat4x4<T> operator/
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
    {
        return m1 * m2._inverse();
    }


    template <typename T>
    inline tmat4x4<T> const operator-
 (
  tmat4x4<T> const & m
 )
    {
        return tmat4x4<T>(
            -m[0],
            -m[1],
            -m[2],
            -m[3]);
    }

    template <typename T>
    inline tmat4x4<T> const operator++
 (
  tmat4x4<T> const & m,
  int
 )
    {
        return tmat4x4<T>(
            m[0] + typename tmat4x4<T>::value_type(1),
            m[1] + typename tmat4x4<T>::value_type(1),
            m[2] + typename tmat4x4<T>::value_type(1),
            m[3] + typename tmat4x4<T>::value_type(1));
    }

    template <typename T>
    inline tmat4x4<T> const operator--
 (
  tmat4x4<T> const & m,
  int
 )
    {
        return tmat4x4<T>(
            m[0] - typename tmat4x4<T>::value_type(1),
            m[1] - typename tmat4x4<T>::value_type(1),
            m[2] - typename tmat4x4<T>::value_type(1),
            m[3] - typename tmat4x4<T>::value_type(1));
    }




 template <typename T>
 inline bool operator==
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T>
 inline bool operator!=
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }

}
}
# 319 "/usr/include/sgct/glm/./core/type_mat4x4.hpp" 2 3 4
# 52 "/usr/include/sgct/glm/./core/type.hpp" 2 3 4

namespace glm
{
# 104 "/usr/include/sgct/glm/./core/type.hpp" 3 4
 typedef mediump_vec2 vec2;




 typedef mediump_vec3 vec3;




 typedef mediump_vec4 vec4;




 typedef mediump_mat2x2 mat2x2;




 typedef mediump_mat2x3 mat2x3;




 typedef mediump_mat2x4 mat2x4;




 typedef mediump_mat3x2 mat3x2;




 typedef mediump_mat3x3 mat3x3;




 typedef mediump_mat3x4 mat3x4;




 typedef mediump_mat4x2 mat4x2;




 typedef mediump_mat4x3 mat4x3;




 typedef mediump_mat4x4 mat4x4;






 typedef mat2x2 mat2;




 typedef mat3x3 mat3;




 typedef mat4x4 mat4;
# 197 "/usr/include/sgct/glm/./core/type.hpp" 3 4
 typedef mediump_ivec2 ivec2;




 typedef mediump_ivec3 ivec3;




 typedef mediump_ivec4 ivec4;
# 229 "/usr/include/sgct/glm/./core/type.hpp" 3 4
 typedef mediump_uvec2 uvec2;




 typedef mediump_uvec3 uvec3;




 typedef mediump_uvec4 uvec4;
# 248 "/usr/include/sgct/glm/./core/type.hpp" 3 4
 typedef detail::tvec2<bool> bvec2;




 typedef detail::tvec3<bool> bvec3;




 typedef detail::tvec4<bool> bvec4;







 typedef detail::tvec2<double> dvec2;




 typedef detail::tvec3<double> dvec3;




 typedef detail::tvec4<double> dvec4;




 typedef detail::tmat2x2<double> dmat2;




 typedef detail::tmat3x3<double> dmat3;




 typedef detail::tmat4x4<double> dmat4;




 typedef detail::tmat2x2<double> dmat2x2;




 typedef detail::tmat2x3<double> dmat2x3;




 typedef detail::tmat2x4<double> dmat2x4;




 typedef detail::tmat3x2<double> dmat3x2;




 typedef detail::tmat3x3<double> dmat3x3;




 typedef detail::tmat3x4<double> dmat3x4;




 typedef detail::tmat4x2<double> dmat4x2;




 typedef detail::tmat4x3<double> dmat4x3;




 typedef detail::tmat4x4<double> dmat4x4;


}
# 98 "/usr/include/sgct/glm/glm.hpp" 2 3 4

# 1 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 1 3 4
# 43 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
namespace glm
{
# 54 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType radians(genType const & degrees);







 template <typename genType>
 genType degrees(genType const & radians);
# 73 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType sin(genType const & angle);
# 83 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType cos(genType const & angle);







 template <typename genType>
 genType tan(genType const & angle);
# 103 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType asin(genType const & x);
# 114 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType acos(genType const & x);
# 127 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType atan(genType const & y, genType const & x);
# 137 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType atan(genType const & y_over_x);







 template <typename genType>
 genType sinh(genType const & angle);







 template <typename genType>
 genType cosh(genType const & angle);







 template <typename genType>
 genType tanh(genType const & angle);







 template <typename genType>
 genType asinh(genType const & x);
# 183 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType acosh(genType const & x);
# 193 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType atanh(genType const & x);


}

# 1 "/usr/include/sgct/glm/./core/func_trigonometric.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_trigonometric.inl" 3 4
# 1 "/usr/include/sgct/glm/./core/_vectorize.hpp" 1 3 4
# 30 "/usr/include/sgct/glm/./core/func_trigonometric.inl" 2 3 4

namespace glm
{

 template <typename genType>
 inline genType radians
 (
  genType const & degrees
 )
 {
  ;

  genType const pi = genType(3.1415926535897932384626433832795);
  return degrees * (pi / genType(180));
 }

 template <typename T> inline detail::tvec2<T> radians( detail::tvec2<T> const & v) { return detail::tvec2<T>( radians(v.x), radians(v.y)); } template <typename T> inline detail::tvec3<T> radians( detail::tvec3<T> const & v) { return detail::tvec3<T>( radians(v.x), radians(v.y), radians(v.z)); } template <typename T> inline detail::tvec4<T> radians( detail::tvec4<T> const & v) { return detail::tvec4<T>( radians(v.x), radians(v.y), radians(v.z), radians(v.w)); }


 template <typename genType>
 inline genType degrees
 (
  genType const & radians
 )
 {
  ;

  const genType pi = genType(3.1415926535897932384626433832795);
  return radians * (genType(180) / pi);
 }

 template <typename T> inline detail::tvec2<T> degrees( detail::tvec2<T> const & v) { return detail::tvec2<T>( degrees(v.x), degrees(v.y)); } template <typename T> inline detail::tvec3<T> degrees( detail::tvec3<T> const & v) { return detail::tvec3<T>( degrees(v.x), degrees(v.y), degrees(v.z)); } template <typename T> inline detail::tvec4<T> degrees( detail::tvec4<T> const & v) { return detail::tvec4<T>( degrees(v.x), degrees(v.y), degrees(v.z), degrees(v.w)); }


 template <typename genType>
 inline genType sin
 (
  genType const & angle
 )
 {
  ;

  return ::std::sin(angle);
 }

 template <typename T> inline detail::tvec2<T> sin( detail::tvec2<T> const & v) { return detail::tvec2<T>( sin(v.x), sin(v.y)); } template <typename T> inline detail::tvec3<T> sin( detail::tvec3<T> const & v) { return detail::tvec3<T>( sin(v.x), sin(v.y), sin(v.z)); } template <typename T> inline detail::tvec4<T> sin( detail::tvec4<T> const & v) { return detail::tvec4<T>( sin(v.x), sin(v.y), sin(v.z), sin(v.w)); }


 template <typename genType>
 inline genType cos(genType const & angle)
 {
  ;

  return ::std::cos(angle);
 }

 template <typename T> inline detail::tvec2<T> cos( detail::tvec2<T> const & v) { return detail::tvec2<T>( cos(v.x), cos(v.y)); } template <typename T> inline detail::tvec3<T> cos( detail::tvec3<T> const & v) { return detail::tvec3<T>( cos(v.x), cos(v.y), cos(v.z)); } template <typename T> inline detail::tvec4<T> cos( detail::tvec4<T> const & v) { return detail::tvec4<T>( cos(v.x), cos(v.y), cos(v.z), cos(v.w)); }


 template <typename genType>
 inline genType tan
 (
  genType const & angle
 )
 {
  ;

  return ::std::tan(angle);
 }

 template <typename T> inline detail::tvec2<T> tan( detail::tvec2<T> const & v) { return detail::tvec2<T>( tan(v.x), tan(v.y)); } template <typename T> inline detail::tvec3<T> tan( detail::tvec3<T> const & v) { return detail::tvec3<T>( tan(v.x), tan(v.y), tan(v.z)); } template <typename T> inline detail::tvec4<T> tan( detail::tvec4<T> const & v) { return detail::tvec4<T>( tan(v.x), tan(v.y), tan(v.z), tan(v.w)); }


 template <typename genType>
 inline genType asin
 (
  genType const & x
 )
 {
  ;

  return ::std::asin(x);
 }

 template <typename T> inline detail::tvec2<T> asin( detail::tvec2<T> const & v) { return detail::tvec2<T>( asin(v.x), asin(v.y)); } template <typename T> inline detail::tvec3<T> asin( detail::tvec3<T> const & v) { return detail::tvec3<T>( asin(v.x), asin(v.y), asin(v.z)); } template <typename T> inline detail::tvec4<T> asin( detail::tvec4<T> const & v) { return detail::tvec4<T>( asin(v.x), asin(v.y), asin(v.z), asin(v.w)); }


 template <typename genType>
 inline genType acos
 (
  genType const & x
 )
 {
  ;

  return ::std::acos(x);
 }

 template <typename T> inline detail::tvec2<T> acos( detail::tvec2<T> const & v) { return detail::tvec2<T>( acos(v.x), acos(v.y)); } template <typename T> inline detail::tvec3<T> acos( detail::tvec3<T> const & v) { return detail::tvec3<T>( acos(v.x), acos(v.y), acos(v.z)); } template <typename T> inline detail::tvec4<T> acos( detail::tvec4<T> const & v) { return detail::tvec4<T>( acos(v.x), acos(v.y), acos(v.z), acos(v.w)); }


 template <typename genType>
 inline genType atan
 (
  genType const & y,
  genType const & x
 )
 {
  ;

  return ::std::atan2(y, x);
 }

 template <typename T> inline detail::tvec2<T> atan ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( atan(x.x, y.x), atan(x.y, y.y)); } template <typename T> inline detail::tvec3<T> atan ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z)); } template <typename T> inline detail::tvec4<T> atan ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z), atan(x.w, y.w)); }

 template <typename genType>
 inline genType atan
 (
  genType const & x
 )
 {
  ;

  return ::std::atan(x);
 }

 template <typename T> inline detail::tvec2<T> atan( detail::tvec2<T> const & v) { return detail::tvec2<T>( atan(v.x), atan(v.y)); } template <typename T> inline detail::tvec3<T> atan( detail::tvec3<T> const & v) { return detail::tvec3<T>( atan(v.x), atan(v.y), atan(v.z)); } template <typename T> inline detail::tvec4<T> atan( detail::tvec4<T> const & v) { return detail::tvec4<T>( atan(v.x), atan(v.y), atan(v.z), atan(v.w)); }


 template <typename genType>
 inline genType sinh
 (
  genType const & angle
 )
 {
  ;

  return std::sinh(angle);
 }

 template <typename T> inline detail::tvec2<T> sinh( detail::tvec2<T> const & v) { return detail::tvec2<T>( sinh(v.x), sinh(v.y)); } template <typename T> inline detail::tvec3<T> sinh( detail::tvec3<T> const & v) { return detail::tvec3<T>( sinh(v.x), sinh(v.y), sinh(v.z)); } template <typename T> inline detail::tvec4<T> sinh( detail::tvec4<T> const & v) { return detail::tvec4<T>( sinh(v.x), sinh(v.y), sinh(v.z), sinh(v.w)); }


 template <typename genType>
 inline genType cosh
 (
  genType const & angle
 )
 {
  ;

  return std::cosh(angle);
 }

 template <typename T> inline detail::tvec2<T> cosh( detail::tvec2<T> const & v) { return detail::tvec2<T>( cosh(v.x), cosh(v.y)); } template <typename T> inline detail::tvec3<T> cosh( detail::tvec3<T> const & v) { return detail::tvec3<T>( cosh(v.x), cosh(v.y), cosh(v.z)); } template <typename T> inline detail::tvec4<T> cosh( detail::tvec4<T> const & v) { return detail::tvec4<T>( cosh(v.x), cosh(v.y), cosh(v.z), cosh(v.w)); }


 template <typename genType>
 inline genType tanh
 (
  genType const & angle
 )
 {
  ;

  return std::tanh(angle);
 }

 template <typename T> inline detail::tvec2<T> tanh( detail::tvec2<T> const & v) { return detail::tvec2<T>( tanh(v.x), tanh(v.y)); } template <typename T> inline detail::tvec3<T> tanh( detail::tvec3<T> const & v) { return detail::tvec3<T>( tanh(v.x), tanh(v.y), tanh(v.z)); } template <typename T> inline detail::tvec4<T> tanh( detail::tvec4<T> const & v) { return detail::tvec4<T>( tanh(v.x), tanh(v.y), tanh(v.z), tanh(v.w)); }


 template <typename genType>
 inline genType asinh
 (
  genType const & x
 )
 {
  ;

  return (x < genType(0) ? genType(-1) : (x > genType(0) ? genType(1) : genType(0))) * log(abs(x) + sqrt(genType(1) + x * x));
 }

 template <typename T> inline detail::tvec2<T> asinh( detail::tvec2<T> const & v) { return detail::tvec2<T>( asinh(v.x), asinh(v.y)); } template <typename T> inline detail::tvec3<T> asinh( detail::tvec3<T> const & v) { return detail::tvec3<T>( asinh(v.x), asinh(v.y), asinh(v.z)); } template <typename T> inline detail::tvec4<T> asinh( detail::tvec4<T> const & v) { return detail::tvec4<T>( asinh(v.x), asinh(v.y), asinh(v.z), asinh(v.w)); }


 template <typename genType>
 inline genType acosh
 (
  genType const & x
 )
 {
  ;

  if(x < genType(1))
   return genType(0);
  return log(x + sqrt(x * x - genType(1)));
 }

 template <typename T> inline detail::tvec2<T> acosh( detail::tvec2<T> const & v) { return detail::tvec2<T>( acosh(v.x), acosh(v.y)); } template <typename T> inline detail::tvec3<T> acosh( detail::tvec3<T> const & v) { return detail::tvec3<T>( acosh(v.x), acosh(v.y), acosh(v.z)); } template <typename T> inline detail::tvec4<T> acosh( detail::tvec4<T> const & v) { return detail::tvec4<T>( acosh(v.x), acosh(v.y), acosh(v.z), acosh(v.w)); }


 template <typename genType>
 inline genType atanh
 (
  genType const & x
 )
 {
  ;

  if(abs(x) >= genType(1))
   return 0;
  return genType(0.5) * log((genType(1) + x) / (genType(1) - x));
 }

 template <typename T> inline detail::tvec2<T> atanh( detail::tvec2<T> const & v) { return detail::tvec2<T>( atanh(v.x), atanh(v.y)); } template <typename T> inline detail::tvec3<T> atanh( detail::tvec3<T> const & v) { return detail::tvec3<T>( atanh(v.x), atanh(v.y), atanh(v.z)); } template <typename T> inline detail::tvec4<T> atanh( detail::tvec4<T> const & v) { return detail::tvec4<T>( atanh(v.x), atanh(v.y), atanh(v.z), atanh(v.w)); }

}
# 200 "/usr/include/sgct/glm/./core/func_trigonometric.hpp" 2 3 4
# 100 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_exponential.hpp" 1 3 4
# 39 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
namespace glm
{
# 52 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
 template <typename genType>
 genType pow(genType const & x, genType const & y);
# 62 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
 template <typename genType>
 genType exp(genType const & x);
# 74 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
 template <typename genType>
 genType log(genType const & x);
# 84 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
 template <typename genType>
 genType exp2(genType const & x);
# 95 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
 template <typename genType>
 genType log2(genType const & x);
# 105 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
 template <typename genType>
 genType sqrt(genType const & x);
# 115 "/usr/include/sgct/glm/./core/func_exponential.hpp" 3 4
 template <typename genType>
 genType inversesqrt(genType const & x);


}

# 1 "/usr/include/sgct/glm/./core/func_exponential.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_exponential.inl" 3 4
# 1 "/usr/include/sgct/glm/./core/_vectorize.hpp" 1 3 4
# 30 "/usr/include/sgct/glm/./core/func_exponential.inl" 2 3 4

namespace glm
{

    template <typename genType>
    inline genType pow
 (
  genType const & x,
  genType const & y
 )
    {
  ;

        return ::std::pow(x, y);
    }

 template <typename T> inline detail::tvec2<T> pow ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( pow(x.x, y.x), pow(x.y, y.y)); } template <typename T> inline detail::tvec3<T> pow ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z)); } template <typename T> inline detail::tvec4<T> pow ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z), pow(x.w, y.w)); }


    template <typename genType>
    inline genType exp
 (
  genType const & x
 )
    {
  ;

        return ::std::exp(x);
    }

 template <typename T> inline detail::tvec2<T> exp( detail::tvec2<T> const & v) { return detail::tvec2<T>( exp(v.x), exp(v.y)); } template <typename T> inline detail::tvec3<T> exp( detail::tvec3<T> const & v) { return detail::tvec3<T>( exp(v.x), exp(v.y), exp(v.z)); } template <typename T> inline detail::tvec4<T> exp( detail::tvec4<T> const & v) { return detail::tvec4<T>( exp(v.x), exp(v.y), exp(v.z), exp(v.w)); }


    template <typename genType>
    inline genType log
 (
  genType const & x
 )
    {
  ;

        return ::std::log(x);
    }

 template <typename T> inline detail::tvec2<T> log( detail::tvec2<T> const & v) { return detail::tvec2<T>( log(v.x), log(v.y)); } template <typename T> inline detail::tvec3<T> log( detail::tvec3<T> const & v) { return detail::tvec3<T>( log(v.x), log(v.y), log(v.z)); } template <typename T> inline detail::tvec4<T> log( detail::tvec4<T> const & v) { return detail::tvec4<T>( log(v.x), log(v.y), log(v.z), log(v.w)); }


    template <typename genType>
    inline genType exp2
 (
  genType const & x
 )
    {
  ;

        return ::std::exp(genType(0.69314718055994530941723212145818) * x);
    }

 template <typename T> inline detail::tvec2<T> exp2( detail::tvec2<T> const & v) { return detail::tvec2<T>( exp2(v.x), exp2(v.y)); } template <typename T> inline detail::tvec3<T> exp2( detail::tvec3<T> const & v) { return detail::tvec3<T>( exp2(v.x), exp2(v.y), exp2(v.z)); } template <typename T> inline detail::tvec4<T> exp2( detail::tvec4<T> const & v) { return detail::tvec4<T>( exp2(v.x), exp2(v.y), exp2(v.z), exp2(v.w)); }

namespace _detail
{
 template <int _PATH = detail::float_or_int_value::GLM_ERROR>
 struct _compute_log2
 {
  template <typename T>
  T operator() (T const & Value) const;






 };

 template <>
 struct _compute_log2<detail::float_or_int_value::GLM_FLOAT>
 {
  template <typename T>
  T operator() (T const & Value) const
  {
   return T(::std::log(Value)) / T(0.69314718055994530941723212145818);
  }
 };

}


    template <typename genType>
    inline genType log2
 (
  genType const & x
 )
    {
  ((x > genType(0)) ? static_cast<void> (0) : __assert_fail ("x > genType(0)", "/usr/include/sgct/glm/./core/func_exponential.inl", 124, __PRETTY_FUNCTION__));
  return _detail::_compute_log2<detail::float_or_int_trait<genType>::ID>()(x);
    }

 template <typename T> inline detail::tvec2<T> log2( detail::tvec2<T> const & v) { return detail::tvec2<T>( log2(v.x), log2(v.y)); } template <typename T> inline detail::tvec3<T> log2( detail::tvec3<T> const & v) { return detail::tvec3<T>( log2(v.x), log2(v.y), log2(v.z)); } template <typename T> inline detail::tvec4<T> log2( detail::tvec4<T> const & v) { return detail::tvec4<T>( log2(v.x), log2(v.y), log2(v.z), log2(v.w)); }


    template <typename genType>
    inline genType sqrt
 (
  genType const & x
 )
    {
  ;

        return genType(::std::sqrt(x));
    }

 template <typename T> inline detail::tvec2<T> sqrt( detail::tvec2<T> const & v) { return detail::tvec2<T>( sqrt(v.x), sqrt(v.y)); } template <typename T> inline detail::tvec3<T> sqrt( detail::tvec3<T> const & v) { return detail::tvec3<T>( sqrt(v.x), sqrt(v.y), sqrt(v.z)); } template <typename T> inline detail::tvec4<T> sqrt( detail::tvec4<T> const & v) { return detail::tvec4<T>( sqrt(v.x), sqrt(v.y), sqrt(v.z), sqrt(v.w)); }

    template <typename genType>
    inline genType inversesqrt
 (
  genType const & x
 )
    {
  ;

        return genType(1) / ::std::sqrt(x);
    }

 template <typename T> inline detail::tvec2<T> inversesqrt( detail::tvec2<T> const & v) { return detail::tvec2<T>( inversesqrt(v.x), inversesqrt(v.y)); } template <typename T> inline detail::tvec3<T> inversesqrt( detail::tvec3<T> const & v) { return detail::tvec3<T>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z)); } template <typename T> inline detail::tvec4<T> inversesqrt( detail::tvec4<T> const & v) { return detail::tvec4<T>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z), inversesqrt(v.w)); }

}
# 122 "/usr/include/sgct/glm/./core/func_exponential.hpp" 2 3 4
# 101 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_common.hpp" 1 3 4
# 39 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
# 1 "/usr/include/sgct/glm/./core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/./core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 30 "/usr/include/sgct/glm/./core/_fixes.hpp" 2 3 4
# 40 "/usr/include/sgct/glm/./core/func_common.hpp" 2 3 4

namespace glm
{
# 52 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
    template <typename genType>
 genType abs(genType const & x);







 template <typename genType>
 genType sign(genType const & x);







 template <typename genType>
 genType floor(genType const & x);
# 80 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 genType trunc(genType const & x);
# 93 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 genType round(genType const & x);
# 105 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 genType roundEven(genType const & x);
# 115 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
    template <typename genType>
 genType ceil(genType const & x);







    template <typename genType>
 genType fract(genType const & x);
# 134 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
    template <typename genType>
 genType mod(
  genType const & x,
  genType const & y);
# 146 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
    template <typename genType>
 genType mod(
  genType const & x,
  typename genType::value_type const & y);
# 160 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 genType modf(
  genType const & x,
  genType & i);







 template <typename genType>
 genType min(
  genType const & x,
  genType const & y);

 template <typename genType>
 genType min(
  genType const & x,
  typename genType::value_type const & y);







 template <typename genType>
 genType max(
  genType const & x,
  genType const & y);

 template <typename genType>
 genType max(
  genType const & x,
  typename genType::value_type const & y);
# 204 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 genType clamp(
  genType const & x,
  genType const & minVal,
  genType const & maxVal);

 template <typename genType>
 genType clamp(
  genType const & x,
  typename genType::value_type const & minVal,
  typename genType::value_type const & maxVal);
# 258 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genTypeT, typename genTypeU>
 genTypeT mix(genTypeT const & x, genTypeT const & y, genTypeU const & a);





 template <typename genType>
 genType step(
  genType const & edge,
  genType const & x);

 template <typename genType>
 genType step(
  typename genType::value_type const & edge,
  genType const & x);
# 289 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 genType smoothstep(
  genType const & edge0,
  genType const & edge1,
  genType const & x);

 template <typename genType>
 genType smoothstep(
  typename genType::value_type const & edge0,
  typename genType::value_type const & edge1,
  genType const & x);
# 311 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 typename genType::bool_type isnan(genType const & x);
# 324 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType>
 typename genType::bool_type isinf(genType const & x);
# 336 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType, typename genIType>
 genIType floatBitsToInt(genType const & value);
# 348 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType, typename genUType>
 genUType floatBitsToUint(genType const & value);
# 364 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType, typename genIType>
 genType intBitsToFloat(genIType const & value);
# 380 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
    template <typename genType, typename genUType>
    genType uintBitsToFloat(genUType const & value);







 template <typename genType>
 genType fma(genType const & a, genType const & b, genType const & c);
# 406 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType, typename genIType>
 genType frexp(genType const & x, genIType & exp);
# 420 "/usr/include/sgct/glm/./core/func_common.hpp" 3 4
 template <typename genType, typename genIType>
 genType ldexp(genType const & x, genIType const & exp);


}

# 1 "/usr/include/sgct/glm/./core/func_common.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_common.inl" 3 4
# 1 "/usr/include/sgct/glm/./core/_vectorize.hpp" 1 3 4
# 30 "/usr/include/sgct/glm/./core/func_common.inl" 2 3 4

namespace glm{
namespace detail
{
    template <typename genFIType, bool >
    struct Abs_
    {};

    template <typename genFIType>
    struct Abs_<genFIType, true>
    {
        static genFIType get(genFIType const & x)
        {
           

                                                                                                       ;
            return x >= genFIType(0) ? x : -x;

        }
    };

    template <typename genFIType>
    struct Abs_<genFIType, false>
    {
        static genFIType get(genFIType const & x)
        {
           
                                                                                             ;
            return x;
        }
    };
}


 template <typename genFIType>
    inline genFIType abs
 (
  genFIType const & x
 )
    {
  return detail::Abs_<genFIType, std::numeric_limits<genFIType>::is_signed>::get(x);
    }

 template <typename T> inline detail::tvec2<T> abs( detail::tvec2<T> const & v) { return detail::tvec2<T>( abs(v.x), abs(v.y)); } template <typename T> inline detail::tvec3<T> abs( detail::tvec3<T> const & v) { return detail::tvec3<T>( abs(v.x), abs(v.y), abs(v.z)); } template <typename T> inline detail::tvec4<T> abs( detail::tvec4<T> const & v) { return detail::tvec4<T>( abs(v.x), abs(v.y), abs(v.z), abs(v.w)); }



    template <typename genFIType>
 inline genFIType sign
 (
  genFIType const & x
 )
 {
 

                                                                       ;

  genFIType result;
  if(x > genFIType(0))
            result = genFIType(1);
        else if(x < genFIType(0))
            result = genFIType(-1);
        else
            result = genFIType(0);
        return result;
 }

 template <typename T> inline detail::tvec2<T> sign( detail::tvec2<T> const & v) { return detail::tvec2<T>( sign(v.x), sign(v.y)); } template <typename T> inline detail::tvec3<T> sign( detail::tvec3<T> const & v) { return detail::tvec3<T>( sign(v.x), sign(v.y), sign(v.z)); } template <typename T> inline detail::tvec4<T> sign( detail::tvec4<T> const & v) { return detail::tvec4<T>( sign(v.x), sign(v.y), sign(v.z), sign(v.w)); }


    template <>
 inline detail::half floor<detail::half>(detail::half const & x)
    {
        return detail::half(::std::floor(float(x)));
    }

    template <typename genType>
    inline genType floor(genType const & x)
    {
  ;

        return ::std::floor(x);
    }

 template <typename T> inline detail::tvec2<T> floor( detail::tvec2<T> const & v) { return detail::tvec2<T>( floor(v.x), floor(v.y)); } template <typename T> inline detail::tvec3<T> floor( detail::tvec3<T> const & v) { return detail::tvec3<T>( floor(v.x), floor(v.y), floor(v.z)); } template <typename T> inline detail::tvec4<T> floor( detail::tvec4<T> const & v) { return detail::tvec4<T>( floor(v.x), floor(v.y), floor(v.z), floor(v.w)); }


    template <typename genType>
    inline genType trunc(genType const & x)
    {
  ;
        return x < 0 ? -floor(-x) : floor(x);
    }

 template <typename T> inline detail::tvec2<T> trunc( detail::tvec2<T> const & v) { return detail::tvec2<T>( trunc(v.x), trunc(v.y)); } template <typename T> inline detail::tvec3<T> trunc( detail::tvec3<T> const & v) { return detail::tvec3<T>( trunc(v.x), trunc(v.y), trunc(v.z)); } template <typename T> inline detail::tvec4<T> trunc( detail::tvec4<T> const & v) { return detail::tvec4<T>( trunc(v.x), trunc(v.y), trunc(v.z), trunc(v.w)); }


    template <typename genType>
    inline genType round(genType const& x)
    {
  ;

  if(x < 0)
   return genType(int(x - genType(0.5)));
  return genType(int(x + genType(0.5)));
    }

 template <typename T> inline detail::tvec2<T> round( detail::tvec2<T> const & v) { return detail::tvec2<T>( round(v.x), round(v.y)); } template <typename T> inline detail::tvec3<T> round( detail::tvec3<T> const & v) { return detail::tvec3<T>( round(v.x), round(v.y), round(v.z)); } template <typename T> inline detail::tvec4<T> round( detail::tvec4<T> const & v) { return detail::tvec4<T>( round(v.x), round(v.y), round(v.z), round(v.w)); }
# 151 "/usr/include/sgct/glm/./core/func_common.inl" 3 4
    template <typename genType>
    inline genType roundEven(genType const & x)
    {
  ;

  int Integer = int(x);
  genType IntegerPart = genType(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > genType(0.5) || FractionalPart < genType(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= genType(0))
  {
   return IntegerPart - 1;
  }
  else
  {
   return IntegerPart + 1;
  }




 }

 template <typename T> inline detail::tvec2<T> roundEven( detail::tvec2<T> const & v) { return detail::tvec2<T>( roundEven(v.x), roundEven(v.y)); } template <typename T> inline detail::tvec3<T> roundEven( detail::tvec3<T> const & v) { return detail::tvec3<T>( roundEven(v.x), roundEven(v.y), roundEven(v.z)); } template <typename T> inline detail::tvec4<T> roundEven( detail::tvec4<T> const & v) { return detail::tvec4<T>( roundEven(v.x), roundEven(v.y), roundEven(v.z), roundEven(v.w)); }


    template <typename genType>
    inline genType ceil(genType const & x)
    {
  ;

        return ::std::ceil(x);
    }

 template <typename T> inline detail::tvec2<T> ceil( detail::tvec2<T> const & v) { return detail::tvec2<T>( ceil(v.x), ceil(v.y)); } template <typename T> inline detail::tvec3<T> ceil( detail::tvec3<T> const & v) { return detail::tvec3<T>( ceil(v.x), ceil(v.y), ceil(v.z)); } template <typename T> inline detail::tvec4<T> ceil( detail::tvec4<T> const & v) { return detail::tvec4<T>( ceil(v.x), ceil(v.y), ceil(v.z), ceil(v.w)); }


    template <typename genType>
    inline genType fract
 (
  genType const & x
 )
    {
  ;

        return x - ::std::floor(x);
    }

 template <typename T> inline detail::tvec2<T> fract( detail::tvec2<T> const & v) { return detail::tvec2<T>( fract(v.x), fract(v.y)); } template <typename T> inline detail::tvec3<T> fract( detail::tvec3<T> const & v) { return detail::tvec3<T>( fract(v.x), fract(v.y), fract(v.z)); } template <typename T> inline detail::tvec4<T> fract( detail::tvec4<T> const & v) { return detail::tvec4<T>( fract(v.x), fract(v.y), fract(v.z), fract(v.w)); }


    template <typename genType>
    inline genType mod
 (
  genType const & x,
  genType const & y
 )
    {
  ;

        return x - y * floor(x / y);
    }

 template <typename T> inline detail::tvec2<T> mod ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( mod(x.x, y), mod(x.y, y)); } template <typename T> inline detail::tvec3<T> mod ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( mod(x.x, y), mod(x.y, y), mod(x.z, y)); } template <typename T> inline detail::tvec4<T> mod ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( mod(x.x, y), mod(x.y, y), mod(x.z, y), mod(x.w, y)); }
 template <typename T> inline detail::tvec2<T> mod ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( mod(x.x, y.x), mod(x.y, y.y)); } template <typename T> inline detail::tvec3<T> mod ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z)); } template <typename T> inline detail::tvec4<T> mod ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z), mod(x.w, y.w)); }


    template <typename genType>
    inline genType modf
 (
  genType const & x,
  genType & i
 )
    {
  ;

  return std::modf(x, &i);
    }

    template <typename valType>
    inline detail::tvec2<valType> modf
 (
  detail::tvec2<valType> const & x,
  detail::tvec2<valType> & i
 )
    {
        return detail::tvec2<valType>(
            modf(x.x, i.x),
            modf(x.y, i.y));
    }

    template <typename valType>
    inline detail::tvec3<valType> modf
 (
  detail::tvec3<valType> const & x,
  detail::tvec3<valType> & i
 )
    {
        return detail::tvec3<valType>(
            modf(x.x, i.x),
            modf(x.y, i.y),
            modf(x.z, i.z));
    }

    template <typename valType>
    inline detail::tvec4<valType> modf
 (
  detail::tvec4<valType> const & x,
  detail::tvec4<valType> & i
 )
    {
        return detail::tvec4<valType>(
            modf(x.x, i.x),
            modf(x.y, i.y),
            modf(x.z, i.z),
            modf(x.w, i.w));
    }
# 286 "/usr/include/sgct/glm/./core/func_common.inl" 3 4
    template <typename genType>
    inline genType min
 (
  genType const & x,
  genType const & y
 )
    {
 


                                                               ;

        return x < y ? x : y;
    }

 template <typename T> inline detail::tvec2<T> min ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( min(x.x, y), min(x.y, y)); } template <typename T> inline detail::tvec3<T> min ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( min(x.x, y), min(x.y, y), min(x.z, y)); } template <typename T> inline detail::tvec4<T> min ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( min(x.x, y), min(x.y, y), min(x.z, y), min(x.w, y)); }
 template <typename T> inline detail::tvec2<T> min ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( min(x.x, y.x), min(x.y, y.y)); } template <typename T> inline detail::tvec3<T> min ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z)); } template <typename T> inline detail::tvec4<T> min ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z), min(x.w, y.w)); }


    template <typename genType>
    inline genType max
 (
  genType const & x,
  genType const & y
 )
    {
 


                                                               ;

  return x > y ? x : y;
    }

 template <typename T> inline detail::tvec2<T> max ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( max(x.x, y), max(x.y, y)); } template <typename T> inline detail::tvec3<T> max ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( max(x.x, y), max(x.y, y), max(x.z, y)); } template <typename T> inline detail::tvec4<T> max ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( max(x.x, y), max(x.y, y), max(x.z, y), max(x.w, y)); }
 template <typename T> inline detail::tvec2<T> max ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( max(x.x, y.x), max(x.y, y.y)); } template <typename T> inline detail::tvec3<T> max ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z)); } template <typename T> inline detail::tvec4<T> max ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z), max(x.w, y.w)); }


    template <typename valType>
    inline valType clamp
 (
  valType const & x,
  valType const & minVal,
  valType const & maxVal
 )
    {
 


                                                                 ;





  return max(min(x, maxVal), minVal);
    }

    template <typename T>
    inline detail::tvec2<T> clamp
 (
  detail::tvec2<T> const & x,
  typename detail::tvec2<T>::value_type const & minVal,
  typename detail::tvec2<T>::value_type const & maxVal
 )
    {
        return detail::tvec2<T>(
            clamp(x.x, minVal, maxVal),
            clamp(x.y, minVal, maxVal));
    }

    template <typename T>
    inline detail::tvec3<T> clamp
 (
  detail::tvec3<T> const & x,
  typename detail::tvec3<T>::value_type const & minVal,
  typename detail::tvec3<T>::value_type const & maxVal
 )
    {
        return detail::tvec3<T>(
            clamp(x.x, minVal, maxVal),
            clamp(x.y, minVal, maxVal),
            clamp(x.z, minVal, maxVal));
    }

    template <typename T>
    inline detail::tvec4<T> clamp
 (
  detail::tvec4<T> const & x,
  typename detail::tvec4<T>::value_type const & minVal,
  typename detail::tvec4<T>::value_type const & maxVal
 )
    {
        return detail::tvec4<T>(
            clamp(x.x, minVal, maxVal),
            clamp(x.y, minVal, maxVal),
            clamp(x.z, minVal, maxVal),
            clamp(x.w, minVal, maxVal));
    }

    template <typename T>
    inline detail::tvec2<T> clamp
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & minVal,
  detail::tvec2<T> const & maxVal
 )
    {
        return detail::tvec2<T>(
            clamp(x.x, minVal.x, maxVal.x),
            clamp(x.y, minVal.y, maxVal.y));
    }

    template <typename T>
    inline detail::tvec3<T> clamp
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & minVal,
  detail::tvec3<T> const & maxVal
 )
    {
        return detail::tvec3<T>(
            clamp(x.x, minVal.x, maxVal.x),
            clamp(x.y, minVal.y, maxVal.y),
            clamp(x.z, minVal.z, maxVal.z));
    }

    template <typename T>
    inline detail::tvec4<T> clamp
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & minVal,
  detail::tvec4<T> const & maxVal
 )
    {
        return detail::tvec4<T>(
            clamp(x.x, minVal.x, maxVal.x),
            clamp(x.y, minVal.y, maxVal.y),
            clamp(x.z, minVal.z, maxVal.z),
            clamp(x.w, minVal.w, maxVal.w));
    }


 template <typename genTypeT, typename genTypeU>
 inline genTypeT mix
 (
  genTypeT const & x,
  genTypeT const & y,
  genTypeU const & a
 )
 {






  return genTypeT(genTypeU(x) + a * genTypeU(y - x));
 }

 template <typename valTypeA, typename valTypeB>
 inline detail::tvec2<valTypeA> mix
 (
  detail::tvec2<valTypeA> const & x,
  detail::tvec2<valTypeA> const & y,
  valTypeB const & a
 )
 {
  return detail::tvec2<valTypeA>(
   detail::tvec2<valTypeB>(x) + a * detail::tvec2<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB>
 inline detail::tvec3<valTypeA> mix
 (
  detail::tvec3<valTypeA> const & x,
  detail::tvec3<valTypeA> const & y,
  valTypeB const & a
 )
 {
  return detail::tvec3<valTypeA>(
   detail::tvec3<valTypeB>(x) + a * detail::tvec3<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB>
 inline detail::tvec4<valTypeA> mix
 (
  detail::tvec4<valTypeA> const & x,
  detail::tvec4<valTypeA> const & y,
  valTypeB const & a
 )
 {
  return detail::tvec4<valTypeA>(
   detail::tvec4<valTypeB>(x) + a * detail::tvec4<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB>
 inline detail::tvec2<valTypeA> mix
 (
  detail::tvec2<valTypeA> const & x,
  detail::tvec2<valTypeA> const & y,
  detail::tvec2<valTypeB> const & a
 )
 {
  return detail::tvec2<valTypeA>(
   detail::tvec2<valTypeB>(x) + a * detail::tvec2<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB>
 inline detail::tvec3<valTypeA> mix
 (
  detail::tvec3<valTypeA> const & x,
  detail::tvec3<valTypeA> const & y,
  detail::tvec3<valTypeB> const & a
 )
 {
  return detail::tvec3<valTypeA>(
   detail::tvec3<valTypeB>(x) + a * detail::tvec3<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB>
 inline detail::tvec4<valTypeA> mix
 (
  detail::tvec4<valTypeA> const & x,
  detail::tvec4<valTypeA> const & y,
  detail::tvec4<valTypeB> const & a
 )
 {
  return detail::tvec4<valTypeA>(
   detail::tvec4<valTypeB>(x) + a * detail::tvec4<valTypeB>(y - x));
 }
# 534 "/usr/include/sgct/glm/./core/func_common.inl" 3 4
 template <typename genType>
 inline genType mix
 (
  genType const & x,
  genType const & y,
  bool const & a
 )
 {
  ;

  return a ? y : x;
 }

 template <typename T>
 inline detail::tvec2<T> mix
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  typename detail::tvec2<T>::bool_type a
 )
 {
  ;

  detail::tvec2<T> result;
  for
  (
   typename detail::tvec2<T>::size_type i = 0;
   i < detail::tvec2<T>::value_size();
   ++i
  )
  {
   result[i] = a[i] ? y[i] : x[i];
  }
  return result;
 }

 template <typename T>
 inline detail::tvec3<T> mix
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  typename detail::tvec3<T>::bool_type a
 )
 {
  ;

  detail::tvec3<T> result;
  for
  (
   typename detail::tvec3<T>::size_type i = 0;
   i < detail::tvec3<T>::value_size();
   ++i
  )
  {
   result[i] = a[i] ? y[i] : x[i];
  }
  return result;
 }

 template <typename T>
 inline detail::tvec4<T> mix
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  typename detail::tvec4<T>::bool_type a
 )
 {
  ;

  detail::tvec4<T> result;
  for
  (
   typename detail::tvec4<T>::size_type i = 0;
   i < detail::tvec4<T>::value_size();
   ++i
  )
  {
   result[i] = a[i] ? y[i] : x[i];
  }
  return result;
 }


    template <typename genType>
    inline genType step
 (
  genType const & edge,
  genType const & x
 )
    {
  ;

        return x < edge ? genType(0) : genType(1);
    }

    template <typename T>
    inline detail::tvec2<T> step
 (
  typename detail::tvec2<T>::value_type const & edge,
  detail::tvec2<T> const & x
 )
    {
        return detail::tvec2<T>(
            x.x < edge ? T(0) : T(1),
            x.y < edge ? T(0) : T(1));
    }

    template <typename T>
    inline detail::tvec3<T> step
 (
  typename detail::tvec3<T>::value_type const & edge,
  detail::tvec3<T> const & x
 )
    {
  return detail::tvec3<T>(
   x.x < edge ? T(0) : T(1),
   x.y < edge ? T(0) : T(1),
   x.z < edge ? T(0) : T(1));
    }

    template <typename T>
    inline detail::tvec4<T> step
 (
  typename detail::tvec4<T>::value_type const & edge,
  detail::tvec4<T> const & x
 )
    {
        return detail::tvec4<T>(
            x.x < edge ? T(0) : T(1),
            x.y < edge ? T(0) : T(1),
            x.z < edge ? T(0) : T(1),
            x.w < edge ? T(0) : T(1));
    }

    template <typename T>
    inline detail::tvec2<T> step
 (
  detail::tvec2<T> const & edge,
  detail::tvec2<T> const & x
 )
    {
        return detail::tvec2<T>(
            x.x < edge.x ? T(0) : T(1),
            x.y < edge.y ? T(0) : T(1));
    }

    template <typename T>
    inline detail::tvec3<T> step
 (
  detail::tvec3<T> const & edge,
  detail::tvec3<T> const & x
 )
    {
        return detail::tvec3<T>(
            x.x < edge.x ? T(0) : T(1),
            x.y < edge.y ? T(0) : T(1),
            x.z < edge.z ? T(0) : T(1));
    }

    template <typename T>
    inline detail::tvec4<T> step
 (
  detail::tvec4<T> const & edge,
  detail::tvec4<T> const & x
 )
    {
        return detail::tvec4<T>(
            x.x < edge.x ? T(0) : T(1),
            x.y < edge.y ? T(0) : T(1),
            x.z < edge.z ? T(0) : T(1),
            x.w < edge.w ? T(0) : T(1));
    }


    template <typename genType>
    inline genType smoothstep
 (
  genType const & edge0,
  genType const & edge1,
  genType const & x
 )
    {
  ;

        genType tmp = clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1));
        return tmp * tmp * (genType(3) - genType(2) * tmp);
    }

    template <typename T>
    inline detail::tvec2<T> smoothstep
 (
  typename detail::tvec2<T>::value_type const & edge0,
  typename detail::tvec2<T>::value_type const & edge1,
  detail::tvec2<T> const & x
 )
    {
        return detail::tvec2<T>(
            smoothstep(edge0, edge1, x.x),
            smoothstep(edge0, edge1, x.y));
    }

    template <typename T>
    inline detail::tvec3<T> smoothstep
 (
  typename detail::tvec3<T>::value_type const & edge0,
  typename detail::tvec3<T>::value_type const & edge1,
  detail::tvec3<T> const & x
 )
    {
        return detail::tvec3<T>(
            smoothstep(edge0, edge1, x.x),
            smoothstep(edge0, edge1, x.y),
            smoothstep(edge0, edge1, x.z));
    }

    template <typename T>
    inline detail::tvec4<T> smoothstep
 (
  typename detail::tvec4<T>::value_type const & edge0,
  typename detail::tvec4<T>::value_type const & edge1,
  detail::tvec4<T> const & x
 )
    {
        return detail::tvec4<T>(
            smoothstep(edge0, edge1, x.x),
            smoothstep(edge0, edge1, x.y),
            smoothstep(edge0, edge1, x.z),
            smoothstep(edge0, edge1, x.w));
    }

    template <typename T>
    inline detail::tvec2<T> smoothstep
 (
  detail::tvec2<T> const & edge0,
  detail::tvec2<T> const & edge1,
  detail::tvec2<T> const & x
 )
    {
        return detail::tvec2<T>(
            smoothstep(edge0.x, edge1.x, x.x),
            smoothstep(edge0.y, edge1.y, x.y));
    }

    template <typename T>
    inline detail::tvec3<T> smoothstep
 (
  detail::tvec3<T> const & edge0,
  detail::tvec3<T> const & edge1,
  detail::tvec3<T> const & x
 )
    {
        return detail::tvec3<T>(
            smoothstep(edge0.x, edge1.x, x.x),
            smoothstep(edge0.y, edge1.y, x.y),
            smoothstep(edge0.z, edge1.z, x.z));
    }

    template <typename T>
    inline detail::tvec4<T> smoothstep
 (
  detail::tvec4<T> const & edge0,
  detail::tvec4<T> const & edge1,
  detail::tvec4<T> const & x
 )
    {
        return detail::tvec4<T>(
            smoothstep(edge0.x, edge1.x, x.x),
            smoothstep(edge0.y, edge1.y, x.y),
            smoothstep(edge0.z, edge1.z, x.z),
            smoothstep(edge0.w, edge1.w, x.w));
    }

 template <typename genType>
 inline typename genType::bool_type isnan
 (
  genType const & x
 )
 {
  ;






  return typename genType::bool_type(std::isnan(x));

 }

    template <typename T>
    inline typename detail::tvec2<T>::bool_type isnan
 (
  detail::tvec2<T> const & x
 )
    {
        return typename detail::tvec2<T>::bool_type(
            isnan(x.x),
            isnan(x.y));
    }

    template <typename T>
    inline typename detail::tvec3<T>::bool_type isnan
 (
  detail::tvec3<T> const & x
 )
    {
        return typename detail::tvec3<T>::bool_type(
            isnan(x.x),
            isnan(x.y),
            isnan(x.z));
    }

    template <typename T>
    inline typename detail::tvec4<T>::bool_type isnan
 (
  detail::tvec4<T> const & x
 )
    {
        return typename detail::tvec4<T>::bool_type(
            isnan(x.x),
            isnan(x.y),
            isnan(x.z),
            isnan(x.w));
    }

 template <typename genType>
 inline typename genType::bool_type isinf
 (
  genType const & x
 )
 {
  ;






  return typename genType::bool_type(std::isinf(x));

 }

    template <typename T>
    inline typename detail::tvec2<T>::bool_type isinf
 (
  detail::tvec2<T> const & x
 )
    {
        return typename detail::tvec2<T>::bool_type(
            isinf(x.x),
            isinf(x.y));
    }

    template <typename T>
    inline typename detail::tvec3<T>::bool_type isinf
 (
  detail::tvec3<T> const & x
 )
    {
        return typename detail::tvec3<T>::bool_type(
            isinf(x.x),
            isinf(x.y),
            isinf(x.z));
    }

    template <typename T>
    inline typename detail::tvec4<T>::bool_type isinf
 (
  detail::tvec4<T> const & x
 )
    {
        return typename detail::tvec4<T>::bool_type(
            isinf(x.x),
            isinf(x.y),
            isinf(x.z),
            isinf(x.w));
    }

 inline int floatBitsToInt(float const & value)
 {
  union
  {
   float f;
   int i;
  } fi;

  fi.f = value;
  return fi.i;
 }

    inline detail::tvec2<int> floatBitsToInt
 (
  detail::tvec2<float> const & value
 )
    {
        return detail::tvec2<int>(
            floatBitsToInt(value.x),
            floatBitsToInt(value.y));
    }

    inline detail::tvec3<int> floatBitsToInt
 (
  detail::tvec3<float> const & value
 )
    {
        return detail::tvec3<int>(
            floatBitsToInt(value.x),
   floatBitsToInt(value.y),
   floatBitsToInt(value.z));
    }

    inline detail::tvec4<int> floatBitsToInt
 (
  detail::tvec4<float> const & value
 )
    {
        return detail::tvec4<int>(
            floatBitsToInt(value.x),
   floatBitsToInt(value.y),
   floatBitsToInt(value.z),
   floatBitsToInt(value.w));
    }

 inline uint floatBitsToUint(float const & value)
 {
  union
  {
   float f;
   uint u;
  } fu;

  fu.f = value;
  return fu.u;
 }

    inline detail::tvec2<uint> floatBitsToUint
 (
  detail::tvec2<float> const & value
 )
    {
        return detail::tvec2<uint>(
            floatBitsToUint(value.x),
            floatBitsToUint(value.y));
    }

    inline detail::tvec3<uint> floatBitsToUint
 (
  detail::tvec3<float> const & value
 )
    {
        return detail::tvec3<uint>(
            floatBitsToUint(value.x),
   floatBitsToUint(value.y),
   floatBitsToUint(value.z));
    }

    inline detail::tvec4<uint> floatBitsToUint
 (
  detail::tvec4<float> const & value
 )
    {
        return detail::tvec4<uint>(
            floatBitsToUint(value.x),
   floatBitsToUint(value.y),
   floatBitsToUint(value.z),
   floatBitsToUint(value.w));
    }

 inline float intBitsToFloat(int const & value)
 {
  union
  {
   float f;
   int i;
  } fi;

  fi.i = value;
  return fi.f;
 }

 inline detail::tvec2<float> intBitsToFloat

 (
  detail::tvec2<int> const & value
 )
    {
        return detail::tvec2<float>(
            intBitsToFloat(value.x),
            intBitsToFloat(value.y));
    }

 inline detail::tvec3<float> intBitsToFloat
 (
  detail::tvec3<int> const & value
 )
    {
        return detail::tvec3<float>(
            intBitsToFloat(value.x),
   intBitsToFloat(value.y),
   intBitsToFloat(value.z));
    }

    inline detail::tvec4<float> intBitsToFloat
 (
  detail::tvec4<int> const & value
 )
    {
        return detail::tvec4<float>(
            intBitsToFloat(value.x),
   intBitsToFloat(value.y),
   intBitsToFloat(value.z),
   intBitsToFloat(value.w));
    }

    inline float uintBitsToFloat(uint const & value)
    {
        union
        {
            float f;
            uint u;
        } fu;

        fu.u = value;
        return fu.f;
    }

    inline detail::tvec2<float> uintBitsToFloat
 (
  detail::tvec2<uint> const & value
 )
    {
        return detail::tvec2<float>(
            uintBitsToFloat(value.x),
            uintBitsToFloat(value.y));
    }

    inline detail::tvec3<float> uintBitsToFloat
 (
  detail::tvec3<uint> const & value
 )
    {
        return detail::tvec3<float>(
            uintBitsToFloat(value.x),
   uintBitsToFloat(value.y),
   uintBitsToFloat(value.z));
    }

    inline detail::tvec4<float> uintBitsToFloat
 (
  detail::tvec4<uint> const & value
 )
    {
        return detail::tvec4<float>(
            uintBitsToFloat(value.x),
   uintBitsToFloat(value.y),
   uintBitsToFloat(value.z),
   uintBitsToFloat(value.w));
    }

 template <typename genType>
 inline genType fma
 (
  genType const & a,
  genType const & b,
  genType const & c
 )
 {
  return a * b + c;
 }

 template <typename genType>
 inline genType frexp
 (
  genType const & x,
  int & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T>
 inline detail::tvec2<T> frexp
 (
  detail::tvec2<T> const & x,
  detail::tvec2<int> & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T>
 inline detail::tvec3<T> frexp
 (
  detail::tvec3<T> const & x,
  detail::tvec3<int> & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T>
 inline detail::tvec4<T> frexp
 (
  detail::tvec4<T> const & x,
  detail::tvec4<int> & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename genType>
 inline genType ldexp
 (
  genType const & x,
  int const & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T>
 inline detail::tvec2<T> ldexp
 (
  detail::tvec2<T> const & x,
  detail::tvec2<int> const & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T>
 inline detail::tvec3<T> ldexp
 (
  detail::tvec3<T> const & x,
  detail::tvec3<int> const & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T>
 inline detail::tvec4<T> ldexp
 (
  detail::tvec4<T> const & x,
  detail::tvec4<int> const & exp
 )
 {
  return std::frexp(x, exp);
 }

}
# 427 "/usr/include/sgct/glm/./core/func_common.hpp" 2 3 4
# 102 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_packing.hpp" 1 3 4
# 39 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
namespace glm
{
# 55 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::uint32 packUnorm2x16(detail::tvec2<detail::float32> const & v);
# 68 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::uint32 packSnorm2x16(detail::tvec2<detail::float32> const & v);
# 81 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::uint32 packUnorm4x8(detail::tvec4<detail::float32> const & v);
# 94 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::uint32 packSnorm4x8(detail::tvec4<detail::float32> const & v);
# 107 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::tvec2<detail::float32> unpackUnorm2x16(detail::uint32 const & p);
# 120 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::tvec2<detail::float32> unpackSnorm2x16(detail::uint32 const & p);
# 133 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
    detail::tvec4<detail::float32> unpackUnorm4x8(detail::uint32 const & p);
# 146 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::tvec4<detail::float32> unpackSnorm4x8(detail::uint32 const & p);
# 156 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 double packDouble2x32(detail::tvec2<detail::uint32> const & v);
# 165 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 detail::tvec2<detail::uint32> unpackDouble2x32(double const & v);
# 176 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 uint packHalf2x16(vec2 const & v);
# 186 "/usr/include/sgct/glm/./core/func_packing.hpp" 3 4
 vec2 unpackHalf2x16(uint const & v);


}

# 1 "/usr/include/sgct/glm/./core/func_packing.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_packing.inl" 3 4
namespace glm
{
 inline detail::uint32 packUnorm2x16(detail::tvec2<detail::float32> const & v)
 {
  detail::uint16 A(detail::uint16(round(clamp(v.x, 0.0f, 1.0f) * 65535.0f)));
  detail::uint16 B(detail::uint16(round(clamp(v.y, 0.0f, 1.0f) * 65535.0f)));
  return detail::uint32((B << 16) | A);
 }

 inline detail::tvec2<detail::float32> unpackUnorm2x16(detail::uint32 const & p)
 {
  detail::uint32 Mask16((1 << 16) - 1);
  detail::uint32 A((p >> 0) & Mask16);
  detail::uint32 B((p >> 16) & Mask16);
  return detail::tvec2<detail::float32>(
   A * 1.0f / 65535.0f,
   B * 1.0f / 65535.0f);
 }

 inline detail::uint32 packSnorm2x16(detail::tvec2<detail::float32> const & v)
 {
  union iu
  {
   detail::int16 i;
   detail::uint16 u;
  } A, B;

  detail::tvec2<detail::float32> Unpack = clamp(v ,-1.0f, 1.0f) * 32767.0f;
  A.i = detail::int16(round(Unpack.x));
  B.i = detail::int16(round(Unpack.y));
  detail::uint32 Pack = (detail::uint32(B.u) << 16) | (detail::uint32(A.u) << 0);
  return Pack;
 }

 inline detail::tvec2<detail::float32> unpackSnorm2x16(detail::uint32 const & p)
 {
  union iu
  {
   detail::int16 i;
   detail::uint16 u;
  } A, B;

  detail::uint32 Mask16((1 << 16) - 1);
  A.u = detail::uint16((p >> 0) & Mask16);
  B.u = detail::uint16((p >> 16) & Mask16);
  detail::tvec2<detail::float32> Pack(A.i, B.i);

  return clamp(Pack * 1.0f / 32767.0f, -1.0f, 1.0f);
 }

 inline detail::uint32 packUnorm4x8(detail::tvec4<detail::float32> const & v)
 {
  detail::uint8 A((detail::uint8)round(clamp(v.x, 0.0f, 1.0f) * 255.0f));
  detail::uint8 B((detail::uint8)round(clamp(v.y, 0.0f, 1.0f) * 255.0f));
  detail::uint8 C((detail::uint8)round(clamp(v.z, 0.0f, 1.0f) * 255.0f));
  detail::uint8 D((detail::uint8)round(clamp(v.w, 0.0f, 1.0f) * 255.0f));
  return detail::uint32((D << 24) | (C << 16) | (B << 8) | A);
 }

 inline detail::tvec4<detail::float32> unpackUnorm4x8(detail::uint32 const & p)
 {
  detail::uint32 Mask8((1 << 8) - 1);
  detail::uint32 A((p >> 0) & Mask8);
  detail::uint32 B((p >> 8) & Mask8);
  detail::uint32 C((p >> 16) & Mask8);
  detail::uint32 D((p >> 24) & Mask8);
  return detail::tvec4<detail::float32>(
   A * 1.0f / 255.0f,
   B * 1.0f / 255.0f,
   C * 1.0f / 255.0f,
   D * 1.0f / 255.0f);
 }

 inline detail::uint32 packSnorm4x8(detail::tvec4<detail::float32> const & v)
 {
  union iu
  {
   detail::int8 i;
   detail::uint8 u;
  } A, B, C, D;

  detail::tvec4<detail::float32> Unpack = clamp(v ,-1.0f, 1.0f) * 127.0f;
  A.i = detail::int8(round(Unpack.x));
  B.i = detail::int8(round(Unpack.y));
  C.i = detail::int8(round(Unpack.z));
  D.i = detail::int8(round(Unpack.w));
  detail::uint32 Pack = (detail::uint32(D.u) << 24) | (detail::uint32(C.u) << 16) | (detail::uint32(B.u) << 8) | (detail::uint32(A.u) << 0);
  return Pack;
 }

 inline detail::tvec4<detail::float32> unpackSnorm4x8(detail::uint32 const & p)
 {
  union iu
  {
   detail::int8 i;
   detail::uint8 u;
  } A, B, C, D;

  detail::uint32 Mask8((1 << 8) - 1);
  A.u = detail::uint8((p >> 0) & Mask8);
  B.u = detail::uint8((p >> 8) & Mask8);
  C.u = detail::uint8((p >> 16) & Mask8);
  D.u = detail::uint8((p >> 24) & Mask8);
  detail::tvec4<detail::float32> Pack(A.i, B.i, C.i, D.i);

  return clamp(Pack * 1.0f / 127.0f, -1.0f, 1.0f);
 }

 inline double packDouble2x32(detail::tvec2<detail::uint32> const & v)
 {
  return *(double*)&v;
 }

 inline detail::tvec2<uint> unpackDouble2x32(double const & v)
 {
  return *(detail::tvec2<uint>*)&v;
 }

 inline uint packHalf2x16(detail::tvec2<float> const & v)
 {
        union helper
        {
            uint other;
            struct
            {
                detail::hdata a, b;
            } orig;
        } Pack;

        Pack.orig.a = detail::toFloat16(v.x);
        Pack.orig.b = detail::toFloat16(v.y);
  return *(uint*)&Pack;
 }

 inline vec2 unpackHalf2x16(uint const & v)
 {
        union helper
        {
            uint other;
            struct
            {
                detail::hdata a, b;
            } orig;
        } Unpack;
        Unpack.other = v;

  return vec2(detail::toFloat32(Unpack.orig.a), detail::toFloat32(Unpack.orig.b));
 }
}
# 192 "/usr/include/sgct/glm/./core/func_packing.hpp" 2 3 4
# 103 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_geometric.hpp" 1 3 4
# 39 "/usr/include/sgct/glm/./core/func_geometric.hpp" 3 4
namespace glm
{
# 50 "/usr/include/sgct/glm/./core/func_geometric.hpp" 3 4
 template <typename genType>
        typename genType::value_type length(
  genType const & x);







 template <typename genType>
 typename genType::value_type distance(
  genType const & p0,
  genType const & p1);







    template <typename genType>
 typename genType::value_type dot(
  genType const & x,
  genType const & y);







    template <typename valType>
 detail::tvec3<valType> cross(
  detail::tvec3<valType> const & x,
  detail::tvec3<valType> const & y);





 template <typename genType>
 genType normalize(
  genType const & x);







    template <typename genType>
 genType faceforward(
  genType const & N,
  genType const & I,
  genType const & Nref);
# 114 "/usr/include/sgct/glm/./core/func_geometric.hpp" 3 4
    template <typename genType>
 genType reflect(
  genType const & I,
  genType const & N);
# 127 "/usr/include/sgct/glm/./core/func_geometric.hpp" 3 4
    template <typename genType>
 genType refract(
  genType const & I,
  genType const & N,
  typename genType::value_type const & eta);


}

# 1 "/usr/include/sgct/glm/./core/func_geometric.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_geometric.inl" 3 4
# 1 "/usr/include/sgct/glm/./core/_vectorize.hpp" 1 3 4
# 30 "/usr/include/sgct/glm/./core/func_geometric.inl" 2 3 4

namespace glm
{

    template <typename genType>
 inline genType length
 (
  genType const & x
 )
    {
  ;

        genType sqr = x * x;
        return sqrt(sqr);
    }

 template <typename T>
 inline typename detail::tvec2<T>::value_type length
 (
  detail::tvec2<T> const & v
 )
    {
  ;

        typename detail::tvec2<T>::value_type sqr = v.x * v.x + v.y * v.y;
        return sqrt(sqr);
    }

    template <typename T>
    inline typename detail::tvec3<T>::value_type length
 (
  detail::tvec3<T> const & v
 )
    {
  ;

        typename detail::tvec3<T>::value_type sqr = v.x * v.x + v.y * v.y + v.z * v.z;
        return sqrt(sqr);
    }

    template <typename T>
    inline typename detail::tvec4<T>::value_type length
 (
  detail::tvec4<T> const & v
 )
    {
  ;

        typename detail::tvec4<T>::value_type sqr = v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w;
        return sqrt(sqr);
    }


 template <typename genType>
    inline genType distance
 (
  genType const & p0,
  genType const & p1
 )
    {
        ;

  return length(p1 - p0);
    }

 template <typename T>
 inline typename detail::tvec2<T>::value_type distance
 (
  detail::tvec2<T> const & p0,
  detail::tvec2<T> const & p1
 )
    {
  ;

        return length(p1 - p0);
    }

    template <typename T>
    inline typename detail::tvec3<T>::value_type distance
 (
  detail::tvec3<T> const & p0,
  detail::tvec3<T> const & p1
 )
    {
  ;

  return length(p1 - p0);
    }

    template <typename T>
    inline typename detail::tvec4<T>::value_type distance
 (
  detail::tvec4<T> const & p0,
  detail::tvec4<T> const & p1
 )
    {
  ;

  return length(p1 - p0);
    }


 template <typename genType>
 inline genType dot
 (
  genType const & x,
  genType const & y

 )
 {
  ;

  return x * y;
 }

    template <typename T>
 inline typename detail::tvec2<T>::value_type dot
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y
 )
    {
  ;

  return x.x * y.x + x.y * y.y;
    }

    template <typename T>
    inline T dot
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y
 )
    {
  ;

  return x.x * y.x + x.y * y.y + x.z * y.z;
    }
# 185 "/usr/include/sgct/glm/./core/func_geometric.inl" 3 4
    template <typename T>
    inline T dot
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y
 )
    {
  ;

        return x.x * y.x + x.y * y.y + x.z * y.z + x.w * y.w;
    }


    template <typename T>
    inline detail::tvec3<T> cross
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y
 )
    {
  ;

        return detail::tvec3<T>(
            x.y * y.z - y.y * x.z,
            x.z * y.x - y.z * x.x,
            x.x * y.y - y.x * x.y);
    }


    template <typename genType>
    inline genType normalize
 (
  genType const & x
 )
    {
  ;

        return x < genType(0) ? genType(-1) : genType(1);
    }


    template <typename T>
    inline detail::tvec2<T> normalize
 (
  detail::tvec2<T> const & x
 )
    {
  ;

  typename detail::tvec2<T>::value_type sqr = x.x * x.x + x.y * x.y;
     return x * inversesqrt(sqr);
    }

    template <typename T>
    inline detail::tvec3<T> normalize
 (
  detail::tvec3<T> const & x
 )
    {
        ;

  typename detail::tvec3<T>::value_type sqr = x.x * x.x + x.y * x.y + x.z * x.z;
     return x * inversesqrt(sqr);
    }

    template <typename T>
    inline detail::tvec4<T> normalize
 (
  detail::tvec4<T> const & x
 )
    {
        ;

  typename detail::tvec4<T>::value_type sqr = x.x * x.x + x.y * x.y + x.z * x.z + x.w * x.w;
     return x * inversesqrt(sqr);
    }


 template <typename genType>
 inline genType faceforward
 (
  genType const & N,
  genType const & I,
  genType const & Nref
 )
 {
  return dot(Nref, I) < 0 ? N : -N;
 }


 template <typename genType>
 genType reflect
 (
  genType const & I,
  genType const & N
 )
 {
  return I - N * dot(N, I) * genType(2);
 }


    template <typename genType>
    inline genType refract
 (
  genType const & I,
  genType const & N,
  genType const & eta
 )
    {



        genType dotValue = dot(N, I);
        genType k = genType(1) - eta * eta * (genType(1) - dotValue * dotValue);
        if(k < genType(0))
            return genType(0);
        else
            return eta * I - (eta * dotValue + sqrt(k)) * N;
    }

    template <typename genType>
    inline genType refract
 (
  genType const & I,
  genType const & N,
  typename genType::value_type const & eta
 )
    {



        typename genType::value_type dotValue = dot(N, I);
        typename genType::value_type k = typename genType::value_type(1) - eta * eta * (typename genType::value_type(1) - dotValue * dotValue);
        if(k < typename genType::value_type(0))
            return genType(0);
        else
            return eta * I - (eta * dotValue + sqrt(k)) * N;
    }

}
# 137 "/usr/include/sgct/glm/./core/func_geometric.hpp" 2 3 4
# 104 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_matrix.hpp" 1 3 4
# 43 "/usr/include/sgct/glm/./core/func_matrix.hpp" 3 4
namespace glm
{
# 55 "/usr/include/sgct/glm/./core/func_matrix.hpp" 3 4
 template <typename matType>
 matType matrixCompMult(
  matType const & x,
  matType const & y);
# 70 "/usr/include/sgct/glm/./core/func_matrix.hpp" 3 4
    template <typename vecType, typename matType>
 matType outerProduct(
  vecType const & c,
  vecType const & r);







    template <typename matType>
 typename matType::transpose_type transpose(
  matType const & x);







 template <typename valType>
 typename detail::tmat2x2<valType>::value_type determinant(
  detail::tmat2x2<valType> const & m);







 template <typename valType>
 typename detail::tmat3x3<valType>::value_type determinant(
  detail::tmat3x3<valType> const & m);







    template <typename valType>
 typename detail::tmat4x4<valType>::value_type determinant(
  detail::tmat4x4<valType> const & m);







 template <typename valType>
 detail::tmat2x2<valType> inverse(
  detail::tmat2x2<valType> const & m);







 template <typename valType>
 detail::tmat3x3<valType> inverse(
  detail::tmat3x3<valType> const & m);







 template <typename valType>
 detail::tmat4x4<valType> inverse(
  detail::tmat4x4<valType> const & m);


}

# 1 "/usr/include/sgct/glm/./core/func_matrix.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_matrix.inl" 3 4
# 1 "/usr/include/sgct/glm/./core/_vectorize.hpp" 1 3 4
# 30 "/usr/include/sgct/glm/./core/func_matrix.inl" 2 3 4

namespace glm
{

 template <typename matType>
 inline matType matrixCompMult
 (
  matType const & x,
  matType const & y
 )
 {
  ;

  matType result(matType::null);
  for(typename matType::size_type i = 0; i < matType::col_size(); ++i)
   result[i] = x[i] * y[i];
  return result;
 }


 template <typename T>
 inline detail::tmat2x2<T> outerProduct
 (
  detail::tvec2<T> const & c,
  detail::tvec2<T> const & r
 )
 {
  ;

  detail::tmat2x2<T> m(detail::tmat2x2<T>::null);
  m[0][0] = c[0] * r[0];
  m[0][1] = c[1] * r[0];
  m[1][0] = c[0] * r[1];
  m[1][1] = c[1] * r[1];
  return m;
 }

 template <typename T>
 inline detail::tmat3x3<T> outerProduct
 (
  detail::tvec3<T> const & c,
  detail::tvec3<T> const & r
 )
 {
  ;

  detail::tmat3x3<T> m(detail::tmat3x3<T>::null);
  for(typename detail::tmat3x3<T>::size_type i(0); i < m.length(); ++i)
   m[i] = c * r[i];
  return m;
 }

 template <typename T>
 inline detail::tmat4x4<T> outerProduct
 (
  detail::tvec4<T> const & c,
  detail::tvec4<T> const & r
 )
 {
  ;

  detail::tmat4x4<T> m(detail::tmat4x4<T>::null);
  for(typename detail::tmat4x4<T>::size_type i(0); i < m.length(); ++i)
   m[i] = c * r[i];
  return m;
 }

 template <typename T>
 inline detail::tmat2x3<T> outerProduct
 (
  detail::tvec3<T> const & c,
  detail::tvec2<T> const & r
 )
 {
  ;

  detail::tmat2x3<T> m(detail::tmat2x3<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  return m;
 }

 template <typename T>
 inline detail::tmat3x2<T> outerProduct
 (
  detail::tvec2<T> const & c,
  detail::tvec3<T> const & r
 )
 {
  ;

  detail::tmat3x2<T> m(detail::tmat3x2<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  return m;
 }

 template <typename T>
 inline detail::tmat2x4<T> outerProduct
 (
  detail::tvec4<T> const & c,
  detail::tvec2<T> const & r
 )
 {
  ;

  detail::tmat2x4<T> m(detail::tmat2x4<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[0][3] = c.w * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  m[1][3] = c.w * r.y;
  return m;
 }

 template <typename T>
 inline detail::tmat4x2<T> outerProduct
 (
  detail::tvec2<T> const & c,
  detail::tvec4<T> const & r
 )
 {
  ;

  detail::tmat4x2<T> m(detail::tmat4x2<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  m[3][0] = c.x * r.w;
  m[3][1] = c.y * r.w;
  return m;
 }

 template <typename T>
 inline detail::tmat3x4<T> outerProduct
 (
  detail::tvec4<T> const & c,
  detail::tvec3<T> const & r
 )
 {
  ;

  detail::tmat3x4<T> m(detail::tmat3x4<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[0][3] = c.w * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  m[1][3] = c.w * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  m[2][2] = c.z * r.z;
  m[2][3] = c.w * r.z;
  return m;
 }

 template <typename T>
 inline detail::tmat4x3<T> outerProduct
 (
  detail::tvec3<T> const & c,
  detail::tvec4<T> const & r
 )
 {
  ;

  detail::tmat4x3<T> m(detail::tmat4x3<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  m[2][2] = c.z * r.z;
  m[3][0] = c.x * r.w;
  m[3][1] = c.y * r.w;
  m[3][2] = c.z * r.w;
  return m;
 }

 template <typename T>
 inline detail::tmat2x2<T> transpose
 (
  detail::tmat2x2<T> const & m
 )
 {
  ;

  detail::tmat2x2<T> result(detail::tmat2x2<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  return result;
 }

 template <typename T>
 inline detail::tmat3x3<T> transpose
 (
  detail::tmat3x3<T> const & m
 )
 {
  ;

  detail::tmat3x3<T> result(detail::tmat3x3<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];

  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];

  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  return result;
 }

 template <typename T>
 inline detail::tmat4x4<T> transpose
 (
  detail::tmat4x4<T> const & m
 )
 {
  ;

  detail::tmat4x4<T> result(detail::tmat4x4<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[0][3] = m[3][0];

  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[1][3] = m[3][1];

  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  result[2][3] = m[3][2];

  result[3][0] = m[0][3];
  result[3][1] = m[1][3];
  result[3][2] = m[2][3];
  result[3][3] = m[3][3];
  return result;
 }

 template <typename T>
 inline detail::tmat2x3<T> transpose
 (
  detail::tmat3x2<T> const & m
 )
 {
  ;

  detail::tmat2x3<T> result(detail::tmat2x3<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  return result;
 }

 template <typename T>
 inline detail::tmat3x2<T> transpose
 (
  detail::tmat2x3<T> const & m
 )
 {
  ;

  detail::tmat3x2<T> result(detail::tmat3x2<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  return result;
 }

 template <typename T>
 inline detail::tmat2x4<T> transpose
 (
  detail::tmat4x2<T> const & m
 )
 {
  ;

  detail::tmat2x4<T> result(detail::tmat2x4<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[0][3] = m[3][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[1][3] = m[3][1];
  return result;
 }

 template <typename T>
 inline detail::tmat4x2<T> transpose
 (
  detail::tmat2x4<T> const & m
 )
 {
  ;

  detail::tmat4x2<T> result(detail::tmat4x2<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[3][0] = m[0][3];
  result[3][1] = m[1][3];
  return result;
 }

 template <typename T>
 inline detail::tmat3x4<T> transpose
 (
  detail::tmat4x3<T> const & m
 )
 {
  ;

  detail::tmat3x4<T> result(detail::tmat3x4<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[0][3] = m[3][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[1][3] = m[3][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  result[2][3] = m[3][2];
  return result;
 }

 template <typename T>
 inline detail::tmat4x3<T> transpose
 (
  detail::tmat3x4<T> const & m
 )
 {
  ;

  detail::tmat4x3<T> result(detail::tmat4x3<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  result[3][0] = m[0][3];
  result[3][1] = m[1][3];
  result[3][2] = m[2][3];
  return result;
 }

 template <typename T>
 inline typename detail::tmat2x2<T>::value_type determinant
 (
  detail::tmat2x2<T> const & m
 )
 {
  ;

  return m[0][0] * m[1][1] - m[1][0] * m[0][1];
 }

 template <typename T>
 inline typename detail::tmat3x3<T>::value_type determinant
 (
  detail::tmat3x3<T> const & m
 )
 {
  ;

  return
   + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
   - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
   + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
 }

 template <typename T>
 inline typename detail::tmat4x4<T>::value_type determinant
 (
  detail::tmat4x4<T> const & m
 )
 {
  ;

  T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

  detail::tvec4<T> DetCof(
   + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
   - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
   + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
   - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

  return m[0][0] * DetCof[0]
    + m[0][1] * DetCof[1]
    + m[0][2] * DetCof[2]
    + m[0][3] * DetCof[3];
 }

 template <typename T>
 inline detail::tmat2x2<T> inverse
 (
  detail::tmat2x2<T> const & m
 )
 {
  ;


  T Determinant = determinant(m);

  detail::tmat2x2<T> Inverse(
   + m[1][1] / Determinant,
   - m[0][1] / Determinant,
   - m[1][0] / Determinant,
   + m[0][0] / Determinant);

  return Inverse;
 }

 template <typename T>
 inline detail::tmat3x3<T> inverse
 (
  detail::tmat3x3<T> const & m
 )
 {
  ;





  T Determinant = determinant(m);

  detail::tmat3x3<T> Inverse(detail::tmat3x3<T>::null);
  Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
  Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
  Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
  Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
  Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
  Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
  Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
  Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
  Inverse /= Determinant;

  return Inverse;
 }

 template <typename T>
 inline detail::tmat4x4<T> inverse
 (
  detail::tmat4x4<T> const & m
 )
 {
  ;

  T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

  T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

  T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

  T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

  T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

  T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  detail::tvec4<T> const SignA(+1, -1, +1, -1);
  detail::tvec4<T> const SignB(-1, +1, -1, +1);

  detail::tvec4<T> Fac0(Coef00, Coef00, Coef02, Coef03);
  detail::tvec4<T> Fac1(Coef04, Coef04, Coef06, Coef07);
  detail::tvec4<T> Fac2(Coef08, Coef08, Coef10, Coef11);
  detail::tvec4<T> Fac3(Coef12, Coef12, Coef14, Coef15);
  detail::tvec4<T> Fac4(Coef16, Coef16, Coef18, Coef19);
  detail::tvec4<T> Fac5(Coef20, Coef20, Coef22, Coef23);

  detail::tvec4<T> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
  detail::tvec4<T> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
  detail::tvec4<T> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
  detail::tvec4<T> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

  detail::tvec4<T> Inv0 = SignA * (Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
  detail::tvec4<T> Inv1 = SignB * (Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
  detail::tvec4<T> Inv2 = SignA * (Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
  detail::tvec4<T> Inv3 = SignB * (Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

  detail::tmat4x4<T> Inverse(Inv0, Inv1, Inv2, Inv3);

  detail::tvec4<T> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

  T Determinant = glm::dot(m[0], Row0);

  Inverse /= Determinant;

  return Inverse;
 }
}
# 149 "/usr/include/sgct/glm/./core/func_matrix.hpp" 2 3 4
# 105 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_vector_relational.hpp" 1 3 4
# 46 "/usr/include/sgct/glm/./core/func_vector_relational.hpp" 3 4
namespace glm
{
# 57 "/usr/include/sgct/glm/./core/func_vector_relational.hpp" 3 4
    template <typename vecType>
 typename vecType::bool_type lessThan(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type lessThanEqual(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type greaterThan(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type greaterThanEqual(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type equal(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type notEqual(vecType const & x, vecType const & y);







 template <template <typename> class vecType>
 bool any(vecType<bool> const & v);







 template <template <typename> class vecType>
 bool all(vecType<bool> const & v);
# 130 "/usr/include/sgct/glm/./core/func_vector_relational.hpp" 3 4
 template <template <typename> class vecType>
 vecType<bool> not_(vecType<bool> const & v);


}

# 1 "/usr/include/sgct/glm/./core/func_vector_relational.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_vector_relational.inl" 3 4
namespace glm
{
    template <typename T, template <typename> class vecType>
 inline typename vecType<T>::bool_type lessThan
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {
 
                                                                             ;
 
                                                                                                                           ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/sgct/glm/./core/func_vector_relational.inl", 42, __PRETTY_FUNCTION__));

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];

  return Result;
 }

 template <typename T, template <typename> class vecType>
 inline typename vecType<T>::bool_type lessThanEqual
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {
 
                                                                                  ;
 
                                                                                                                                ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/sgct/glm/./core/func_vector_relational.inl", 62, __PRETTY_FUNCTION__));

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType>
 inline typename vecType<T>::bool_type greaterThan
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {
 
                                                                                ;
 
                                                                                                                              ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/sgct/glm/./core/func_vector_relational.inl", 81, __PRETTY_FUNCTION__));

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType>
 inline typename vecType<T>::bool_type greaterThanEqual
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {
 
                                                                                     ;
 
                                                                                                                                   ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/sgct/glm/./core/func_vector_relational.inl", 100, __PRETTY_FUNCTION__));

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType>
 inline typename vecType<T>::bool_type equal
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {
 
                                                                          ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/sgct/glm/./core/func_vector_relational.inl", 117, __PRETTY_FUNCTION__));

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType>
 inline typename vecType<T>::bool_type notEqual
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {
 
                                                                             ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/sgct/glm/./core/func_vector_relational.inl", 134, __PRETTY_FUNCTION__));

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <template <typename> class vecType>
 inline bool any(vecType<bool> const & v)
 {
 
                                                                                ;

  bool Result = false;
  for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
   Result = Result || v[i];
  return Result;
 }

 template <template <typename> class vecType>
 inline bool all(vecType<bool> const & v)
 {
 
                                                                                ;

  bool Result = true;
  for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
   Result = Result && v[i];
  return Result;
 }

 template <template <typename> class vecType>
 inline vecType<bool> not_(vecType<bool> const & v)
 {
 
                                                                         ;

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 137 "/usr/include/sgct/glm/./core/func_vector_relational.hpp" 2 3 4
# 106 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_integer.hpp" 1 3 4
# 41 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
namespace glm
{
# 54 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename genUType>
 genUType uaddCarry(
  genUType const & x,
  genUType const & y,
  genUType & carry);
# 68 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename genUType>
 genUType usubBorrow(
  genUType const & x,
  genUType const & y,
  genUType & borrow);
# 82 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename genUType>
 void umulExtended(
  genUType const & x,
  genUType const & y,
  genUType & msb,
  genUType & lsb);
# 97 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename genIType>
 void imulExtended(
  genIType const & x,
  genIType const & y,
  genIType & msb,
  genIType & lsb);
# 119 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename genIUType>
 genIUType bitfieldExtract(
  genIUType const & Value,
  int const & Offset,
  int const & Bits);
# 139 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename genIUType>
 genIUType bitfieldInsert(
  genIUType const & Base,
  genIUType const & Insert,
  int const & Offset,
  int const & Bits);
# 154 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename genIUType>
 genIUType bitfieldReverse(genIUType const & value);
# 165 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type bitCount(genIUType<T> const & Value);
# 178 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type findLSB(genIUType<T> const & Value);
# 192 "/usr/include/sgct/glm/./core/func_integer.hpp" 3 4
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type findMSB(genIUType<T> const & Value);


}

# 1 "/usr/include/sgct/glm/./core/func_integer.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_integer.inl" 3 4
# 1 "/usr/include/sgct/glm/./core/_vectorize.hpp" 1 3 4
# 30 "/usr/include/sgct/glm/./core/func_integer.inl" 2 3 4





namespace glm
{

 template <typename genUType>
 inline genUType uaddCarry
 (
  genUType const & x,
  genUType const & y,
  genUType & Carry
 )
 {
  detail::highp_uint_t Value64 = detail::highp_uint_t(x) + detail::highp_uint_t(y);
  genUType Result = genUType(Value64 % (detail::highp_uint_t(1) << detail::highp_uint_t(32)));
  Carry = (Value64 % (detail::highp_uint_t(1) << detail::highp_uint_t(32))) > 1 ? 1 : 0;
  return Result;
 }

 template <typename T>
 inline detail::tvec2<T> uaddCarry
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & Carry
 )
 {
  return detail::tvec2<T>(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]));
 }

 template <typename T>
 inline detail::tvec3<T> uaddCarry
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & Carry
 )
 {
  return detail::tvec3<T>(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]),
   uaddCarry(x[2], y[2], Carry[2]));
 }

 template <typename T>
 inline detail::tvec4<T> uaddCarry
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & Carry
 )
 {
  return detail::tvec4<T>(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]),
   uaddCarry(x[2], y[2], Carry[2]),
   uaddCarry(x[3], y[3], Carry[3]));
 }


 template <typename genUType>
 inline genUType usubBorrow
 (
  genUType const & x,
  genUType const & y,
  genUType & Borrow
 )
 {
  Borrow = x >= y ? 0 : 1;
  if(x > y)
   return genUType(detail::highp_int_t(x) - detail::highp_int_t(y));
  else
   return genUType(detail::highp_int_t(1) << detail::highp_int_t(32) + detail::highp_int_t(x) - detail::highp_int_t(y));
 }

 template <typename T>
 inline detail::tvec2<T> usubBorrow
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & Borrow
 )
 {
  return detail::tvec2<T>(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]));
 }

 template <typename T>
 inline detail::tvec3<T> usubBorrow
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & Borrow
 )
 {
  return detail::tvec3<T>(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]),
   usubBorrow(x[2], y[2], Borrow[2]));
 }

 template <typename T>
 inline detail::tvec4<T> usubBorrow
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & Borrow
 )
 {
  return detail::tvec4<T>(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]),
   usubBorrow(x[2], y[2], Borrow[2]),
   usubBorrow(x[3], y[3], Borrow[3]));
 }


 template <typename genUType>
 inline void umulExtended
 (
  genUType const & x,
  genUType const & y,
  genUType & msb,
  genUType & lsb
 )
 {
  detail::highp_uint_t ValueX64 = x;
  detail::highp_uint_t ValueY64 = y;
  detail::highp_uint_t Value64 = ValueX64 * ValueY64;
  msb = *(genUType*)&genUType(Value64 & ((detail::highp_uint_t(1) << detail::highp_uint_t(32)) - detail::highp_uint_t(1)));
  lsb = *(genUType*)&genUType(Value64 >> detail::highp_uint_t(32));
 }

 template <typename T>
 inline detail::tvec2<T> umulExtended
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & msb,
  detail::tvec2<T> & lsb
 )
 {
  return detail::tvec2<T>(
   umulExtended(x[0], y[0], msb, lsb),
   umulExtended(x[1], y[1], msb, lsb));
 }

 template <typename T>
 inline detail::tvec3<T> umulExtended
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & msb,
  detail::tvec3<T> & lsb
 )
 {
  return detail::tvec3<T>(
   umulExtended(x[0], y[0], msb, lsb),
   umulExtended(x[1], y[1], msb, lsb),
   umulExtended(x[2], y[2], msb, lsb));
 }

 template <typename T>
 inline detail::tvec4<T> umulExtended
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & msb,
  detail::tvec4<T> & lsb
 )
 {
  return detail::tvec4<T>(
   umulExtended(x[0], y[0], msb, lsb),
   umulExtended(x[1], y[1], msb, lsb),
   umulExtended(x[2], y[2], msb, lsb),
   umulExtended(x[3], y[3], msb, lsb));
 }


 template <typename genIType>
 inline void imulExtended
 (
  genIType const & x,
  genIType const & y,
  genIType & msb,
  genIType & lsb
 )
 {
  detail::highp_int_t ValueX64 = x;
  detail::highp_int_t ValueY64 = y;
  detail::highp_int_t Value64 = ValueX64 * ValueY64;
  msb = *(genIType*)&genIType(Value64 & ((detail::highp_uint_t(1) << detail::highp_uint_t(32)) - detail::highp_uint_t(1)));
  lsb = *(genIType*)&genIType(Value64 >> detail::highp_uint_t(32));
 }

 template <typename T>
 inline detail::tvec2<T> imulExtended
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & msb,
  detail::tvec2<T> & lsb
 )
 {
  return detail::tvec2<T>(
   imulExtended(x[0], y[0], msb, lsb),
   imulExtended(x[1], y[1], msb, lsb));
 }

 template <typename T>
 inline detail::tvec3<T> imulExtended
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & msb,
  detail::tvec3<T> & lsb
 )
 {
  return detail::tvec3<T>(
   imulExtended(x[0], y[0], msb, lsb),
   imulExtended(x[1], y[1], msb, lsb),
   imulExtended(x[2], y[2], msb, lsb));
 }

 template <typename T>
 inline detail::tvec4<T> imulExtended
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & msb,
  detail::tvec4<T> & lsb
 )
 {
  return detail::tvec4<T>(
   imulExtended(x[0], y[0], msb, lsb),
   imulExtended(x[1], y[1], msb, lsb),
   imulExtended(x[2], y[2], msb, lsb),
   imulExtended(x[3], y[3], msb, lsb));
 }


 template <typename genIUType>
 inline genIUType bitfieldExtract
 (
  genIUType const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  int GenSize = int(sizeof(genIUType)) << int(3);

  ((Offset + Bits <= GenSize) ? static_cast<void> (0) : __assert_fail ("Offset + Bits <= GenSize", "/usr/include/sgct/glm/./core/func_integer.inl", 287, __PRETTY_FUNCTION__));

  genIUType ShiftLeft = Bits ? Value << (GenSize - (Bits + Offset)) : genIUType(0);
  genIUType ShiftBack = ShiftLeft >> genIUType(GenSize - Bits);

  return ShiftBack;
 }

 template <typename T>
 inline detail::tvec2<T> bitfieldExtract
 (
  detail::tvec2<T> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec2<T>(
   bitfieldExtract(Value[0]),
   bitfieldExtract(Value[1]));
 }

 template <typename T>
 inline detail::tvec3<T> bitfieldExtract
 (
  detail::tvec3<T> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec3<T>(
   bitfieldExtract(Value[0]),
   bitfieldExtract(Value[1]),
   bitfieldExtract(Value[2]));
 }

 template <typename T>
 inline detail::tvec4<T> bitfieldExtract
 (
  detail::tvec4<T> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec4<T>(
   bitfieldExtract(Value[0]),
   bitfieldExtract(Value[1]),
   bitfieldExtract(Value[2]),
   bitfieldExtract(Value[3]));
 }


 template <typename genIUType>
 inline genIUType bitfieldInsert
 (
  genIUType const & Base,
  genIUType const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  ;
  ((Offset + Bits <= sizeof(genIUType)) ? static_cast<void> (0) : __assert_fail ("Offset + Bits <= sizeof(genIUType)", "/usr/include/sgct/glm/./core/func_integer.inl", 348, __PRETTY_FUNCTION__));

  if(Bits == 0)
   return Base;

  genIUType Mask = 0;
  for(int Bit = Offset; Bit < Offset + Bits; ++Bit)
   Mask |= (1 << Bit);

  return (Base & ~Mask) | (Insert & Mask);
 }

 template <typename T>
 inline detail::tvec2<T> bitfieldInsert
 (
  detail::tvec2<T> const & Base,
  detail::tvec2<T> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec2<T>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits));
 }

 template <typename T>
 inline detail::tvec3<T> bitfieldInsert
 (
  detail::tvec3<T> const & Base,
  detail::tvec3<T> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec3<T>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits),
   bitfieldInsert(Base[2], Insert[2], Offset, Bits));
 }

 template <typename T>
 inline detail::tvec4<T> bitfieldInsert
 (
  detail::tvec4<T> const & Base,
  detail::tvec4<T> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec4<T>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits),
   bitfieldInsert(Base[2], Insert[2], Offset, Bits),
   bitfieldInsert(Base[3], Insert[3], Offset, Bits));
 }


 template <typename genIUType>
 inline genIUType bitfieldReverse(genIUType const & Value)
 {
  ;

  genIUType Out = 0;
  std::size_t BitSize = sizeof(genIUType) * 8;
  for(std::size_t i = 0; i < BitSize; ++i)
   if(Value & (genIUType(1) << i))
    Out |= genIUType(1) << (BitSize - 1 - i);
  return Out;
 }

 template <typename T> inline detail::tvec2<T> bitfieldReverse( detail::tvec2<T> const & v) { return detail::tvec2<T>( bitfieldReverse(v.x), bitfieldReverse(v.y)); } template <typename T> inline detail::tvec3<T> bitfieldReverse( detail::tvec3<T> const & v) { return detail::tvec3<T>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z)); } template <typename T> inline detail::tvec4<T> bitfieldReverse( detail::tvec4<T> const & v) { return detail::tvec4<T>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z), bitfieldReverse(v.w)); }


 template <typename genIUType>
 inline int bitCount(genIUType const & Value)
 {
  ;

  int Count = 0;
  for(std::size_t i = 0; i < sizeof(genIUType) * std::size_t(8); ++i)
  {
   if(Value & (1 << i))
    ++Count;
  }
  return Count;
 }

 template <typename T>
 inline detail::tvec2<int> bitCount
 (
  detail::tvec2<T> const & value
 )
 {
  return detail::tvec2<int>(
   bitCount(value[0]),
   bitCount(value[1]));
 }

 template <typename T>
 inline detail::tvec3<int> bitCount
 (
  detail::tvec3<T> const & value
 )
 {
  return detail::tvec3<int>(
   bitCount(value[0]),
   bitCount(value[1]),
   bitCount(value[2]));
 }

 template <typename T>
 inline detail::tvec4<int> bitCount
 (
  detail::tvec4<T> const & value
 )
 {
  return detail::tvec4<int>(
   bitCount(value[0]),
   bitCount(value[1]),
   bitCount(value[2]),
   bitCount(value[3]));
 }


 template <typename genIUType>
 inline int findLSB
 (
  genIUType const & Value
 )
 {
  ;
  if(Value == 0)
   return -1;

  genIUType Bit;
  for(Bit = genIUType(0); !(Value & (1 << Bit)); ++Bit){}
  return Bit;
 }

 template <typename T>
 inline detail::tvec2<int> findLSB
 (
  detail::tvec2<T> const & value
 )
 {
  return detail::tvec2<int>(
   findLSB(value[0]),
   findLSB(value[1]));
 }

 template <typename T>
 inline detail::tvec3<int> findLSB
 (
  detail::tvec3<T> const & value
 )
 {
  return detail::tvec3<int>(
   findLSB(value[0]),
   findLSB(value[1]),
   findLSB(value[2]));
 }

 template <typename T>
 inline detail::tvec4<int> findLSB
 (
  detail::tvec4<T> const & value
 )
 {
  return detail::tvec4<int>(
   findLSB(value[0]),
   findLSB(value[1]),
   findLSB(value[2]),
   findLSB(value[3]));
 }
# 540 "/usr/include/sgct/glm/./core/func_integer.inl" 3 4
 template <typename genIUType>
 inline int findMSB
 (
  genIUType const & Value
 )
 {
  return __builtin_clz(Value);
 }
# 567 "/usr/include/sgct/glm/./core/func_integer.inl" 3 4
 template <typename T>
 inline detail::tvec2<int> findMSB
 (
  detail::tvec2<T> const & value
 )
 {
  return detail::tvec2<int>(
   findMSB(value[0]),
   findMSB(value[1]));
 }

 template <typename T>
 inline detail::tvec3<int> findMSB
 (
  detail::tvec3<T> const & value
 )
 {
  return detail::tvec3<int>(
   findMSB(value[0]),
   findMSB(value[1]),
   findMSB(value[2]));
 }

 template <typename T>
 inline detail::tvec4<int> findMSB
 (
  detail::tvec4<T> const & value
 )
 {
  return detail::tvec4<int>(
   findMSB(value[0]),
   findMSB(value[1]),
   findMSB(value[2]),
   findMSB(value[3]));
 }
}
# 199 "/usr/include/sgct/glm/./core/func_integer.hpp" 2 3 4
# 107 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/func_noise.hpp" 1 3 4
# 41 "/usr/include/sgct/glm/./core/func_noise.hpp" 3 4
namespace glm
{
# 52 "/usr/include/sgct/glm/./core/func_noise.hpp" 3 4
 template <typename genType>
 typename genType::value_type noise1(genType const & x);







 template <typename genType>
 detail::tvec2<typename genType::value_type> noise2(genType const & x);







 template <typename genType>
 detail::tvec3<typename genType::value_type> noise3(genType const & x);







 template <typename genType>
 detail::tvec4<typename genType::value_type> noise4(genType const & x);


}

# 1 "/usr/include/sgct/glm/./core/func_noise.inl" 1 3 4
# 29 "/usr/include/sgct/glm/./core/func_noise.inl" 3 4
namespace glm
{
 template <typename T>
 inline T noise1(T const & x)
 {
  return noise1(glm::detail::tvec2<T>(x, T(0)));
 }

 template <typename T>
 inline glm::detail::tvec2<T> noise2(T const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + T(0.0)),
   noise1(x + T(1.0)));
 }

 template <typename T>
 inline glm::detail::tvec3<T> noise3(T const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - T(1.0)),
   noise1(x + T(0.0)),
   noise1(x + T(1.0)));
 }

 template <typename T>
 inline glm::detail::tvec4<T> noise4(T const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - T(1.0)),
   noise1(x + T(0.0)),
   noise1(x + T(1.0)),
   noise1(x + T(2.0)));
 }

 template <typename T>
 inline T noise1(glm::detail::tvec2<T> const & v)
 {
  detail::tvec4<T> const C = detail::tvec4<T>(
             T( 0.211324865405187),
             T( 0.366025403784439),
             T(-0.577350269189626),
             T( 0.024390243902439));


  detail::tvec2<T> i = floor(v + dot(v, detail::tvec2<T>(C[1])));
  detail::tvec2<T> x0 = v - i + dot(i, detail::tvec2<T>(C[0]));




  detail::tvec2<T> i1 = (x0.x > x0.y) ? detail::tvec2<T>(1, 0) : detail::tvec2<T>(0, 1);



  detail::tvec4<T> x12 = detail::tvec4<T>(x0.x, x0.y, x0.x, x0.y) + detail::tvec4<T>(C.x, C.x, C.z, C.z);
  x12 = detail::tvec4<T>(detail::tvec2<T>(x12) - i1, x12.z, x12.w);


  i = mod(i, T(289));
  detail::tvec3<T> p = permute(
          permute(i.y + detail::tvec3<T>(T(0), i1.y, T(1)))
          + i.x + detail::tvec3<T>(T(0), i1.x, T(1)));

  detail::tvec3<T> m = max(T(0.5) - detail::tvec3<T>(
                 dot(x0, x0),
                 dot(detail::tvec2<T>(x12.x, x12.y), detail::tvec2<T>(x12.x, x12.y)),
                 dot(detail::tvec2<T>(x12.z, x12.w), detail::tvec2<T>(x12.z, x12.w))), T(0));
  m = m * m ;
  m = m * m ;




  detail::tvec3<T> x = T(2) * fract(p * C.w) - T(1);
  detail::tvec3<T> h = abs(x) - T(0.5);
  detail::tvec3<T> ox = floor(x + T(0.5));
  detail::tvec3<T> a0 = x - ox;



  m *= T(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);


  detail::tvec3<T> g;
  g.x = a0.x * x0.x + h.x * x0.y;

  g.y = a0.y * x12.x + h.y * x12.y;
  g.z = a0.z * x12.z + h.z * x12.w;
  return T(130) * dot(m, g);
 }

 template <typename T>
 inline T noise1(detail::tvec3<T> const & v)
 {
  detail::tvec2<T> const C(1.0 / 6.0, 1.0 / 3.0);
  detail::tvec4<T> const D(0.0, 0.5, 1.0, 2.0);


  detail::tvec3<T> i(floor(v + dot(v, detail::tvec3<T>(C.y))));
  detail::tvec3<T> x0(v - i + dot(i, detail::tvec3<T>(C.x)));


  detail::tvec3<T> g(step(detail::tvec3<T>(x0.y, x0.z, x0.x), x0));
  detail::tvec3<T> l(T(1) - g);
  detail::tvec3<T> i1(min(g, detail::tvec3<T>(l.z, l.x, l.y)));
  detail::tvec3<T> i2(max(g, detail::tvec3<T>(l.z, l.x, l.y)));





  detail::tvec3<T> x1(x0 - i1 + C.x);
  detail::tvec3<T> x2(x0 - i2 + C.y);
  detail::tvec3<T> x3(x0 - D.y);


  i = mod289(i);
  detail::tvec4<T> p(permute(permute(permute(
               i.z + detail::tvec4<T>(T(0), i1.z, i2.z, T(1))) +
             i.y + detail::tvec4<T>(T(0), i1.y, i2.y, T(1))) +
           i.x + detail::tvec4<T>(T(0), i1.x, i2.x, T(1))));



  T n_ = T(0.142857142857);
  detail::tvec3<T> ns(n_ * detail::tvec3<T>(D.w, D.y, D.z) - detail::tvec3<T>(D.x, D.z, D.x));

  detail::tvec4<T> j(p - T(49) * floor(p * ns.z * ns.z));

  detail::tvec4<T> x_(floor(j * ns.z));
  detail::tvec4<T> y_(floor(j - T(7) * x_));

  detail::tvec4<T> x(x_ * ns.x + ns.y);
  detail::tvec4<T> y(y_ * ns.x + ns.y);
  detail::tvec4<T> h(T(1) - abs(x) - abs(y));

  detail::tvec4<T> b0(x.x, x.y, y.x, y.y);
  detail::tvec4<T> b1(x.z, x.w, y.z, y.w);



  detail::tvec4<T> s0(floor(b0) * T(2) + T(1));
  detail::tvec4<T> s1(floor(b1) * T(2) + T(1));
  detail::tvec4<T> sh(-step(h, detail::tvec4<T>(0.0)));

  detail::tvec4<T> a0 = detail::tvec4<T>(b0.x, b0.z, b0.y, b0.w) + detail::tvec4<T>(s0.x, s0.z, s0.y, s0.w) * detail::tvec4<T>(sh.x, sh.x, sh.y, sh.y);
  detail::tvec4<T> a1 = detail::tvec4<T>(b1.x, b1.z, b1.y, b1.w) + detail::tvec4<T>(s1.x, s1.z, s1.y, s1.w) * detail::tvec4<T>(sh.z, sh.z, sh.w, sh.w);

  detail::tvec3<T> p0(a0.x, a0.y, h.x);
  detail::tvec3<T> p1(a0.z, a0.w, h.y);
  detail::tvec3<T> p2(a1.x, a1.y, h.z);
  detail::tvec3<T> p3(a1.z, a1.w, h.w);


  detail::tvec4<T> norm = taylorInvSqrt(detail::tvec4<T>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;


  detail::tvec4<T> m = max(T(0.6) - detail::tvec4<T>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), T(0));
  m = m * m;
  return T(42) * dot(m * m, detail::tvec4<T>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
 }

 template <typename T>
 inline T noise1(detail::tvec4<T> const & v)
 {
  detail::tvec4<T> const C(
         0.138196601125011,
         0.276393202250021,
         0.414589803375032,
         -0.447213595499958);


  T const F4 = T(0.309016994374947451);


  detail::tvec4<T> i = floor(v + dot(v, vec4(F4)));
  detail::tvec4<T> x0 = v - i + dot(i, vec4(C.x));




  detail::tvec4<T> i0;
  detail::tvec3<T> isX = step(detail::tvec3<T>(x0.y, x0.z, x0.w), detail::tvec3<T>(x0.x));
  detail::tvec3<T> isYZ = step(detail::tvec3<T>(x0.z, x0.w, x0.w), detail::tvec3<T>(x0.y, x0.y, x0.z));



  i0 = detail::tvec4<T>(isX.x + isX.y + isX.z, T(1) - isX);

  i0.y += isYZ.x + isYZ.y;

  i0.z += T(1) - isYZ.x;
  i0.w += T(1) - isYZ.y;
  i0.z += isYZ.z;
  i0.w += T(1) - isYZ.z;


  detail::tvec4<T> i3 = clamp(i0, 0.0, 1.0);
  detail::tvec4<T> i2 = clamp(i0 - 1.0, 0.0, 1.0);
  detail::tvec4<T> i1 = clamp(i0 - 2.0, 0.0, 1.0);






  detail::tvec4<T> x1 = x0 - i1 + C.x;
  detail::tvec4<T> x2 = x0 - i2 + C.y;
  detail::tvec4<T> x3 = x0 - i3 + C.z;
  detail::tvec4<T> x4 = x0 + C.w;


  i = mod(i, T(289));
  T j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);
  detail::tvec4<T> j1 = permute(permute(permute(permute(
                 i.w + detail::tvec4<T>(i1.w, i2.w, i3.w, T(1)))
               + i.z + detail::tvec4<T>(i1.z, i2.z, i3.z, T(1)))
             + i.y + detail::tvec4<T>(i1.y, i2.y, i3.y, T(1)))
           + i.x + detail::tvec4<T>(i1.x, i2.x, i3.x, T(1)));



  detail::tvec4<T> ip = detail::tvec4<T>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));

  detail::tvec4<T> p0 = grad4(j0, ip);
  detail::tvec4<T> p1 = grad4(j1.x, ip);
  detail::tvec4<T> p2 = grad4(j1.y, ip);
  detail::tvec4<T> p3 = grad4(j1.z, ip);
  detail::tvec4<T> p4 = grad4(j1.w, ip);


  detail::tvec4<T> norm = taylorInvSqrt(detail::tvec4<T>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4, p4));


  detail::tvec3<T> m0 = max(T(0.6) - detail::tvec3<T>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), T(0));
  detail::tvec2<T> m1 = max(T(0.6) - detail::tvec2<T>(dot(x3, x3), dot(x4, x4) ), T(0));
  m0 = m0 * m0;
  m1 = m1 * m1;
  return T(49) *
  (dot(m0 * m0, detail::tvec3<T>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) +
   dot(m1 * m1, detail::tvec2<T>(dot(p3, x3), dot(p4, x4))));
 }

 template <typename T>
 inline glm::detail::tvec2<T> noise2(glm::detail::tvec2<T> const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + glm::detail::tvec2<T>(0.0)),
   noise1(glm::detail::tvec2<T>(0.0) - x));
 }

 template <typename T>
 inline glm::detail::tvec2<T> noise2(glm::detail::tvec3<T> const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + glm::detail::tvec3<T>(0.0)),
   noise1(glm::detail::tvec3<T>(0.0) - x));
 }

 template <typename T>
 inline glm::detail::tvec2<T> noise2(glm::detail::tvec4<T> const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + glm::detail::tvec4<T>(0.0)),
   noise1(glm::detail::tvec4<T>(0.0) - x));
 }

 template <typename T>
 inline glm::detail::tvec3<T> noise3(glm::detail::tvec2<T> const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - glm::detail::tvec2<T>(1.0)),
   noise1(x + glm::detail::tvec2<T>(0.0)),
   noise1(x + glm::detail::tvec2<T>(1.0)));
 }

 template <typename T>
 inline glm::detail::tvec3<T> noise3(glm::detail::tvec3<T> const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - glm::detail::tvec3<T>(1.0)),
   noise1(x + glm::detail::tvec3<T>(0.0)),
   noise1(x + glm::detail::tvec3<T>(1.0)));
 }

 template <typename T>
 inline glm::detail::tvec3<T> noise3(glm::detail::tvec4<T> const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - glm::detail::tvec4<T>(1.0)),
   noise1(x + glm::detail::tvec4<T>(0.0)),
   noise1(x + glm::detail::tvec4<T>(1.0)));
 }

 template <typename T>
 inline glm::detail::tvec4<T> noise4(glm::detail::tvec2<T> const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - glm::detail::tvec2<T>(1.0)),
   noise1(x + glm::detail::tvec2<T>(0.0)),
   noise1(x + glm::detail::tvec2<T>(1.0)),
   noise1(x + glm::detail::tvec2<T>(2.0)));
 }


 template <typename T>
 inline glm::detail::tvec4<T> noise4(glm::detail::tvec3<T> const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - glm::detail::tvec3<T>(1.0)),
   noise1(x + glm::detail::tvec3<T>(0.0)),
   noise1(x + glm::detail::tvec3<T>(1.0)),
   noise1(x + glm::detail::tvec3<T>(2.0)));
 }

 template <typename T>
 inline glm::detail::tvec4<T> noise4(glm::detail::tvec4<T> const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - glm::detail::tvec4<T>(1.0)),
   noise1(x + glm::detail::tvec4<T>(0.0)),
   noise1(x + glm::detail::tvec4<T>(1.0)),
   noise1(x + glm::detail::tvec4<T>(2.0)));
 }

}
# 86 "/usr/include/sgct/glm/./core/func_noise.hpp" 2 3 4
# 108 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/./core/_swizzle.hpp" 1 3 4
# 109 "/usr/include/sgct/glm/glm.hpp" 2 3 4
# 6 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 2
# 1 "/usr/include/sgct/glm/gtc/quaternion.hpp" 1 3 4
# 43 "/usr/include/sgct/glm/gtc/quaternion.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../glm.hpp" 1 3 4
# 78 "/usr/include/sgct/glm/gtc/../glm.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 30 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 2 3 4
# 79 "/usr/include/sgct/glm/gtc/../glm.hpp" 2 3 4
# 44 "/usr/include/sgct/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/gtc/../gtc/half_float.hpp" 1 3 4
# 41 "/usr/include/sgct/glm/gtc/../gtc/half_float.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../gtc/../glm.hpp" 1 3 4
# 78 "/usr/include/sgct/glm/gtc/../gtc/../glm.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../gtc/../core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/gtc/../gtc/../core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 30 "/usr/include/sgct/glm/gtc/../gtc/../core/_fixes.hpp" 2 3 4
# 79 "/usr/include/sgct/glm/gtc/../gtc/../glm.hpp" 2 3 4
# 42 "/usr/include/sgct/glm/gtc/../gtc/half_float.hpp" 2 3 4





namespace glm{
namespace detail
{

 template <>
 struct tvec2<half>
 {
  enum ctor{null};
  typedef half value_type;
  typedef std::size_t size_type;

        size_type length() const;
  static size_type value_size();

  typedef tvec2<half> type;
  typedef tvec2<bool> bool_type;




  half x, y;




  half & operator[](size_type i);
  half const & operator[](size_type i) const;




  tvec2();
  tvec2(tvec2<half> const & v);




  explicit tvec2(ctor);
  explicit tvec2(
   half const & s);
  explicit tvec2(
   half const & s1,
   half const & s2);




  tvec2(tref2<half> const & r);





  template <typename U>
  explicit tvec2(U const & x);

  template <typename U, typename V>
  explicit tvec2(U const & x, V const & y);





  template <typename U>
  explicit tvec2(tvec2<U> const & v);

  template <typename U>
  explicit tvec2(tvec3<U> const & v);

  template <typename U>
  explicit tvec2(tvec4<U> const & v);




  tvec2<half>& operator= (tvec2<half> const & v);

  tvec2<half>& operator+=(half const & s);
  tvec2<half>& operator+=(tvec2<half> const & v);
  tvec2<half>& operator-=(half const & s);
  tvec2<half>& operator-=(tvec2<half> const & v);
  tvec2<half>& operator*=(half const & s);
  tvec2<half>& operator*=(tvec2<half> const & v);
  tvec2<half>& operator/=(half const & s);
  tvec2<half>& operator/=(tvec2<half> const & v);
  tvec2<half>& operator++();
  tvec2<half>& operator--();




  half swizzle(comp X) const;
  tvec2<half> swizzle(comp X, comp Y) const;
  tvec3<half> swizzle(comp X, comp Y, comp Z) const;
  tvec4<half> swizzle(comp X, comp Y, comp Z, comp W) const;
  tref2<half> swizzle(comp X, comp Y);
 };

 template <>
 struct tvec3<half>
 {
  enum ctor{null};
  typedef half value_type;
  typedef std::size_t size_type;
        size_type length() const;
  static size_type value_size();

  typedef tvec3<half> type;
  typedef tvec3<bool> bool_type;




  half x, y, z;




  half & operator[](size_type i);
  half const & operator[](size_type i) const;




  tvec3();
  tvec3(tvec3<half> const & v);




  explicit tvec3(ctor);
  explicit tvec3(
   half const & s);
  explicit tvec3(
   half const & s1,
   half const & s2,
   half const & s3);




  tvec3(tref3<half> const & r);





  template <typename U>
  explicit tvec3(U const & x);

  template <typename U, typename V, typename W>
  explicit tvec3(U const & x, V const & y, W const & z);





  template <typename A, typename B>
  explicit tvec3(tvec2<A> const & v, B const & s);

  template <typename A, typename B>
  explicit tvec3(A const & s, tvec2<B> const & v);

  template <typename U>
  explicit tvec3(tvec3<U> const & v);

  template <typename U>
  explicit tvec3(tvec4<U> const & v);




  tvec3<half>& operator= (tvec3<half> const & v);

  tvec3<half>& operator+=(half const & s);
  tvec3<half>& operator+=(tvec3<half> const & v);
  tvec3<half>& operator-=(half const & s);
  tvec3<half>& operator-=(tvec3<half> const & v);
  tvec3<half>& operator*=(half const & s);
  tvec3<half>& operator*=(tvec3<half> const & v);
  tvec3<half>& operator/=(half const & s);
  tvec3<half>& operator/=(tvec3<half> const & v);
  tvec3<half>& operator++();
  tvec3<half>& operator--();




  half swizzle(comp X) const;
  tvec2<half> swizzle(comp X, comp Y) const;
  tvec3<half> swizzle(comp X, comp Y, comp Z) const;
  tvec4<half> swizzle(comp X, comp Y, comp Z, comp W) const;
  tref3<half> swizzle(comp X, comp Y, comp Z);
 };

 template <>
 struct tvec4<half>
 {
  enum ctor{null};
  typedef half value_type;
  typedef std::size_t size_type;
        size_type length() const;
  static size_type value_size();

  typedef tvec4<half> type;
  typedef tvec4<bool> bool_type;




  half x, y, z, w;




  half & operator[](size_type i);
  half const & operator[](size_type i) const;




  tvec4();
  tvec4(tvec4<half> const & v);




  explicit tvec4(ctor);
  explicit tvec4(
   half const & s);
  explicit tvec4(
   half const & s0,
   half const & s1,
   half const & s2,
   half const & s3);




  tvec4(tref4<half> const & r);





  template <typename U>
  explicit tvec4(U const & x);

  template <typename A, typename B, typename C, typename D>
  explicit tvec4(A const & x, B const & y, C const & z, D const & w);





  template <typename A, typename B, typename C>
  explicit tvec4(tvec2<A> const & v, B const & s1, C const & s2);

  template <typename A, typename B, typename C>
  explicit tvec4(A const & s1, tvec2<B> const & v, C const & s2);

  template <typename A, typename B, typename C>
  explicit tvec4(A const & s1, B const & s2, tvec2<C> const & v);

  template <typename A, typename B>
  explicit tvec4(tvec3<A> const & v, B const & s);

  template <typename A, typename B>
  explicit tvec4(A const & s, tvec3<B> const & v);

  template <typename A, typename B>
  explicit tvec4(tvec2<A> const & v1, tvec2<B> const & v2);

  template <typename U>
  explicit tvec4(tvec4<U> const & v);




  tvec4<half>& operator= (tvec4<half> const & v);

  tvec4<half>& operator+=(half const & s);
  tvec4<half>& operator+=(tvec4<half> const & v);
  tvec4<half>& operator-=(half const & s);
  tvec4<half>& operator-=(tvec4<half> const & v);
  tvec4<half>& operator*=(half const & s);
  tvec4<half>& operator*=(tvec4<half> const & v);
  tvec4<half>& operator/=(half const & s);
  tvec4<half>& operator/=(tvec4<half> const & v);
  tvec4<half>& operator++();
  tvec4<half>& operator--();




  half swizzle(comp X) const;
  tvec2<half> swizzle(comp X, comp Y) const;
  tvec3<half> swizzle(comp X, comp Y, comp Z) const;
  tvec4<half> swizzle(comp X, comp Y, comp Z, comp W) const;
  tref4<half> swizzle(comp X, comp Y, comp Z, comp W);
 };

}







 typedef detail::half half;



 typedef detail::tvec2<detail::half> hvec2;



 typedef detail::tvec3<detail::half> hvec3;



 typedef detail::tvec4<detail::half> hvec4;



 typedef detail::tmat2x2<detail::half> hmat2;



 typedef detail::tmat3x3<detail::half> hmat3;



 typedef detail::tmat4x4<detail::half> hmat4;



 typedef detail::tmat2x2<detail::half> hmat2x2;



 typedef detail::tmat2x3<detail::half> hmat2x3;



 typedef detail::tmat2x4<detail::half> hmat2x4;



 typedef detail::tmat3x2<detail::half> hmat3x2;



 typedef detail::tmat3x3<detail::half> hmat3x3;



 typedef detail::tmat3x4<detail::half> hmat3x4;



 typedef detail::tmat4x2<detail::half> hmat4x2;



 typedef detail::tmat4x3<detail::half> hmat4x3;



 typedef detail::tmat4x4<detail::half> hmat4x4;


}

# 1 "/usr/include/sgct/glm/gtc/../gtc/half_float.inl" 1 3 4
# 29 "/usr/include/sgct/glm/gtc/../gtc/half_float.inl" 3 4
namespace glm{
namespace detail
{





 inline tvec2<half>::size_type tvec2<half>::length() const
 {
  return 2;
 }

 inline tvec2<half>::size_type tvec2<half>::value_size()
 {
  return 2;
 }




 inline half & tvec2<half>::operator[](tvec2<half>::size_type i)
 {
  ((i < tvec2<half>::value_size()) ? static_cast<void> (0) : __assert_fail ("i < tvec2<half>::value_size()", "/usr/include/sgct/glm/gtc/../gtc/half_float.inl", 52, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 inline half const & tvec2<half>::operator[](tvec2<half>::size_type i) const
 {
  ((i < tvec2<half>::value_size()) ? static_cast<void> (0) : __assert_fail ("i < tvec2<half>::value_size()", "/usr/include/sgct/glm/gtc/../gtc/half_float.inl", 58, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 inline tvec2<half>::tvec2() :
  x(half(0.f)),
  y(half(0.f))
 {}

 inline tvec2<half>::tvec2
 (
  tvec2<half> const & v
 ) :
  x(v.x),
  y(v.y)
 {}




 inline tvec2<half>::tvec2
 (
  half const & s
 ) :
  x(s),
  y(s)
 {}

 inline tvec2<half>::tvec2
 (
  half const & s1,
  half const & s2
 ) :
  x(s1),
  y(s2)
 {}




 inline tvec2<half>::tvec2
 (
  tref2<half> const & r
 ) :
  x(r.x),
  y(r.y)
 {}




 template <typename U>
 inline tvec2<half>::tvec2
 (
  U const & x
 ) :
  x(half(x)),
  y(half(x))
 {}

 template <typename U, typename V>
 inline tvec2<half>::tvec2
 (
  U const & x,
  V const & y
 ) :
  x(half(x)),
  y(half(y))
 {}




 template <typename U>
 inline tvec2<half>::tvec2
 (
  tvec2<U> const & v
 ) :
  x(half(v.x)),
  y(half(v.y))
 {}

 template <typename U>
 inline tvec2<half>::tvec2
 (
  tvec3<U> const & v
 ) :
  x(half(v.x)),
  y(half(v.y))
 {}

 template <typename U>
 inline tvec2<half>::tvec2
 (
  tvec4<U> const & v
 ) :
  x(half(v.x)),
  y(half(v.y))
 {}




 inline tvec2<half> & tvec2<half>::operator=
 (
  tvec2<half> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator+=
 (
  half const & s
 )
 {
  this->x += s;
  this->y += s;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator+=
 (
  tvec2<half> const & v
 )
 {
  this->x += v.x;
  this->y += v.y;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator-=
 (
  half const & s
 )
 {
  this->x -= s;
  this->y -= s;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator-=
 (
  tvec2<half> const & v
 )
 {
  this->x -= v.x;
  this->y -= v.y;
  return *this;
 }

 inline tvec2<half>& tvec2<half>::operator*=
 (
  half const & s
 )
 {
  this->x *= s;
  this->y *= s;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator*=
 (
  tvec2<half> const & v
 )
 {
  this->x *= v.x;
  this->y *= v.y;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator/=
 (
  half const & s
 )
 {
  this->x /= s;
  this->y /= s;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator/=
 (
  tvec2<half> const & v
 )
 {
  this->x /= v.x;
  this->y /= v.y;
  return *this;
 }

 inline tvec2<half> & tvec2<half>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 inline tvec2<half>& tvec2<half>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }




 inline half tvec2<half>::swizzle(comp x) const
 {
  return (*this)[x];
 }

 inline tvec2<half> tvec2<half>::swizzle(comp x, comp y) const
 {
  return tvec2<half>(
   (*this)[x],
   (*this)[y]);
 }

 inline tvec3<half> tvec2<half>::swizzle(comp x, comp y, comp z) const
 {
  return tvec3<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 inline tvec4<half> tvec2<half>::swizzle(comp x, comp y, comp z, comp w) const
 {
  return tvec4<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 inline tref2<half> tvec2<half>::swizzle(comp x, comp y)
 {
  return tref2<half>(
   (*this)[x],
   (*this)[y]);
 }




 inline tvec3<half>::size_type tvec3<half>::length() const
 {
  return 3;
 }

 inline tvec3<half>::size_type tvec3<half>::value_size()
 {
  return 3;
 }




 inline half & tvec3<half>::operator[]
 (
  tvec3<half>::size_type i
 )
 {
  ((i < tvec3<half>::value_size()) ? static_cast<void> (0) : __assert_fail ("i < tvec3<half>::value_size()", "/usr/include/sgct/glm/gtc/../gtc/half_float.inl", 328, __PRETTY_FUNCTION__));

  return (&x)[i];
 }

 inline half const & tvec3<half>::operator[]
 (
  tvec3<half>::size_type i
 ) const
 {
  ((i < tvec3<half>::value_size()) ? static_cast<void> (0) : __assert_fail ("i < tvec3<half>::value_size()", "/usr/include/sgct/glm/gtc/../gtc/half_float.inl", 338, __PRETTY_FUNCTION__));

  return (&x)[i];
 }




 inline tvec3<half>::tvec3() :
  x(half(0)),
  y(half(0)),
  z(half(0))
 {}

 inline tvec3<half>::tvec3
 (
  tvec3<half> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z)
 {}




 inline tvec3<half>::tvec3
 (
  half const & s
 ) :
  x(s),
  y(s),
  z(s)
 {}

 inline tvec3<half>::tvec3
 (
  half const & s0,
  half const & s1,
  half const & s2
 ) :
  x(s0),
  y(s1),
  z(s2)
 {}




 inline tvec3<half>::tvec3
 (
  tref3<half> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z)
 {}




 template <typename U>
 inline tvec3<half>::tvec3
 (
  U const & x
 ) :
  x(half(x)),
  y(half(x)),
  z(half(x))
 {}

 template <typename A, typename B, typename C>
 inline tvec3<half>::tvec3
 (
  A const & x,
  B const & y,
  C const & z
 ) :
  x(half(x)),
  y(half(y)),
  z(half(z))
 {}




 template <typename A, typename B>
 inline tvec3<half>::tvec3
 (
  tvec2<A> const & v,
  B const & s
 ) :
  x(half(v.x)),
  y(half(v.y)),
  z(half(s))
 {}

 template <typename A, typename B>
 inline tvec3<half>::tvec3
 (
  A const & s,
  tvec2<B> const & v
 ) :
  x(half(s)),
  y(half(v.x)),
  z(half(v.y))
 {}

 template <typename U>
 inline tvec3<half>::tvec3
 (
  tvec3<U> const & v
 ) :
  x(half(v.x)),
  y(half(v.y)),
  z(half(v.z))
 {}

 template <typename U>
 inline tvec3<half>::tvec3
 (
  tvec4<U> const & v
 ) :
  x(half(v.x)),
  y(half(v.y)),
  z(half(v.z))
 {}




 inline tvec3<half> & tvec3<half>::operator=
 (
  tvec3<half> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator+=
 (
  half const & s
 )
 {
  this->x += s;
  this->y += s;
  this->z += s;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator+=
 (
  tvec3<half> const & v
 )
 {
  this->x += v.x;
  this->y += v.y;
  this->z += v.z;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator-=
 (
  half const & s
 )
 {
  this->x -= s;
  this->y -= s;
  this->z -= s;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator-=
 (
  tvec3<half> const & v
 )
 {
  this->x -= v.x;
  this->y -= v.y;
  this->z -= v.z;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator*=
 (
  half const & s
 )
 {
  this->x *= s;
  this->y *= s;
  this->z *= s;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator*=
 (
  tvec3<half> const & v
 )
 {
  this->x *= v.x;
  this->y *= v.y;
  this->z *= v.z;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator/=
 (
  half const & s
 )
 {
  this->x /= s;
  this->y /= s;
  this->z /= s;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator/=
 (
  tvec3<half> const & v
 )
 {
  this->x /= v.x;
  this->y /= v.y;
  this->z /= v.z;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 inline tvec3<half> & tvec3<half>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }




 inline half tvec3<half>::swizzle(comp x) const
 {
  return (*this)[x];
 }

 inline tvec2<half> tvec3<half>::swizzle(comp x, comp y) const
 {
  return tvec2<half>(
   (*this)[x],
   (*this)[y]);
 }

 inline tvec3<half> tvec3<half>::swizzle(comp x, comp y, comp z) const
 {
  return tvec3<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 inline tvec4<half> tvec3<half>::swizzle(comp x, comp y, comp z, comp w) const
 {
  return tvec4<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 inline tref3<half> tvec3<half>::swizzle(comp x, comp y, comp z)
 {
  return tref3<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }




 inline tvec4<half>::size_type tvec4<half>::length() const
 {
  return 4;
 }

 inline tvec4<half>::size_type tvec4<half>::value_size()
 {
  return 4;
 }




 inline half & tvec4<half>::operator[]
 (
  tvec4<half>::size_type i
 )
 {
  ((i < tvec4<half>::value_size()) ? static_cast<void> (0) : __assert_fail ("i < tvec4<half>::value_size()", "/usr/include/sgct/glm/gtc/../gtc/half_float.inl", 645, __PRETTY_FUNCTION__));

  return (&x)[i];
 }

 inline half const & tvec4<half>::operator[]
 (
  tvec4<half>::size_type i
 ) const
 {
  ((i < tvec4<half>::value_size()) ? static_cast<void> (0) : __assert_fail ("i < tvec4<half>::value_size()", "/usr/include/sgct/glm/gtc/../gtc/half_float.inl", 655, __PRETTY_FUNCTION__));

  return (&x)[i];
 }




 inline tvec4<half>::tvec4() :
  x(half(0)),
  y(half(0)),
  z(half(0)),
  w(half(0))
 {}

 inline tvec4<half>::tvec4
 (
  tvec4<half> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z),
  w(v.w)
 {}




 inline tvec4<half>::tvec4
 (
  half const & s
 ) :
  x(s),
  y(s),
  z(s),
  w(s)
 {}

 inline tvec4<half>::tvec4
 (
  half const & s1,
  half const & s2,
  half const & s3,
  half const & s4
 ) :
  x(s1),
  y(s2),
  z(s3),
  w(s4)
 {}




 inline tvec4<half>::tvec4
 (
  tref4<half> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z),
  w(r.w)
 {}




 template <typename U>
 inline tvec4<half>::tvec4
 (
  U const & x
 ) :
  x(half(x)),
  y(half(x)),
  z(half(x)),
  w(half(x))
 {}

 template <typename A, typename B, typename C, typename D>
 inline tvec4<half>::tvec4
 (
  A const & x,
  B const & y,
  C const & z,
  D const & w
 ) :
  x(half(x)),
  y(half(y)),
  z(half(z)),
  w(half(w))
 {}




 template <typename A, typename B, typename C>
 inline tvec4<half>::tvec4
 (
  tvec2<A> const & v,
  B const & s1,
  C const & s2
 ) :
  x(half(v.x)),
  y(half(v.y)),
  z(half(s1)),
  w(half(s2))
 {}

 template <typename A, typename B, typename C>
 inline tvec4<half>::tvec4
 (
  A const & s1,
  tvec2<B> const & v,
  C const & s2
 ) :
  x(half(s1)),
  y(half(v.x)),
  z(half(v.y)),
  w(half(s2))
 {}

 template <typename A, typename B, typename C>
 inline tvec4<half>::tvec4
 (
  A const & s1,
  B const & s2,
  tvec2<C> const & v
 ) :
  x(half(s1)),
  y(half(s2)),
  z(half(v.x)),
  w(half(v.y))
 {}

 template <typename A, typename B>
 inline tvec4<half>::tvec4
 (
  tvec3<A> const & v,
  B const & s
 ) :
  x(half(v.x)),
  y(half(v.y)),
  z(half(v.z)),
  w(half(s))
 {}

 template <typename A, typename B>
 inline tvec4<half>::tvec4
 (
  A const & s,
  tvec3<B> const & v
 ) :
  x(half(s)),
  y(half(v.x)),
  z(half(v.y)),
  w(half(v.z))
 {}

 template <typename A, typename B>
 inline tvec4<half>::tvec4
 (
  tvec2<A> const & v1,
  tvec2<B> const & v2
 ) :
  x(half(v1.x)),
  y(half(v1.y)),
  z(half(v2.x)),
  w(half(v2.y))
 {}

 template <typename U>
 inline tvec4<half>::tvec4
 (
  tvec4<U> const & v
 ) :
  x(half(v.x)),
  y(half(v.y)),
  z(half(v.z)),
  w(half(v.w))
 {}




 inline tvec4<half>& tvec4<half>::operator=
 (
  tvec4<half> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  this->w = v.w;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator+=
 (
  half const & s
 )
 {
  this->x += s;
  this->y += s;
  this->z += s;
  this->w += s;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator+=
 (
  tvec4<half> const & v
 )
 {
  this->x += v.x;
  this->y += v.y;
  this->z += v.z;
  this->w += v.w;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator-=
 (
  half const & s
 )
 {
  this->x -= s;
  this->y -= s;
  this->z -= s;
  this->w -= s;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator-=
 (
  tvec4<half> const & v
 )
 {
  this->x -= v.x;
  this->y -= v.y;
  this->z -= v.z;
  this->w -= v.w;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator*=
 (
  half const & s
 )
 {
  this->x *= s;
  this->y *= s;
  this->z *= s;
  this->w *= s;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator*=
 (
  tvec4<half> const & v
 )
 {
  this->x *= v.x;
  this->y *= v.y;
  this->z *= v.z;
  this->w *= v.w;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator/=
 (
  half const & s
 )
 {
  this->x /= s;
  this->y /= s;
  this->z /= s;
  this->w /= s;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator/=
 (
  tvec4<half> const & v
 )
 {
  this->x /= v.x;
  this->y /= v.y;
  this->z /= v.z;
  this->w /= v.w;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 inline tvec4<half>& tvec4<half>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }




 inline half tvec4<half>::swizzle(comp x) const
 {
  return (*this)[x];
 }

 inline tvec2<half> tvec4<half>::swizzle(comp x, comp y) const
 {
  return tvec2<half>(
   (*this)[x],
   (*this)[y]);
 }

 inline tvec3<half> tvec4<half>::swizzle(comp x, comp y, comp z) const
 {
  return tvec3<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 inline tvec4<half> tvec4<half>::swizzle(comp x, comp y, comp z, comp w) const
 {
  return tvec4<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 inline tref4<half> tvec4<half>::swizzle(comp x, comp y, comp z, comp w)
 {
  return tref4<half>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }



}
}
# 423 "/usr/include/sgct/glm/gtc/../gtc/half_float.hpp" 2 3 4
# 45 "/usr/include/sgct/glm/gtc/quaternion.hpp" 2 3 4





namespace glm{
namespace detail
{



 template <typename T>
 struct tquat
 {
        enum ctor{null};

        typedef T value_type;
        typedef std::size_t size_type;

 public:
  value_type x, y, z, w;

        size_type length() const;


  tquat();
  explicit tquat(
   value_type const & s,
   glm::detail::tvec3<T> const & v);
  explicit tquat(
   value_type const & w,
   value_type const & x,
   value_type const & y,
   value_type const & z);




  explicit tquat(
   tvec3<T> const & eulerAngles);
  explicit tquat(
   tmat3x3<T> const & m);
  explicit tquat(
   tmat4x4<T> const & m);


  value_type & operator[](int i);
  value_type const & operator[](int i) const;


  tquat<T> & operator*=(value_type const & s);
  tquat<T> & operator/=(value_type const & s);
 };

 template <typename T>
 detail::tquat<T> operator- (
  detail::tquat<T> const & q);

 template <typename T>
 detail::tquat<T> operator+ (
  detail::tquat<T> const & q,
  detail::tquat<T> const & p);

 template <typename T>
 detail::tquat<T> operator* (
  detail::tquat<T> const & q,
  detail::tquat<T> const & p);

 template <typename T>
 detail::tvec3<T> operator* (
  detail::tquat<T> const & q,
  detail::tvec3<T> const & v);

 template <typename T>
 detail::tvec3<T> operator* (
  detail::tvec3<T> const & v,
  detail::tquat<T> const & q);

 template <typename T>
 detail::tvec4<T> operator* (
  detail::tquat<T> const & q,
  detail::tvec4<T> const & v);

 template <typename T>
 detail::tvec4<T> operator* (
  detail::tvec4<T> const & v,
  detail::tquat<T> const & q);

 template <typename T>
 detail::tquat<T> operator* (
  detail::tquat<T> const & q,
  typename detail::tquat<T>::value_type const & s);

 template <typename T>
 detail::tquat<T> operator* (
  typename detail::tquat<T>::value_type const & s,
  detail::tquat<T> const & q);

 template <typename T>
 detail::tquat<T> operator/ (
  detail::tquat<T> const & q,
  typename detail::tquat<T>::value_type const & s);

}







    template <typename T>
    T length(
  detail::tquat<T> const & q);




 template <typename T>
 detail::tquat<T> normalize(
  detail::tquat<T> const & q);




 template <typename T>
 T dot(
  detail::tquat<T> const & q1,
  detail::tquat<T> const & q2);




 template <typename T>
 detail::tquat<T> mix(
  detail::tquat<T> const & x,
  detail::tquat<T> const & y,
  T const & a);




    template <typename T>
 detail::tquat<T> conjugate(
  detail::tquat<T> const & q);




    template <typename T>
 detail::tquat<T> inverse(
  detail::tquat<T> const & q);




 template <typename T>
 detail::tquat<T> rotate(
  detail::tquat<T> const & q,
  typename detail::tquat<T>::value_type const & angle,
  detail::tvec3<T> const & v);




    template <typename T>
 detail::tmat3x3<T> mat3_cast(
  detail::tquat<T> const & x);




 template <typename T>
 detail::tmat4x4<T> mat4_cast(
  detail::tquat<T> const & x);




 template <typename T>
 detail::tquat<T> quat_cast(
  detail::tmat3x3<T> const & x);




 template <typename T>
 detail::tquat<T> quat_cast(
  detail::tmat4x4<T> const & x);




    typedef detail::tquat<float> quat;




 typedef detail::tquat<detail::half> hquat;




 typedef detail::tquat<float> fquat;




 typedef detail::tquat<double> dquat;




 typedef detail::tquat<lowp_float> lowp_quat;




 typedef detail::tquat<mediump_float> mediump_quat;




 typedef detail::tquat<highp_float> highp_quat;


}

# 1 "/usr/include/sgct/glm/gtc/quaternion.inl" 1 3 4
# 31 "/usr/include/sgct/glm/gtc/quaternion.inl" 3 4
namespace glm{
namespace detail
{
    template <typename T>
    inline tquat<T>::tquat() :
        x(0),
        y(0),
        z(0),
        w(1)
    {}

    template <typename T>
    inline tquat<T>::tquat
 (
  value_type const & s,
  tvec3<T> const & v
 ) :
        x(v.x),
        y(v.y),
        z(v.z),
        w(s)
    {}

    template <typename T>
    inline tquat<T>::tquat
 (
  value_type const & w,
  value_type const & x,
  value_type const & y,
  value_type const & z
 ) :
        x(x),
        y(y),
        z(z),
        w(w)
    {}
# 89 "/usr/include/sgct/glm/gtc/quaternion.inl" 3 4
 template <typename T>
 inline tquat<T>::tquat
 (
  tvec3<T> const & eulerAngle
 )
 {
  tvec3<T> c = glm::cos(eulerAngle * value_type(0.5));
  tvec3<T> s = glm::sin(eulerAngle * value_type(0.5));

  this->w = c.x * c.y * c.z + s.x * s.y * s.z;
  this->x = s.x * c.y * c.z - c.x * s.y * s.z;
  this->y = c.x * s.y * c.z + s.x * c.y * s.z;
  this->z = c.x * c.y * s.z - s.x * s.y * c.z;
 }

    template <typename T>
    inline tquat<T>::tquat
 (
  tmat3x3<T> const & m
 )
    {
  *this = quat_cast(m);
    }

    template <typename T>
    inline tquat<T>::tquat
 (
  tmat4x4<T> const & m
 )
    {
  *this = quat_cast(m);
    }




    template <typename T>
 inline typename tquat<T>::value_type & tquat<T>::operator [] (int i)
    {
        return (&x)[i];
    }

    template <typename T>
    inline typename tquat<T>::value_type const & tquat<T>::operator [] (int i) const
    {
        return (&x)[i];
    }




    template <typename T>
    inline tquat<T> & tquat<T>::operator *=
 (
  value_type const & s
 )
    {
        this->w *= s;
        this->x *= s;
        this->y *= s;
        this->z *= s;
        return *this;
    }

    template <typename T>
    inline tquat<T> & tquat<T>::operator /=
 (
  value_type const & s
 )
    {
        this->w /= s;
        this->x /= s;
        this->y /= s;
        this->z /= s;
        return *this;
    }




 template <typename T>
 inline detail::tquat<T> operator-
 (
  detail::tquat<T> const & q
 )
 {
  return detail::tquat<T>(-q.w, -q.x, -q.y, -q.z);
 }

 template <typename T>
 inline detail::tquat<T> operator+
 (
  detail::tquat<T> const & q,
  detail::tquat<T> const & p
 )
 {
        return detail::tquat<T>(
            q.w + p.w,
         q.x + p.x,
         q.y + p.y,
         q.z + p.z);
 }

 template <typename T>
 inline detail::tquat<T> operator*
 (
  detail::tquat<T> const & q,
  detail::tquat<T> const & p
 )
 {
        return detail::tquat<T>(
            q.w * p.w - q.x * p.x - q.y * p.y - q.z * p.z,
         q.w * p.x + q.x * p.w + q.y * p.z - q.z * p.y,
         q.w * p.y + q.y * p.w + q.z * p.x - q.x * p.z,
         q.w * p.z + q.z * p.w + q.x * p.y - q.y * p.x);
 }


 template <typename T>
 inline detail::tvec3<T> operator*
 (
  detail::tquat<T> const & q,
  detail::tvec3<T> const & v
 )
 {
  typename detail::tquat<T>::value_type Two(2);

  detail::tvec3<T> uv, uuv;
  detail::tvec3<T> QuatVector(q.x, q.y, q.z);
  uv = glm::cross(QuatVector, v);
  uuv = glm::cross(QuatVector, uv);
  uv *= (Two * q.w);
  uuv *= Two;

  return v + uv + uuv;
 }

 template <typename T>
 inline detail::tvec3<T> operator*
 (
  detail::tvec3<T> const & v,
  detail::tquat<T> const & q
 )
 {
  return inverse(q) * v;
 }

 template <typename T>
 inline detail::tvec4<T> operator*
 (
  detail::tquat<T> const & q,
  detail::tvec4<T> const & v
 )
 {
  return detail::tvec4<T>(q * detail::tvec3<T>(v), v.w);
 }

 template <typename T>
 inline detail::tvec4<T> operator*
 (
  detail::tvec4<T> const & v,
  detail::tquat<T> const & q
 )
 {
  return inverse(q) * v;
 }

 template <typename T>
 inline detail::tquat<T> operator*
 (
  detail::tquat<T> const & q,
  typename detail::tquat<T>::value_type const & s
 )
 {
  return detail::tquat<T>(
   q.w * s, q.x * s, q.y * s, q.z * s);
 }

 template <typename T>
 inline detail::tquat<T> operator*
 (
  typename detail::tquat<T>::value_type const & s,
  detail::tquat<T> const & q
 )
 {
  return q * s;
 }

 template <typename T>
 inline detail::tquat<T> operator/
 (
  detail::tquat<T> const & q,
  typename detail::tquat<T>::value_type const & s
 )
 {
  return detail::tquat<T>(
   q.w / s, q.x / s, q.y / s, q.z / s);
 }




 template <typename T>
 inline bool operator==
 (
  detail::tquat<T> const & q1,
  detail::tquat<T> const & q2
 )
 {
  return (q1.x == q2.x) && (q1.y == q2.y) && (q1.z == q2.z) && (q1.w == q2.w);
 }

 template <typename T>
 inline bool operator!=
 (
  detail::tquat<T> const & q1,
  detail::tquat<T> const & q2
 )
 {
  return (q1.x != q2.x) || (q1.y != q2.y) || (q1.z != q2.z) || (q1.w != q2.w);
 }

}


    template <typename T>
 inline T length
 (
  detail::tquat<T> const & q
 )
    {
  return glm::sqrt(dot(q, q));
    }

    template <typename T>
    inline detail::tquat<T> normalize
 (
  detail::tquat<T> const & q
 )
    {
        typename detail::tquat<T>::value_type len = length(q);
        if(len <= typename detail::tquat<T>::value_type(0))
            return detail::tquat<T>(1, 0, 0, 0);
        typename detail::tquat<T>::value_type oneOverLen = typename detail::tquat<T>::value_type(1) / len;
        return detail::tquat<T>(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
    }

    template <typename T>
    inline T dot
 (
  detail::tquat<T> const & q1,
  detail::tquat<T> const & q2
 )
    {
        return q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
    }

    template <typename T>
    inline detail::tquat<T> cross
 (
  detail::tquat<T> const & q1,
  detail::tquat<T> const & q2
 )
    {
        return detail::tquat<T>(
            q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
         q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
         q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
         q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
    }
# 440 "/usr/include/sgct/glm/gtc/quaternion.inl" 3 4
    template <typename T>
    inline detail::tquat<T> mix
 (
  detail::tquat<T> const & x,
  detail::tquat<T> const & y,
  T const & a
 )
    {
  T angle = acos(dot(x, y));
  return (glm::sin((T(1) - a) * angle) * x + glm::sin(a * angle) * y) / glm::sin(angle);
 }

    template <typename T>
    inline detail::tquat<T> conjugate
 (
  detail::tquat<T> const & q
 )
    {
        return detail::tquat<T>(q.w, -q.x, -q.y, -q.z);
    }

    template <typename T>
    inline detail::tquat<T> inverse
 (
  detail::tquat<T> const & q
 )
    {
        return conjugate(q) / dot(q, q);
    }

    template <typename T>
    inline detail::tquat<T> rotate
 (
  detail::tquat<T> const & q,
  typename detail::tquat<T>::value_type const & angle,
  detail::tvec3<T> const & v
 )
    {
  detail::tvec3<T> Tmp = v;


        typename detail::tquat<T>::value_type len = glm::length(Tmp);
        if(abs(len - T(1)) > T(0.001))
        {
            T oneOverLen = T(1) / len;
            Tmp.x *= oneOverLen;
            Tmp.y *= oneOverLen;
            Tmp.z *= oneOverLen;
        }

        typename detail::tquat<T>::value_type AngleRad = radians(angle);
        typename detail::tquat<T>::value_type fSin = sin(AngleRad * T(0.5));

  return q * detail::tquat<T>(cos(AngleRad * T(0.5)), Tmp.x * fSin, Tmp.y * fSin, Tmp.z * fSin);

 }

    template <typename T>
    inline detail::tmat3x3<T> mat3_cast
 (
  detail::tquat<T> const & q
 )
    {
        detail::tmat3x3<T> Result(T(1));
        Result[0][0] = 1 - 2 * q.y * q.y - 2 * q.z * q.z;
        Result[0][1] = 2 * q.x * q.y + 2 * q.w * q.z;
        Result[0][2] = 2 * q.x * q.z - 2 * q.w * q.y;

        Result[1][0] = 2 * q.x * q.y - 2 * q.w * q.z;
        Result[1][1] = 1 - 2 * q.x * q.x - 2 * q.z * q.z;
        Result[1][2] = 2 * q.y * q.z + 2 * q.w * q.x;

        Result[2][0] = 2 * q.x * q.z + 2 * q.w * q.y;
        Result[2][1] = 2 * q.y * q.z - 2 * q.w * q.x;
        Result[2][2] = 1 - 2 * q.x * q.x - 2 * q.y * q.y;
        return Result;
    }

    template <typename T>
    inline detail::tmat4x4<T> mat4_cast
 (
  detail::tquat<T> const & q
 )
    {
        return detail::tmat4x4<T>(mat3_cast(q));
    }

    template <typename T>
    inline detail::tquat<T> quat_cast
 (
  detail::tmat3x3<T> const & m
 )
    {
        typename detail::tquat<T>::value_type fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
        typename detail::tquat<T>::value_type fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
        typename detail::tquat<T>::value_type fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
        typename detail::tquat<T>::value_type fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

        int biggestIndex = 0;
        typename detail::tquat<T>::value_type fourBiggestSquaredMinus1 = fourWSquaredMinus1;
        if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
        {
            fourBiggestSquaredMinus1 = fourXSquaredMinus1;
            biggestIndex = 1;
        }
        if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
        {
            fourBiggestSquaredMinus1 = fourYSquaredMinus1;
            biggestIndex = 2;
        }
        if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
        {
            fourBiggestSquaredMinus1 = fourZSquaredMinus1;
            biggestIndex = 3;
        }

        typename detail::tquat<T>::value_type biggestVal = sqrt(fourBiggestSquaredMinus1 + T(1)) * T(0.5);
        typename detail::tquat<T>::value_type mult = T(0.25) / biggestVal;

        detail::tquat<T> Result;
        switch(biggestIndex)
        {
        case 0:
            Result.w = biggestVal;
            Result.x = (m[1][2] - m[2][1]) * mult;
            Result.y = (m[2][0] - m[0][2]) * mult;
            Result.z = (m[0][1] - m[1][0]) * mult;
            break;
        case 1:
            Result.w = (m[1][2] - m[2][1]) * mult;
            Result.x = biggestVal;
            Result.y = (m[0][1] + m[1][0]) * mult;
            Result.z = (m[2][0] + m[0][2]) * mult;
            break;
        case 2:
            Result.w = (m[2][0] - m[0][2]) * mult;
            Result.x = (m[0][1] + m[1][0]) * mult;
            Result.y = biggestVal;
            Result.z = (m[1][2] + m[2][1]) * mult;
            break;
        case 3:
            Result.w = (m[0][1] - m[1][0]) * mult;
            Result.x = (m[2][0] + m[0][2]) * mult;
            Result.y = (m[1][2] + m[2][1]) * mult;
            Result.z = biggestVal;
            break;
        }
        return Result;
    }

    template <typename T>
    inline detail::tquat<T> quat_cast
 (
  detail::tmat4x4<T> const & m4
 )
    {
  return quat_cast(detail::tmat3x3<T>(m4));
    }

}
# 274 "/usr/include/sgct/glm/gtc/quaternion.hpp" 2 3 4
# 7 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 2
# 1 "/usr/include/sgct/glm/gtc/type_ptr.hpp" 1 3 4
# 63 "/usr/include/sgct/glm/gtc/type_ptr.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../glm.hpp" 1 3 4
# 78 "/usr/include/sgct/glm/gtc/../glm.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 30 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 2 3 4
# 79 "/usr/include/sgct/glm/gtc/../glm.hpp" 2 3 4
# 64 "/usr/include/sgct/glm/gtc/type_ptr.hpp" 2 3 4

# 1 "/usr/include/sgct/glm/gtc/../gtc/quaternion.hpp" 1 3 4
# 66 "/usr/include/sgct/glm/gtc/type_ptr.hpp" 2 3 4
# 1 "/usr/include/c++/4.6/cstring" 1 3 4
# 41 "/usr/include/c++/4.6/cstring" 3 4
       
# 42 "/usr/include/c++/4.6/cstring" 3


# 1 "/usr/include/string.h" 1 3 4
# 29 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 93 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 165 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 210 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strchr (__const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 233 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strrchr (__const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 312 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strstr (__const char *__haystack,
        __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" __const char *strcasestr (__const char *__haystack,
           __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *index (__const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *rindex (__const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *basename (__const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 646 "/usr/include/string.h" 3 4
}
# 45 "/usr/include/c++/4.6/cstring" 2 3
# 73 "/usr/include/c++/4.6/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 122 "/usr/include/c++/4.6/cstring" 3

}
# 67 "/usr/include/sgct/glm/gtc/type_ptr.hpp" 2 3 4





namespace glm
{





 template<typename genType>
    typename genType::value_type const * value_ptr(genType const & vec);



 template<typename T>
    detail::tvec2<T> make_vec2(T const * const ptr);



 template<typename T>
    detail::tvec3<T> make_vec3(T const * const ptr);



 template<typename T>
    detail::tvec4<T> make_vec4(T const * const ptr);



 template<typename T>
    detail::tmat2x2<T> make_mat2x2(T const * const ptr);



 template<typename T>
    detail::tmat2x3<T> make_mat2x3(T const * const ptr);



 template<typename T>
    detail::tmat2x4<T> make_mat2x4(T const * const ptr);



 template<typename T>
    detail::tmat3x2<T> make_mat3x2(T const * const ptr);



 template<typename T>
    detail::tmat3x3<T> make_mat3x3(T const * const ptr);



 template<typename T>
    detail::tmat3x4<T> make_mat3x4(T const * const ptr);



 template<typename T>
    detail::tmat4x2<T> make_mat4x2(
        T const * const ptr);



 template<typename T>
    detail::tmat4x3<T> make_mat4x3(T const * const ptr);



 template<typename T>
    detail::tmat4x4<T> make_mat4x4(T const * const ptr);



 template<typename T>
    detail::tmat2x2<T> make_mat2(T const * const ptr);



 template<typename T>
    detail::tmat3x3<T> make_mat3(T const * const ptr);



 template<typename T>
    detail::tmat4x4<T> make_mat4(T const * const ptr);



 template<typename T>
    detail::tquat<T> make_quat(T const * const ptr);


}

# 1 "/usr/include/sgct/glm/gtc/type_ptr.inl" 1 3 4
# 29 "/usr/include/sgct/glm/gtc/type_ptr.inl" 3 4
namespace glm
{





 template<typename T>
 inline T const * value_ptr
 (
  detail::tvec2<T> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tvec2<T> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tvec3<T> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tvec3<T> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tvec4<T> const & vec
 )
 {
  return &(vec.x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tvec4<T> & vec
 )
 {
  return &(vec.x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat2x2<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat2x2<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat3x3<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat3x3<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat4x4<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat4x4<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat2x3<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat2x3<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat3x2<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat3x2<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat2x4<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat2x4<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat4x2<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat4x2<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat3x4<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T * value_ptr
 (
  detail::tmat3x4<T> & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
  detail::tmat4x3<T> const & mat
 )
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline T const * value_ptr
 (
        detail::tquat<T> const & q
    )
 {
  return &(q[0]);
 }



 template<typename T>
 inline T * value_ptr(detail::tmat4x3<T> & mat)
 {
  return &(mat[0].x);
 }



 template<typename T>
 inline detail::tvec2<T> make_vec2(T const * const ptr)
 {
  detail::tvec2<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tvec2<T>));
  return Result;
 }



 template<typename T>
 inline detail::tvec3<T> make_vec3(T const * const ptr)
 {
  detail::tvec3<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tvec3<T>));
  return Result;
 }



 template<typename T>
 inline detail::tvec4<T> make_vec4(T const * const ptr)
 {
  detail::tvec4<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tvec4<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat2x2<T> make_mat2x2(T const * const ptr)
 {
  detail::tmat2x2<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat2x2<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat2x3<T> make_mat2x3(T const * const ptr)
 {
  detail::tmat2x3<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat2x3<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat2x4<T> make_mat2x4(T const * const ptr)
 {
  detail::tmat2x4<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat2x4<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat3x2<T> make_mat3x2(T const * const ptr)
 {
  detail::tmat3x2<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat3x2<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat3x3<T> make_mat3x3(T const * const ptr)
 {
  detail::tmat3x3<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat3x3<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat3x4<T> make_mat3x4(T const * const ptr)
 {
  detail::tmat3x4<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat3x4<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat4x2<T> make_mat4x2(T const * const ptr)
 {
  detail::tmat4x2<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat4x2<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat4x3<T> make_mat4x3(T const * const ptr)
 {
  detail::tmat4x3<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat4x3<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat4x4<T> make_mat4x4(T const * const ptr)
 {
  detail::tmat4x4<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tmat4x4<T>));
  return Result;
 }



 template<typename T>
 inline detail::tmat2x2<T> make_mat2(T const * const ptr)
 {
  return make_mat2x2(ptr);
 }



 template<typename T>
 inline detail::tmat3x3<T> make_mat3(T const * const ptr)
 {
  return make_mat3x3(ptr);
 }



 template<typename T>
 inline detail::tmat4x4<T> make_mat4(T const * const ptr)
 {
  return make_mat4x4(ptr);
 }



 template<typename T>
 inline detail::tquat<T> make_quat(T const * const ptr)
 {
  detail::tquat<T> Result;
  memcpy(value_ptr(Result), ptr, sizeof(detail::tquat<T>));
  return Result;
 }


}
# 167 "/usr/include/sgct/glm/gtc/type_ptr.hpp" 2 3 4
# 8 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 2
# 1 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 1 3 4
# 50 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../glm.hpp" 1 3 4
# 78 "/usr/include/sgct/glm/gtc/../glm.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 30 "/usr/include/sgct/glm/gtc/../core/_fixes.hpp" 2 3 4
# 79 "/usr/include/sgct/glm/gtc/../glm.hpp" 2 3 4
# 51 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 2 3 4





namespace glm
{
# 81 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> translate(
  detail::tmat4x4<T> const & m,
  detail::tvec3<T> const & v);
# 97 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> rotate(
  detail::tmat4x4<T> const & m,
  T const & angle,
  detail::tvec3<T> const & axis);
# 113 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> scale(
  detail::tmat4x4<T> const & m,
  detail::tvec3<T> const & v);
# 129 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> ortho(
  T const & left,
  T const & right,
  T const & bottom,
  T const & top,
  T const & zNear,
  T const & zFar);
# 147 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> ortho(
  T const & left,
  T const & right,
  T const & bottom,
  T const & top);
# 164 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> frustum(
  T const & left,
  T const & right,
  T const & bottom,
  T const & top,
  T const & near,
  T const & far);
# 181 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> perspective(
  T const & fovy,
  T const & aspect,
  T const & near,
  T const & far);
# 197 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename valType>
 detail::tmat4x4<valType> perspectiveFov(
  valType const & fov,
  valType const & width,
  valType const & height,
  valType const & near,
  valType const & far);
# 212 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
    template <typename T>
 detail::tmat4x4<T> infinitePerspective(
  T fovy, T aspect, T near);
# 223 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
    template <typename T>
 detail::tmat4x4<T> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 236 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, typename U>
 detail::tvec3<T> project(
  detail::tvec3<T> const & obj,
  detail::tmat4x4<T> const & model,
  detail::tmat4x4<T> const & proj,
  detail::tvec4<U> const & viewport);
# 252 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, typename U>
 detail::tvec3<T> unProject(
  detail::tvec3<T> const & win,
  detail::tmat4x4<T> const & model,
  detail::tmat4x4<T> const & proj,
  detail::tvec4<U> const & viewport);
# 267 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, typename U>
 detail::tmat4x4<T> pickMatrix(
  detail::tvec2<T> const & center,
  detail::tvec2<T> const & delta,
  detail::tvec4<U> const & viewport);
# 280 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T> lookAt(
  detail::tvec3<T> const & eye,
  detail::tvec3<T> const & center,
  detail::tvec3<T> const & up);


}

# 1 "/usr/include/sgct/glm/gtc/matrix_transform.inl" 1 3 4
# 29 "/usr/include/sgct/glm/gtc/matrix_transform.inl" 3 4
namespace glm
{
 template <typename T>
 inline detail::tmat4x4<T> translate
 (
  detail::tmat4x4<T> const & m,
  detail::tvec3<T> const & v
 )
 {
  detail::tmat4x4<T> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T> rotate
 (
  detail::tmat4x4<T> const & m,
  T const & angle,
  detail::tvec3<T> const & v
 )
 {
  T a = radians(angle);
  T c = cos(a);
  T s = sin(a);

  detail::tvec3<T> axis = normalize(v);

  detail::tvec3<T> temp = (T(1) - c) * axis;

  detail::tmat4x4<T> Rotate(detail::tmat4x4<T>::null);
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  detail::tmat4x4<T> Result(detail::tmat4x4<T>::null);
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T> scale
 (
  detail::tmat4x4<T> const & m,
  detail::tvec3<T> const & v
 )
 {
  detail::tmat4x4<T> Result(detail::tmat4x4<T>::null);
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T> translate_slow
 (
  detail::tmat4x4<T> const & m,
  detail::tvec3<T> const & v
 )
 {
  detail::tmat4x4<T> Result(T(1));
  Result[3] = detail::tvec4<T>(v, T(1));
  return m * Result;


  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];





 }

 template <typename T>
 inline detail::tmat4x4<T> rotate_slow
 (
  detail::tmat4x4<T> const & m,
  T const & angle,
  detail::tvec3<T> const & v
 )
 {
  T a = radians(angle);
  T c = cos(a);
  T s = sin(a);
  detail::tmat4x4<T> Result;

  detail::tvec3<T> axis = normalize(v);

  Result[0][0] = c + (1 - c) * axis.x * axis.x;
  Result[0][1] = (1 - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (1 - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = 0;

  Result[1][0] = (1 - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (1 - c) * axis.y * axis.y;
  Result[1][2] = (1 - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = 0;

  Result[2][0] = (1 - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (1 - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (1 - c) * axis.z * axis.z;
  Result[2][3] = 0;

  Result[3] = detail::tvec4<T>(0, 0, 0, 1);
  return m * Result;
 }

 template <typename T>
 inline detail::tmat4x4<T> scale_slow
 (
  detail::tmat4x4<T> const & m,
  detail::tvec3<T> const & v
 )
 {
  detail::tmat4x4<T> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType> ortho
 (
  valType const & left,
  valType const & right,
  valType const & bottom,
  valType const & top,
  valType const & zNear,
  valType const & zFar
 )
 {
  detail::tmat4x4<valType> Result(1);
  Result[0][0] = valType(2) / (right - left);
  Result[1][1] = valType(2) / (top - bottom);
  Result[2][2] = - valType(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType> ortho(
  valType const & left,
  valType const & right,
  valType const & bottom,
  valType const & top)
 {
  detail::tmat4x4<valType> Result(1);
  Result[0][0] = valType(2) / (right - left);
  Result[1][1] = valType(2) / (top - bottom);
  Result[2][2] = - valType(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType> frustum
 (
  valType const & left,
  valType const & right,
  valType const & bottom,
  valType const & top,
  valType const & nearVal,
  valType const & farVal
 )
 {
  detail::tmat4x4<valType> Result(0);
  Result[0][0] = (valType(2) * nearVal) / (right - left);
  Result[1][1] = (valType(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = -(farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = valType(-1);
  Result[3][2] = -(valType(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType> perspective
 (
  valType const & fovy,
  valType const & aspect,
  valType const & zNear,
  valType const & zFar
 )
 {
  valType range = tan(radians(fovy / valType(2))) * zNear;
  valType left = -range * aspect;
  valType right = range * aspect;
  valType bottom = -range;
  valType top = range;

  detail::tmat4x4<valType> Result(valType(0));
  Result[0][0] = (valType(2) * zNear) / (right - left);
  Result[1][1] = (valType(2) * zNear) / (top - bottom);
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - valType(1);
  Result[3][2] = - (valType(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType> perspectiveFov
 (
  valType const & fov,
  valType const & width,
  valType const & height,
  valType const & zNear,
  valType const & zFar
 )
 {
  valType rad = glm::radians(fov);
  valType h = glm::cos(valType(0.5) * rad) / glm::sin(valType(0.5) * rad);
  valType w = h * height / width;

  detail::tmat4x4<valType> Result(valType(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = -valType(1);
  Result[3][2] = (valType(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T> infinitePerspective
 (
  T fovy,
  T aspect,
  T zNear
 )
 {
  T range = tan(radians(fovy / T(2))) * zNear;
  T left = -range * aspect;
  T right = range * aspect;
  T bottom = -range;
  T top = range;

  detail::tmat4x4<T> Result(T(0));
  Result[0][0] = (T(2) * zNear) / (right - left);
  Result[1][1] = (T(2) * zNear) / (top - bottom);
  Result[2][2] = - T(1);
  Result[2][3] = - T(1);
  Result[3][2] = - T(2) * zNear;
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T> tweakedInfinitePerspective
 (
  T fovy,
  T aspect,
  T zNear
 )
 {
  T range = tan(radians(fovy / T(2))) * zNear;
  T left = -range * aspect;
  T right = range * aspect;
  T bottom = -range;
  T top = range;

  detail::tmat4x4<T> Result(T(0));
  Result[0][0] = (T(2) * zNear) / (right - left);
  Result[1][1] = (T(2) * zNear) / (top - bottom);
  Result[2][2] = T(0.0001) - T(1);
  Result[2][3] = T(-1);
  Result[3][2] = - (T(0.0001) - T(2)) * zNear;
  return Result;
 }

 template <typename T, typename U>
 inline detail::tvec3<T> project
 (
  detail::tvec3<T> const & obj,
  detail::tmat4x4<T> const & model,
  detail::tmat4x4<T> const & proj,
  detail::tvec4<U> const & viewport
 )
 {
  detail::tvec4<T> tmp = detail::tvec4<T>(obj, T(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp = tmp * T(0.5) + T(0.5);
  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return detail::tvec3<T>(tmp);
 }

 template <typename T, typename U>
 inline detail::tvec3<T> unProject
 (
  detail::tvec3<T> const & win,
  detail::tmat4x4<T> const & model,
  detail::tmat4x4<T> const & proj,
  detail::tvec4<U> const & viewport
 )
 {
  detail::tmat4x4<T> inverse = glm::inverse(proj * model);

  detail::tvec4<T> tmp = detail::tvec4<T>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp = tmp * T(2) - T(1);

  detail::tvec4<T> obj = inverse * tmp;
  obj /= obj.w;

  return detail::tvec3<T>(obj);
 }

 template <typename T, typename U>
 detail::tmat4x4<T> pickMatrix
 (
  detail::tvec2<T> const & center,
  detail::tvec2<T> const & delta,
  detail::tvec4<U> const & viewport
 )
 {
  ((delta.x > T(0) && delta.y > T(0)) ? static_cast<void> (0) : __assert_fail ("delta.x > T(0) && delta.y > T(0)", "/usr/include/sgct/glm/gtc/matrix_transform.inl", 366, __PRETTY_FUNCTION__));
  detail::tmat4x4<T> Result(1.0f);

  if(!(delta.x > T(0) && delta.y > T(0)))
   return Result;

  detail::tvec3<T> Temp(
   (T(viewport[2]) - T(2) * (center.x - T(viewport[0]))) / delta.x,
   (T(viewport[3]) - T(2) * (center.y - T(viewport[1]))) / delta.y,
   T(0));


  Result = translate(Result, Temp);
  return scale(Result, detail::tvec3<T>(T(viewport[2]) / delta.x, T(viewport[3]) / delta.y, T(1)));
 }

 template <typename T>
 inline detail::tmat4x4<T> lookAt
 (
  detail::tvec3<T> const & eye,
  detail::tvec3<T> const & center,
  detail::tvec3<T> const & up
 )
 {
  detail::tvec3<T> f = normalize(center - eye);
  detail::tvec3<T> u = normalize(up);
  detail::tvec3<T> s = normalize(cross(f, u));
  u = cross(s, f);

  detail::tmat4x4<T> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;





  return translate(Result, -eye);
 }
}
# 290 "/usr/include/sgct/glm/gtc/matrix_transform.hpp" 2 3 4
# 9 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 2
# 1 "/usr/include/sgct/glm/gtx/random.hpp" 1 3 4
# 43 "/usr/include/sgct/glm/gtx/random.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtx/../glm.hpp" 1 3 4
# 78 "/usr/include/sgct/glm/gtx/../glm.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtx/../core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/gtx/../core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 30 "/usr/include/sgct/glm/gtx/../core/_fixes.hpp" 2 3 4
# 79 "/usr/include/sgct/glm/gtx/../glm.hpp" 2 3 4
# 44 "/usr/include/sgct/glm/gtx/random.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/gtx/../gtc/random.hpp" 1 3 4
# 44 "/usr/include/sgct/glm/gtx/../gtc/random.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtx/../gtc/../glm.hpp" 1 3 4
# 78 "/usr/include/sgct/glm/gtx/../gtc/../glm.hpp" 3 4
# 1 "/usr/include/sgct/glm/gtx/../gtc/../core/_fixes.hpp" 1 3 4
# 29 "/usr/include/sgct/glm/gtx/../gtc/../core/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.6/cmath" 1 3 4
# 41 "/usr/include/c++/4.6/cmath" 3 4
       
# 42 "/usr/include/c++/4.6/cmath" 3
# 30 "/usr/include/sgct/glm/gtx/../gtc/../core/_fixes.hpp" 2 3 4
# 79 "/usr/include/sgct/glm/gtx/../gtc/../glm.hpp" 2 3 4
# 45 "/usr/include/sgct/glm/gtx/../gtc/random.hpp" 2 3 4
# 1 "/usr/include/sgct/glm/gtx/../gtc/../gtc/half_float.hpp" 1 3 4
# 46 "/usr/include/sgct/glm/gtx/../gtc/random.hpp" 2 3 4





namespace glm
{
# 62 "/usr/include/sgct/glm/gtx/../gtc/random.hpp" 3 4
 template <typename genType>
 genType linearRand(
  genType const & Min,
  genType const & Max);






 template <typename genType>
 genType gaussRand(
  genType const & Mean,
  genType const & Deviation);





 template <typename T>
 detail::tvec2<T> circularRand(
  T const & Radius);





 template <typename T>
 detail::tvec3<T> sphericalRand(
  T const & Radius);





 template <typename T>
 detail::tvec2<T> diskRand(
  T const & Radius);





 template <typename T>
 inline detail::tvec3<T> ballRand(
  T const & Radius);


}

# 1 "/usr/include/sgct/glm/gtx/../gtc/random.inl" 1 3 4
# 10 "/usr/include/sgct/glm/gtx/../gtc/random.inl" 3 4
# 1 "/usr/include/c++/4.6/ctime" 1 3 4
# 41 "/usr/include/c++/4.6/ctime" 3 4
       
# 42 "/usr/include/c++/4.6/ctime" 3


# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 86 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  long int offset;
  long int freq;
  long int maxerror;
  long int esterror;
  int status;
  long int constant;
  long int precision;
  long int tolerance;
  struct timeval time;
  long int tick;

  long int ppsfreq;
  long int jitter;
  int shift;
  long int stabil;
  long int jitcnt;
  long int calcnt;
  long int errcnt;
  long int stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 43 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 180 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 45 "/usr/include/c++/4.6/ctime" 2 3
# 60 "/usr/include/c++/4.6/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 11 "/usr/include/sgct/glm/gtx/../gtc/random.inl" 2 3 4
# 1 "/usr/include/c++/4.6/cassert" 1 3 4
# 43 "/usr/include/c++/4.6/cassert" 3 4
       
# 44 "/usr/include/c++/4.6/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.6/cassert" 2 3
# 12 "/usr/include/sgct/glm/gtx/../gtc/random.inl" 2 3 4
# 1 "/usr/include/sgct/glm/gtx/../gtc/../core/_vectorize.hpp" 1 3 4
# 13 "/usr/include/sgct/glm/gtx/../gtc/random.inl" 2 3 4

namespace glm{
namespace detail
{
 struct compute_linearRand
 {
  template <typename T>
  inline T operator() (T const & Min, T const & Max) const;






 };

 template <>
 inline half compute_linearRand::operator()<half> (half const & Min, half const & Max) const
 {
  return half(float(std::rand()) / float(2147483647) * (float(Max) - float(Min)) + float(Min));
 }

 template <>
 inline float compute_linearRand::operator()<float> (float const & Min, float const & Max) const
 {
  return float(std::rand()) / float(2147483647) * (Max - Min) + Min;
 }

 template <>
 inline double compute_linearRand::operator()<double> (double const & Min, double const & Max) const
 {
  return double(std::rand()) / double(2147483647) * (Max - Min) + Min;
 }

 template <>
 inline long double compute_linearRand::operator()<long double> (long double const & Min, long double const & Max) const
 {
  return (long double)(std::rand()) / (long double)(2147483647) * (Max - Min) + Min;
 }
}

 template <typename genType>
 inline genType linearRand
 (
  genType const & Min,
  genType const & Max
 )
 {
  return detail::compute_linearRand()(Min, Max);
 }

 template <typename T> inline detail::tvec2<T> linearRand ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( linearRand(x.x, y.x), linearRand(x.y, y.y)); } template <typename T> inline detail::tvec3<T> linearRand ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( linearRand(x.x, y.x), linearRand(x.y, y.y), linearRand(x.z, y.z)); } template <typename T> inline detail::tvec4<T> linearRand ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( linearRand(x.x, y.x), linearRand(x.y, y.y), linearRand(x.z, y.z), linearRand(x.w, y.w)); }

 template <typename genType>
 inline genType gaussRand
 (
  genType const & Mean,
  genType const & Deviation
 )
 {
  genType w, x1, x2;

  do
  {
   x1 = linearRand(genType(-1), genType(1));
   x2 = linearRand(genType(-1), genType(1));

   w = x1 * x1 + x2 * x2;
  } while(w > genType(1));

  return x2 * Deviation * Deviation * sqrt((genType(-2) * log(w)) / w) + Mean;
 }

 template <typename T> inline detail::tvec2<T> gaussRand ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( gaussRand(x.x, y.x), gaussRand(x.y, y.y)); } template <typename T> inline detail::tvec3<T> gaussRand ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( gaussRand(x.x, y.x), gaussRand(x.y, y.y), gaussRand(x.z, y.z)); } template <typename T> inline detail::tvec4<T> gaussRand ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( gaussRand(x.x, y.x), gaussRand(x.y, y.y), gaussRand(x.z, y.z), gaussRand(x.w, y.w)); }

 template <typename T>
 inline detail::tvec2<T> diskRand
 (
  T const & Radius
 )
 {
  detail::tvec2<T> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(detail::tvec2<T>(-Radius), detail::tvec2<T>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template <typename T>
 inline detail::tvec3<T> ballRand
 (
  T const & Radius
 )
 {
  detail::tvec3<T> Result(T(0));
  T LenRadius(T(0));

  do
  {
   Result = linearRand(detail::tvec3<T>(-Radius), detail::tvec3<T>(Radius));
   LenRadius = length(Result);
  }
  while(LenRadius > Radius);

  return Result;
 }

 template <typename T>
 inline detail::tvec2<T> circularRand
 (
  T const & Radius
 )
 {
  T a = linearRand(T(0), T(6.283185307179586476925286766559f));
  return detail::tvec2<T>(cos(a), sin(a)) * Radius;
 }

 template <typename T>
 inline detail::tvec3<T> sphericalRand
 (
  T const & Radius
 )
 {
  T z = linearRand(T(-1), T(1));
  T a = linearRand(T(0), T(6.283185307179586476925286766559f));

  T r = sqrt(T(1) - z * z);

  T x = r * cos(a);
  T y = r * sin(a);

  return detail::tvec3<T>(x, y, z) * Radius;
 }
}
# 113 "/usr/include/sgct/glm/gtx/../gtc/random.hpp" 2 3 4
# 45 "/usr/include/sgct/glm/gtx/random.hpp" 2 3 4





namespace glm
{





    template <typename T> T signedRand1();

 template <> float signedRand1();
    template <> double signedRand1();
    template <typename T> detail::tvec2<T> signedRand2();
    template <typename T> detail::tvec3<T> signedRand3();
    template <typename T> detail::tvec4<T> signedRand4();

 template <typename T> detail::tvec2<T> normalizedRand2();
 template <typename T> detail::tvec2<T> normalizedRand2(T Min, T Max);
 template <typename T> detail::tvec3<T> normalizedRand3();
 template <typename T> detail::tvec3<T> normalizedRand3(T Min, T Max);

    template <typename T> T compRand1();
 template <> float compRand1();
    template <> double compRand1();
    template <typename T> T compRand1(T Min, T Max);
    template <typename T> detail::tvec2<T> compRand2(T Min, T Max);
    template <typename T> detail::tvec3<T> compRand3(T Min, T Max);
    template <typename T> detail::tvec4<T> compRand4(T Min, T Max);
    template <typename T> detail::tvec2<T> compRand2(const detail::tvec2<T>& Min, const detail::tvec2<T>& Max);
    template <typename T> detail::tvec3<T> compRand3(const detail::tvec3<T>& Min, const detail::tvec3<T>& Max);
    template <typename T> detail::tvec3<T> compRand4(const detail::tvec4<T>& Min, const detail::tvec4<T>& Max);

    template <typename T> detail::tvec2<T> vecRand2();
    template <typename T> detail::tvec2<T> vecRand2(T MinRadius, T MaxRadius);
    template <typename T> detail::tvec3<T> vecRand3();
    template <typename T> detail::tvec3<T> vecRand3(T MinRadius, T MaxRadius);
    template <typename T> detail::tvec4<T> vecRand4();
    template <typename T> detail::tvec4<T> vecRand4(T MinRadius, T MaxRadius);

    template <typename T> T gaussRand1(T mean, T std_deviation);
    template <typename T> detail::tvec2<T> gaussRand2(T mean, T std_deviation);
    template <typename T> detail::tvec3<T> gaussRand3(T mean, T std_deviation);
    template <typename T> detail::tvec4<T> gaussRand4(T mean, T std_deviation);
    template <typename T> detail::tvec2<T> gaussRand2(const detail::tvec2<T>& mean, T std_deviation);
    template <typename T> detail::tvec3<T> gaussRand3(const detail::tvec3<T>& mean, T std_deviation);
    template <typename T> detail::tvec4<T> gaussRand4(const detail::tvec4<T>& mean, T std_deviation);
    template <typename T> detail::tvec2<T> gaussRand2(T mean, const detail::tvec2<T>& std_deviation);
    template <typename T> detail::tvec3<T> gaussRand3(T mean, const detail::tvec3<T>& std_deviation);
    template <typename T> detail::tvec4<T> gaussRand4(T mean, const detail::tvec4<T>& std_deviation);
    template <typename T> detail::tvec2<T> gaussRand2(const detail::tvec2<T>& mean, const detail::tvec2<T>& std_deviation);
    template <typename T> detail::tvec3<T> gaussRand3(const detail::tvec3<T>& mean, const detail::tvec3<T>& std_deviation);
    template <typename T> detail::tvec4<T> gaussRand4(const detail::tvec4<T>& mean, const detail::tvec4<T>& std_deviation);


}

# 1 "/usr/include/sgct/glm/gtx/random.inl" 1 3 4
# 10 "/usr/include/sgct/glm/gtx/random.inl" 3 4
# 1 "/usr/include/c++/4.6/ctime" 1 3 4
# 41 "/usr/include/c++/4.6/ctime" 3 4
       
# 42 "/usr/include/c++/4.6/ctime" 3
# 11 "/usr/include/sgct/glm/gtx/random.inl" 2 3 4
# 1 "/usr/include/c++/4.6/cassert" 1 3 4
# 43 "/usr/include/c++/4.6/cassert" 3 4
       
# 44 "/usr/include/c++/4.6/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.6/cassert" 2 3
# 12 "/usr/include/sgct/glm/gtx/random.inl" 2 3 4

namespace glm{

template <>
 inline float signedRand1()
{





 return float((std::rand() - (2147483647 >> 1) - 1) << 1) / float(2147483647 - 0);
}

template <>
 inline double signedRand1()
{
 return double(signedRand1<float>());
}

template <typename T>
 inline detail::tvec2<T> signedRand2()
{
 return detail::tvec2<T>(
  signedRand1<float>(),
  signedRand1<float>());
}

template <typename T>
 inline detail::tvec3<T> signedRand3()
{
 return detail::tvec3<T>(
  signedRand1<float>(),
  signedRand1<float>(),
  signedRand1<float>());
}

template <typename T>
 inline detail::tvec4<T> signedRand4()
{
 return detail::tvec4<T>(
  signedRand1<float>(),
  signedRand1<float>(),
  signedRand1<float>(),
  signedRand1<float>());
}

template <typename T>
 inline detail::tvec2<T> normalizedRand2(
 T Min,
 T Max)
{
    return normalizedRand2<T>() * compRand1(Min, Max);
}

template <typename T>
 inline detail::tvec2<T> normalizedRand2()
{
    T a = compRand1<T>(T(0), T(6.283185307179586476925286766559f));
    return detail::tvec2<T>(cos(a), sin(a));
}

template <typename T>
 inline detail::tvec3<T> normalizedRand3(
 T Min,
 T Max)
{
    return normalizedRand3<T>() * compRand1(Min, Max);
}

template <typename T>
 inline detail::tvec3<T> normalizedRand3()
{
 T z = compRand1(T(-1), T(1));
 T a = compRand1(T(0), T(6.283185307179586476925286766559f));

    T r = sqrt(T(1) - z * z);

 T x = r * cos(a);
 T y = r * sin(a);

    return detail::tvec3<T>(x, y, z);
}

template <>
 inline float compRand1()
{
 return float(std::rand()) / float(2147483647);
}

template <>
 inline double compRand1()
{
 return double(std::rand()) / double(2147483647);
}

 inline detail::half compRand1(
 detail::half Min,
 detail::half Max)
{
 return compRand1<detail::half>() * (Max - Min) + Min;
}

 inline float compRand1(
 float Min,
 float Max)
{
 return compRand1<float>() * (Max - Min) + Min;
}

 inline double compRand1(
 double Min,
 double Max)
{
 return compRand1<double>() * (Max - Min) + Min;
}

template <typename T>
 inline T compRand1(
 T Min,
 T Max)
{
 return T(compRand1<double>() * double(Max - Min) + double(Min));
}

template <typename T>
 inline detail::tvec2<T> compRand2(
 T Min,
 T Max)
{
 return detail::tvec2<T>(
  compRand1(Min, Max),
  compRand1(Min, Max));
}

template <typename T>
 inline detail::tvec3<T> compRand3(
 T Min,
 T Max)
{
 return detail::tvec3<T>(
  compRand1(Min, Max),
  compRand1(Min, Max),
  compRand1(Min, Max));
}

template <typename T>
 inline detail::tvec4<T> compRand4(
 T Min,
 T Max)
{
 return detail::tvec4<T>(
  compRand1(Min, Max),
  compRand1(Min, Max),
  compRand1(Min, Max),
  compRand1(Min, Max));
}

template <typename T>
 inline detail::tvec2<T> compRand2(
 T Min,
 const detail::tvec2<T>& Max)
{
 return detail::tvec2<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y));
}

template <typename T>
 inline detail::tvec3<T> compRand3(
 T Min,
 const detail::tvec3<T>& Max)
{
 return detail::tvec3<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y),
  compRand1(Min.z, Max.z));
}

template <typename T>
 inline detail::tvec4<T> compRand4(
 T Min,
 const detail::tvec4<T>& Max)
{
 return detail::tvec4<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y),
  compRand1(Min.z, Max.z),
  compRand1(Min.w, Max.w));
}

template <typename T>
 inline detail::tvec2<T> compRand2(
 const detail::tvec2<T>& Min,
 T Max)
{
 return detail::tvec2<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y));
}

template <typename T>
 inline detail::tvec3<T> compRand3(
 const detail::tvec3<T>& Min,
 T Max)
{
 return detail::tvec3<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y),
  compRand1(Min.z, Max.z));
}

template <typename T>
 inline detail::tvec4<T> compRand4(
 const detail::tvec4<T>& Min,
 T Max)
{
 return detail::tvec4<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y),
  compRand1(Min.z, Max.z),
  compRand1(Min.w, Max.w));
}

template <typename T>
 inline detail::tvec2<T> compRand2(
 const detail::tvec2<T>& Min,
 const detail::tvec2<T>& Max)
{
 return detail::tvec2<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y));
}

template <typename T>
 inline detail::tvec3<T> compRand3(
 const detail::tvec3<T>& Min,
 const detail::tvec3<T>& Max)
{
 return detail::tvec3<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y),
  compRand1(Min.z, Max.z));
}

template <typename T>
 inline detail::tvec4<T> compRand4(
 const detail::tvec4<T>& Min,
 const detail::tvec4<T>& Max)
{
 return detail::tvec4<T>(
  compRand1(Min.x, Max.x),
  compRand1(Min.y, Max.y),
  compRand1(Min.z, Max.z),
  compRand1(Min.w, Max.w));
}

template <typename T>
 inline detail::tvec2<float> vecRand2()
{
 detail::tvec2<float> result(float(0));
 do
 {
  result = compRand2(float(-1), float(1));
 } while (length(result) > float(1));

    return result;
}

template <typename T>
 inline detail::tvec2<double> vecRand2()
{
 detail::tvec2<double> result(double(0));
 do
 {
  result = compRand2(double(-1), double(1));
 } while (length(result) > double(1));

    return result;
}

template <typename T>
 inline detail::tvec2<T> vecRand2(
 T MinRadius,
 T MaxRadius)
{
 ((MinRadius <= MaxRadius) ? static_cast<void> (0) : __assert_fail ("MinRadius <= MaxRadius", "/usr/include/sgct/glm/gtx/random.inl", 298, __PRETTY_FUNCTION__));

 detail::tvec2<T> Result(T(0));
 T LenRadius(0);

 do
 {
  Result = compRand2(-MaxRadius, MaxRadius);
  LenRadius = length(Result);
 }
 while(LenRadius > MaxRadius || LenRadius < MinRadius);

    return Result;
}

template <typename T>
 inline detail::tvec3<T> vecRand3()
{
 detail::tvec3<T> Result(T(0));
 do
 {
  Result = compRand3(T(-1), T(1));
 }
 while(length(Result) > T(1));

    return Result;
}

template <typename T>
 inline detail::tvec3<T> vecRand3(
 T MinRadius,
 T MaxRadius)
{
 ((MinRadius <= MaxRadius) ? static_cast<void> (0) : __assert_fail ("MinRadius <= MaxRadius", "/usr/include/sgct/glm/gtx/random.inl", 331, __PRETTY_FUNCTION__));

 detail::tvec3<T> Result(0);
 T LenRadius(0);

 do
 {
  Result = compRand3(-MaxRadius, MaxRadius);
  LenRadius = length(Result);
 }
 while(LenRadius > MaxRadius || LenRadius < MinRadius);

    return Result;
}

template <typename T>
 inline detail::tvec4<float> vecRand4()
{
 detail::tvec4<float> result(float(0));
 do
 {
  result = compRand4(float(-1), float(1));
 } while (length(result) > float(1));

    return result;
}

template <typename T>
 inline detail::tvec4<double> vecRand4()
{
 detail::tvec4<double> result(double(0));
 do
 {
  result = compRand4(double(-1), double(1));
 } while (length(result) > double(1));

    return result;
}

template <typename T>
 inline detail::tvec4<T> vecRand4(
 T MinRadius,
 T MaxRadius)
{
 ((MinRadius <= MaxRadius) ? static_cast<void> (0) : __assert_fail ("MinRadius <= MaxRadius", "/usr/include/sgct/glm/gtx/random.inl", 375, __PRETTY_FUNCTION__));

 detail::tvec4<T> Result(T(0));
 T LenRadius(T(0));

 do
 {
  Result = compRand4(-MaxRadius, MaxRadius);
  LenRadius = length(Result);
 }
 while(LenRadius > MaxRadius || LenRadius < MinRadius);

    return Result;
}

template <typename T>
 inline T gaussRand1(
 T mean,
 T std_deviation)
{
    T w, x1, x2;

    do
    {
        x1 = compRand1(T(-1), T(1));
        x2 = compRand1(T(-1), T(1));

        w = x1 * x1 + x2 * x2;
    } while(w > T(1));

    return x2 * std_deviation * std_deviation * sqrt((T(-2) * log(w)) / w) + mean;
}

template <typename T>
 inline detail::tvec2<T> gaussRand2(
 T mean,
 T std_deviation)
{
    return detail::tvec2<T>(
        gaussRand1(mean, std_deviation),
        gaussRand1(mean, std_deviation));
}

template <typename T>
 inline detail::tvec3<T> gaussRand3(
 T mean,
 T std_deviation)
{
    return detail::tvec3<T>(
        gaussRand1(mean, std_deviation),
        gaussRand1(mean, std_deviation),
        gaussRand1(mean, std_deviation));
}

template <typename T>
 inline detail::tvec4<T> gaussRand4(
 T mean,
 T std_deviation)
{
    return detail::tvec4<T>(
        gaussRand1(mean, std_deviation),
        gaussRand1(mean, std_deviation),
        gaussRand1(mean, std_deviation),
        gaussRand1(mean, std_deviation));
}

template <typename T>
 inline detail::tvec2<T> gaussRand2(
 T mean,
 const detail::tvec2<T>& std_deviation)
{
    return detail::tvec2<T>(
        gaussRand1(mean, std_deviation.x),
        gaussRand1(mean, std_deviation.y));
}

template <typename T>
 inline detail::tvec3<T> gaussRand3(
 T mean,
 const detail::tvec3<T>& std_deviation)
{
    return detail::tvec3<T>(
        gaussRand1(mean, std_deviation.x),
        gaussRand1(mean, std_deviation.y),
        gaussRand1(mean, std_deviation.z));
}

template <typename T>
 inline detail::tvec4<T> gaussRand4(
 T mean,
 const detail::tvec4<T>& std_deviation)
{
    return detail::tvec4<T>(
        gaussRand1(mean, std_deviation.x),
        gaussRand1(mean, std_deviation.y),
        gaussRand1(mean, std_deviation.z),
        gaussRand1(mean, std_deviation.w));
}

template <typename T>
 inline detail::tvec2<T> gaussRand2(
 const detail::tvec2<T>& mean,
 T std_deviation)
{
    return detail::tvec2<T>(
        gaussRand1(mean.x, std_deviation),
        gaussRand1(mean.y, std_deviation));
}

template <typename T>
 inline detail::tvec3<T> gaussRand3(
 const detail::tvec3<T>& mean,
 T std_deviation)
{
    return detail::tvec3<T>(
        gaussRand1(mean.x, std_deviation),
        gaussRand1(mean.y, std_deviation),
        gaussRand1(mean.z, std_deviation));
}

template <typename T>
 inline detail::tvec4<T> gaussRand4(
 const detail::tvec4<T>& mean,
 T std_deviation)
{
    return detail::tvec4<T>(
        gaussRand1(mean.x, std_deviation),
        gaussRand1(mean.y, std_deviation),
        gaussRand1(mean.z, std_deviation),
        gaussRand1(mean.w, std_deviation));
}

template <typename T>
 inline detail::tvec2<T> gaussRand2(
 const detail::tvec2<T>& mean,
 const detail::tvec2<T>& std_deviation)
{
    return detail::tvec2<T>(
        gaussRand1(mean.x, std_deviation.x),
        gaussRand1(mean.y, std_deviation.y));
}

template <typename T>
 inline detail::tvec3<T> gaussRand3(
 const detail::tvec3<T>& mean,
 const detail::tvec3<T>& std_deviation)
{
    return detail::tvec3<T>(
        gaussRand1(mean.x, std_deviation.x),
        gaussRand1(mean.y, std_deviation.y),
        gaussRand1(mean.z, std_deviation.z));
}

template <typename T>
 inline detail::tvec4<T> gaussRand4(
 const detail::tvec4<T>& mean,
 const detail::tvec4<T>& std_deviation)
{
    return detail::tvec4<T>(
        gaussRand1(mean.x, std_deviation.x),
        gaussRand1(mean.y, std_deviation.y),
        gaussRand1(mean.z, std_deviation.z),
        gaussRand1(mean.w, std_deviation.w));
}

}
# 106 "/usr/include/sgct/glm/gtx/random.hpp" 2 3 4
# 10 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/omp.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/omp.h" 3 4
typedef struct
{
  unsigned char _x[4]
    __attribute__((__aligned__(4)));
} omp_lock_t;

typedef struct
{
  unsigned char _x[8 + sizeof (void *)]
    __attribute__((__aligned__(sizeof (void *))));
} omp_nest_lock_t;


typedef enum omp_sched_t
{
  omp_sched_static = 1,
  omp_sched_dynamic = 2,
  omp_sched_guided = 3,
  omp_sched_auto = 4
} omp_sched_t;


extern "C" {





extern void omp_set_num_threads (int) throw ();
extern int omp_get_num_threads (void) throw ();
extern int omp_get_max_threads (void) throw ();
extern int omp_get_thread_num (void) throw ();
extern int omp_get_num_procs (void) throw ();

extern int omp_in_parallel (void) throw ();

extern void omp_set_dynamic (int) throw ();
extern int omp_get_dynamic (void) throw ();

extern void omp_set_nested (int) throw ();
extern int omp_get_nested (void) throw ();

extern void omp_init_lock (omp_lock_t *) throw ();
extern void omp_destroy_lock (omp_lock_t *) throw ();
extern void omp_set_lock (omp_lock_t *) throw ();
extern void omp_unset_lock (omp_lock_t *) throw ();
extern int omp_test_lock (omp_lock_t *) throw ();

extern void omp_init_nest_lock (omp_nest_lock_t *) throw ();
extern void omp_destroy_nest_lock (omp_nest_lock_t *) throw ();
extern void omp_set_nest_lock (omp_nest_lock_t *) throw ();
extern void omp_unset_nest_lock (omp_nest_lock_t *) throw ();
extern int omp_test_nest_lock (omp_nest_lock_t *) throw ();

extern double omp_get_wtime (void) throw ();
extern double omp_get_wtick (void) throw ();

void omp_set_schedule (omp_sched_t, int) throw ();
void omp_get_schedule (omp_sched_t *, int *) throw ();
int omp_get_thread_limit (void) throw ();
void omp_set_max_active_levels (int) throw ();
int omp_get_max_active_levels (void) throw ();
int omp_get_level (void) throw ();
int omp_get_ancestor_thread_num (int) throw ();
int omp_get_team_size (int) throw ();
int omp_get_active_level (void) throw ();


}
# 11 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h" 2
# 20 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Types.h"
using glm::vec2;
using glm::vec3;
using glm::vec4;

using glm::uvec2;
using glm::uvec3;
using glm::uvec4;

using glm::ivec2;
using glm::ivec3;
using glm::ivec4;

using glm::mat3;
using glm::mat4;

using glm::quat;


typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long u64;

typedef signed char i8;
typedef signed short i16;
typedef signed int i32;
typedef signed long i64;

typedef glm::detail::float16 f16;
typedef float f32;
typedef double f64;
# 15 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.h" 2
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/Particle.h" 1





class Particle {
public:
    Particle() : life(1.0), invMass(1.0) {}
    Particle(vec3 p, vec3 v, f32 l)
    {
        invMass = 1.0f;
        position = p;
        life = l;
        setVelocity(v);
    }

    void setPosition(vec3 _position){ position = _position; }
    void setVelocity(vec3 _velocity){ oldPosition = position - _velocity; }
    void setForce(vec3 _force){ force = _force; }

    void setLife(f32 _life) { life = _life; }
    void setMass(f32 _mass) { invMass = 1.0f/_mass; }

friend class ParticleSystem;
friend class GravityModifier;
friend class WindModifier;

protected:
    vec3 position;
    vec3 oldPosition;
    vec3 force;

    f32 life;
    f32 invMass;
};
# 16 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.h" 2
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleEmitter.h" 1



class ParticleSystem;


# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.h" 1
# 8 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleEmitter.h" 2

class ParticleEmitter {

 public:

 friend class ParticleSystem;

    ParticleEmitter()
    {
        spawnRate = 10;
        lifeInterval = vec2(0.1, 0.5);
    }

    virtual void emit(ParticleSystem* ps) = 0;
    virtual void draw() {};

    virtual void setSpawnRate(u8 rate) { spawnRate = rate; }
    virtual void setLifeInterval(vec2 interval) { lifeInterval = interval; }

    virtual u8 getSpawnRate() { return spawnRate; }
    virtual vec2 getLifeInterval() { return lifeInterval; }


 protected:
    u8 spawnRate;
    vec2 lifeInterval;
};
# 17 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.h" 2
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleModifier.h" 1






class ParticleModifier {

public:
    virtual void modify(ParticleSystem *ps) = 0;
    virtual void draw() {};
};
# 18 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.h" 2

class ParticleSystem {

 public:

    ParticleSystem();
    virtual ~ParticleSystem();

    virtual void update(f32 deltaTime);
    virtual void draw();

    virtual void createPointEmitter(u8 spawnRate, vec2 lifeInterval, vec3 position, vec2 speedInterval);
    virtual void createConeEmitter(u8 spawnRate, vec2 lifeInterval, vec3 position, vec2 speedInterval, vec3 direction, f32 spreadAngle);

    virtual void createGravityModifier(vec3 position, f32 force);
    virtual void createWindModifier(vec3 position, vec3 force);

friend class ParticleModifier;
friend class GravityModifier;
friend class WindModifier;
friend class ParticleEmitter;
friend class PointEmitter;
friend class ConeEmitter;

 private:

    virtual void createParticle(vec3 position, vec3 velocity, f32 life);
    virtual void updateNeeds();

 private:
    std::vector< Particle > particles;
    std::vector< ParticleModifier* > modifiers;
    std::vector< ParticleEmitter* > emitters;

    u32 currentCount;

    u32 maxCount;
};
# 2 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.cpp" 2
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/PointEmitter.h" 1



class ParticleSystem;






class PointEmitter : public ParticleEmitter {

 public:

    PointEmitter()
    {
        speedInterval = vec2(1.0,2.0);
    }

    PointEmitter(u8 _spawnRate, vec2 _lifeInterval, vec3 _position, vec2 _speedInterval)
    {
        spawnRate = _spawnRate;
        lifeInterval = _lifeInterval;
        position = _position;
        speedInterval = _speedInterval;
    }

    virtual void emit(ParticleSystem *ps);
    virtual void draw();

    virtual void setPosition(vec3 _position) { position = _position; }
    virtual void setSpeedInterval(vec2 interval) { speedInterval = interval; }

    virtual vec3 getPosition() { return position; }
    virtual vec2 getSpeedInterval() { return speedInterval;}

 protected:
    vec3 position;
    vec2 speedInterval;
};
# 3 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.cpp" 2
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ConeEmitter.h" 1
# 9 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ConeEmitter.h"
class ConeEmitter : public PointEmitter {

public:

    ConeEmitter(u8 _spawnRate, vec2 _lifeInterval, vec3 _position, vec2 _speedInterval, vec3 _direction, f32 _spreadAngle)
    {
        spawnRate = _spawnRate;
        lifeInterval = _lifeInterval;
        position = _position;
        speedInterval = _speedInterval;
        direction = _direction;
        spreadAngle = _spreadAngle;
    }

    virtual void emit(ParticleSystem *ps);
    virtual void draw();

    virtual void setDirection(vec3 _direction) { direction = _direction; }
    virtual void setSpreadAngle(f32 _spreadAngle) { spreadAngle = _spreadAngle; }

    virtual vec3 getDirection() { return direction; }
    virtual f32 getSpreadAngle() { return spreadAngle; }


protected:
    vec3 direction;
    f32 spreadAngle;
};
# 4 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.cpp" 2
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/GravityModifier.h" 1
# 9 "/home/robsk789/privat_stuff/TNM090/lab3/qt/GravityModifier.h"
class GravityModifier : public ParticleModifier {
friend class ParticleSystem;

 public:

    GravityModifier(vec3 _position, f32 _force)
    {
        position = _position;
        force = _force;
    }

    virtual void modify(ParticleSystem *ps);
    virtual void draw();

    virtual void setPosition(vec3 _position) { position = _position; }
    virtual void setForce(f32 _force) { force = _force; }

    virtual vec3 getPosition() { return position; }
    virtual f32 getForce() { return force; }


 protected:
    vec3 position;
    f32 force;
};
# 5 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.cpp" 2
# 1 "/home/robsk789/privat_stuff/TNM090/lab3/qt/WindModifier.h" 1
# 9 "/home/robsk789/privat_stuff/TNM090/lab3/qt/WindModifier.h"
class WindModifier : public ParticleModifier {

 public:

    WindModifier()
    {
        force = vec3(1,0,0);
    }

    WindModifier(vec3 _position, vec3 _force)
    {
        setPosition(_position);
        setForce(_force);
    }

    virtual void modify(ParticleSystem *ps);
    virtual void draw();

    virtual void setPosition(vec3 _position) { position = _position; }
    virtual void setForce(vec3 _force) { force = _force; }

    virtual vec3 getPosition() { return position; }
    virtual vec3 getForce() { return force; }


 protected:
    vec3 position;
    vec3 force;
};
# 6 "/home/robsk789/privat_stuff/TNM090/lab3/qt/ParticleSystem.cpp" 2

ParticleSystem::ParticleSystem()
{
    particles.resize(10, Particle());
    currentCount = 0;
    maxCount = 0;
}

ParticleSystem::~ParticleSystem()
{
    emitters.clear();
    modifiers.clear();
}

void ParticleSystem::update(f32 deltaTime)
{





    for(u32 i=0; i<currentCount; i++)
    {
        particles[i].life -= deltaTime;
        if(particles[i].life < 0.0f)
        {
            particles[i] = particles[--currentCount];
        }
    }



    for(u32 i=0; i<emitters.size(); i++)
    {
        emitters[i]->emit(this);
    }




    for(u32 i=0; i<modifiers.size(); i++)
    {
        modifiers[i]->modify(this);
    }

    Particle *p;
    vec3 velocity;
    vec3 acceleration;
    f32 dt2 = deltaTime*deltaTime;




    for(u32 i=0; i<particles.size(); i++)
    {
        p = &particles[i];

        velocity = (p->position - p->oldPosition) + p->force * p->invMass * dt2;
        p->oldPosition = p->position;
        p->position += velocity;
        p->force = vec3(0);
    }
}

void ParticleSystem::draw()
{
    glColor3f(1,1,1);
    glPointSize(1.0f);
    glBegin( 0x0000);
        for(u32 i=0; i<particles.size(); i++)
        {
            glVertex3fv(glm::value_ptr(particles[i].position));
        }
    glEnd();

    for(u32 i=0; i<modifiers.size(); i++)
    {
        modifiers[i]->draw();
    }

    for(u32 i=0; i<emitters.size(); i++)
    {
        emitters[i]->draw();
    }
}

void ParticleSystem::createPointEmitter(u8 spawnRate, vec2 lifeInterval, vec3 position, vec2 speedInterval)
{
    ParticleEmitter *pe = new PointEmitter(spawnRate, lifeInterval, position, speedInterval);
    emitters.push_back(pe);

    updateNeeds();
}

void ParticleSystem::createConeEmitter(u8 spawnRate, vec2 lifeInterval, vec3 position, vec2 speedInterval, vec3 direction, f32 spreadAngle)
{
    ParticleEmitter *pe = new ConeEmitter(spawnRate, lifeInterval, position, speedInterval, direction, spreadAngle);
    emitters.push_back(pe);

    updateNeeds();
}

void ParticleSystem::createGravityModifier(vec3 position, f32 force)
{
    ParticleModifier *pm = new GravityModifier(position, force);
    modifiers.push_back(pm);
}

void ParticleSystem::createWindModifier(vec3 position, vec3 force)
{
    ParticleModifier *pm = new WindModifier(position, force);
    modifiers.push_back(pm);
}

void ParticleSystem::createParticle(vec3 position, vec3 velocity, f32 life)
{
    particles[currentCount++] = Particle(position, velocity, life);
}




void ParticleSystem::updateNeeds()
{
    u32 needs = 0;
    for(u32 i=0; i<emitters.size(); i++)
    {

        needs += (u32)( (f32)emitters[i]->spawnRate * (f32)60 * emitters[i]->lifeInterval[1] * 1.1f );
    }

    particles.resize(needs, Particle());
}
